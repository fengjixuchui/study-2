
对于Rust来说，无法合理处理的情况就必须引发恐慌。比如，使用thread：：spawn无法创建线程只能产生恐慌，也许是平台内存用尽之类的原因，在这种情况下 Result＜T，E＞已经无用。

Rust的恐慌本质上（底层的实现机制）相当于C++异常。C++支持通过throw抛出异常，也可以使用try/catch来捕获异常，但是如果使用不当，就会引起内存不安全的问题，从而造成Bug或比较严重的安全漏洞。使用C++写代码，需要开发人员来保证异常安全（Exception Safety）。

为什么抛出异常有可能产生内存不安全的问题呢？这其实很容易理解。可以想象一个函数，如果执行了一半，突然抛出了异常，那么会发生什么？函数提前返回，异常发生点之后的代码也许就永远不会被调用到，有可能造成资源泄漏和数据结构恶化（比如合法指针变成了悬垂指针）。这就是异常不安全。

异常安全的代码要求就是不能在异常抛出时造成资源泄漏和数据结构恶化。现代C++使用RAII 可以解决此问题，在异常抛出时，利用栈回退（Stack Unwind）机制来确保在栈内构造的局部变量或指针的析构函数都可以被一一调用。这样就可以保证异常安全。

