
# 1. 什么是 trait

trait 是 Rust 的灵魂. Rust 中**所有的抽象**, 比如接口抽象、OOP范式抽象、函数式范式抽象等, 均基于 trait 来完成. 同时, trait也保证了这些抽象几乎都是运行时零开销的.

那么, 到底什么是trait？

从**类型系统**的角度来说, trait 是 Rust **对 Ad-hoc 多态的支持**.

从**语义**上来说, trait 是**在行为上对类型的约束**, 有如下 4 种用法:

* **接口抽象**. **接口**是对**类型行为**的统一约束.
* **泛型约束**. **泛型的行为**被 trait 限定在更有限的范围内.
* **抽象类型**. 在运行时作为一种**间接的抽象类型**去使用, 动态地分发给具体的类型.
* **标签 trait**. 对类型的约束, 可以直接作为一种“**标签**”使用.

# 2. 接口抽象

特点如下:

* **接口**中可以**定义方法**, 并支持**默认实现**
* 接口中**不能实现另一个接口**, 但是接口之间**可以继承**
* **同一个接口**可以同时被**多个类型实现**, 但**不能**被**同一个类型**实现**多次**
* 使用 **trait** 关键字来**定义接口**
* 使用 **impl** 关键字**为类型实现接口方法**

![2021-10-25-21-10-01.png](./images/2021-10-25-21-10-01.png)

`code 2_53` 中的 `Fly trait` 就是一个典型的接口抽象. 类型 Duck 和 Pig 均实现了该 trait, 但具体行为不同. 这正是一种 **Ad-hoc** 多态: **同一个 trait, 在不同上下文中实现的行为不同**.

为不同的类型实现 trait, 属于一种函数重载, 也可以说**函数重载**就是一种 Ad-hoc 多态.

## 2.1. 关联类型

Rust 中的很多操作符都是基于 trait 来实现的.

比如加法操作符就是一个 trait.

### 2.1.1. 结合泛型的 trait

那如何对这个加法操作进行抽象呢? 一个方法是**结合泛型的 trait**.

```rust
trait Add<RHS, Output> {
	fn add(self, rhs: RHS) -> Output;
}
impl Add<i32, i32> for i32 {
	fn add(self, rhs: i32) -> i32 {
		self + rhs
	}
}
impl Add<u32, i32> for u32 {
	fn add(self, rhs: u32) -> i32 {
	    (self + rhs) as i32
	}
}
fn main_3_22() {
	let (a, b, c, d) = (1i32, 2i32, 3u32, 4u32);
	let x: i32 = a.add(b);
	let y: i32 = c.add(d);
	assert_eq!(x, 3i32);
	assert_eq!(y, 7i32);
}
```

### 2.1.2. 缺点

使用 trait 泛型来实现加法抽象, 它有一个**很大的问题**.

一般来说, 对于加法操作要考虑以下**两种情况**：

* **基本数据类型**, 比如 i32 和 i32 类型相加, 出于安全考虑, 结果必然还是 i32 类型
* 对**字符串**进行加法操作, 但是 Rust 中可以**动态增加长度**的**只有 String 类型**的字符串, 所以一般是 String 类型的才会实现 Add, 其**返回值**也必须是 **String** 类型. 但是**加法操作符右侧**也可以是**字符串字面量**. 所以, String 的加法操作还必须实现 `Add<&str, String>`.

不管是以上两种情况中的哪一种, Add 的**第二个类型参数**总是显得有点**多余**. 所以, Rust **标准库**中定义的 `Add trait` 使用了另外一种写法.

### 2.1.3. 标准库中 Add trait 的定义

**标准库**中 Add trait 的定义:

```rust
pub trait Add<Rhs = Self> {
	type Output;
	fn add(self, rhs: Rhs) -> Self::Output;
}
```

第二个类型参数去掉了. 取而代之的是 **type 定义的 Output**, 以这种方式定义的类型叫作**关联类型**. 而 `Add<Rhs = Self>` 这种形式表示**为类型参数 Rhs 指定了默认值 Self**. Self 是**每个 trait** 都带有的**隐式类型参数**, 代表实现**当前 trait 的具体类型**.

当代码中出现操作符 “`+`” 的时候, Rust 就会自动调用**操作符左侧的操作数对应**的 `add（）` 方法, 去完成具体的加法操作, 也就是说 “`+`” 操作与调用 `add（）` 方法是等价的, 如图.

![2021-10-25-22-08-02.png](./images/2021-10-25-22-08-02.png)

标准库中 u32 类型 Add trait 的实现:

```rust
impl Add for $t {
	type Output = $t;
	fn add(self, other: $t) -> $t { self + other }
}
```

`$t` 是宏, 这里可以看作 u32 类型. 如下.

```rust
impl Add for u32 {
	type Output = u32;
	fn add(self, other: u32) -> u32 { self + other }
}
```

这里的**关联类型是 u32**, 因为两个 u32 整数相加结果必然还是 u32 整数. 如果实现 Add trait 时并**未指明泛型参数的具体类型**, 则默认为**Self类型**, 也就是 u32 类型.

String 类型的字符串也支持加号.

标准库中 String 类型 Add trait 的实现(有删减):

```rust
impl Add<&str> for String {
	type Output = String;
	fn add(self, other: &str) -> String {
	    self.push_str(other);
	    self
	}
}
```

关联类型 Output 指定为 String 类型, 意味着加法返回的是String类型.

```rust
fn main_3_27() {
	let a = "hello"; // &str
	let b = " world"; // &str
	let c = a.to_string() + b;
	println!("{:?}", c);
}
```

使用**关联类型**能够使代码变得更加精简, 同时也对方法的**输入**和**输出**进行了很好的**隔离**, 使得代码的可读性大大增强.

在**语义层面**上, 使用关联类型也增强了 trait 表示行为的这种语义, 因为它表示了和**某个行为**（`trait`）**相关联的类型**. 在工程上, 也体现出了高内聚的特点.

## 2.2. trait 一致性

上面 Add trait 的分析可以知道, u32 和 u64 不能直接相加.

```rust
use std::ops::Add;
impl Add<u64> for u32 {
	type Output = u64;
	fn add(self, other: u64) -> Self::Output {
	    (self as u64) + other
	}
}
fn main_3_28() {
	let a = 1u32;
	let b = 2u64;
	assert_eq!(a + b, 3);
}
```

编译出错:

```
error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
```

因为 Rust 遵循一条重要的规则: **孤儿规则**(`Orphan Rule`), 即 **如果要实现某个 trait, 那么该 trait 和要实现该 trait 的那个类型至少有一个要在当前 crate 中定义**.

**Add trait** 和 **u32** 都不是在当前 crate 中定义的, 而是定义于标准库中的. 如果没有孤儿规则的限制, 标准库中 u32 类型的加法行为就会被破坏性地改写, 导致所有使用 u32 类型的 crate 可能产生难以预料的Bug.

要想正常编译通过, 就需要把 Add trait 放到当前 crate 中来定义.

```rust
trait Add_3_29<RHS=Self> {
	type Output;
	fn add_3_29(self, rhs: RHS) -> Self::Output;
}
impl Add_3_29<u64> for u32 {
    type Output = u64;
    fn add_3_29(self, other: u64) -> Self::Output  {
	    (self as u64) + other
    }
}
fn main_3_29() {
	let a = 1u32;
	let b = 2u64;
	assert_eq!(a.add_3_29(b), 3);
}
```

在 impl Add 时候, 将 RHS 和关联类型指定为 u64 类型. 同时用 add, 而非操作符 `+`, 避免调用标准库中的 add.

还可以**在本地创建一个新的类型**, 然后为此新类型实现Add, 这同样不会违反孤儿规则.

```rust
use std::ops::Add;
#[derive(Debug)]
struct Point {
	x: i32,
	y: i32,
}
impl Add for Point {
	type Output = Point;
	fn add(self, other: Point) -> Point {
		Point {
			x: self.x + other.x,
			y: self.y + other.y,
		}
	}
}
fn main_3_30() {
	// Point { x: 3, y: 3 }
	println!("{:?}", Point { x: 1, y: 0 } + Point { x: 2, y: 3 });
}
```

还需要注意, **关联类型 Output 必须指定具体类型**. 函数 add 的返回类型可以写 `Point`, 也可以写 `Self`, 也可以写 `Self::Output`.

## 2.3. trait 继承

Rust 不支持传统面向对象的继承, 但是支持**trait继承**.

在日常编程中, trait 中定义的一些**行为可能会有重复**的情况, 使用trait 继承可以简化编程, 方便组合, 让代码更加优美.




# 3. 泛型约束


## 3.1. trait 限定

## 3.2. 理解 trait 限定

# 4. 抽象类型

## 4.1. trait 对象



# 5. 标签 trait

## 5.1. Sized trait

## 5.2. Copy trait

## 5.3. Send trait 和 Sync trait