
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [类型大小](#类型大小)
  - [可确定大小类型和动态大小类型](#可确定大小类型和动态大小类型)
  - [零大小类型](#零大小类型)
  - [底类型](#底类型)

<!-- /code_chunk_output -->

Rust 是一门强类型且类型安全的静态语言. **Rust 中一切皆表达式，表达式皆有值，值皆有类型**。所以可以说，**Rust 中一切皆类型**.

除了一些基本的**原生类型**和**复合类型**，Rust 把**作用域**也纳入了类型系统，这就是第 4 章将要学到的生命周期标记。还有一些表达式，有时有返回值，有时没有返回值 (也就是只返回单元值), 或者有时返回正确的值，有时返回错误的值，Rust 将这类情况也纳入了类型系统，也就是 `Option＜T＞` 和 `Result＜T,E＞` 这样的**可选类型**，从而强制开发人员必须分别处理这两种情况。一些根本**无法返回值**的情况，比如线程崩溃，break 或 continue 等行为，也都被纳入了类型系统，这种类型叫作 never 类型.

可以说，Rust 的类型系统基本囊括了编程中会遇到的各种情况，一般情况下不会有未定义的行为出现，所以说，Rust 是类型安全的语言.

# 类型大小

编程语言中不同的类型本质上是内存占用空间和编码方式的不同. Rust中没有GC，内存首先由编译器来分配，Rust代码被编译为LLVM IR，其中携带了内存分配的信息。**所以编译器需要事先知道类型的大小，才能分配合理的内存**。

## 可确定大小类型和动态大小类型

Rust中绝大部分类型都是在**编译期可确定大小的类型**（SizedType），比如原生整数类型u32固定是4个字节，u64固定是8个字节，等等，都是可以在编译期确定大小的类型。

然而，Rust也有少量的**动态大小的类型**（Dynamic Sized Type，DST），比如str类型的字符串字面量，编译器不可能事先知道程序中会出现什么样的字符串，所以对于编译器来说，str类型的大小是无法确定的。对于这种情况，Rust提供了**引用类型**，因为引用总会有**固定的且在编译期已知的大小**。字符串切片 `&str` 就是一种引用类型，它由**指针**和**长度信息**组成，如图3-1所示。

`&str` 由指针和长度信息组成:

![2021-10-23-23-38-00.png](./images/2021-10-23-23-38-00.png)

`&str` 存储于**栈**上，**str字符串序列**存储于**堆**上。这里的堆和栈是指不同的内存空间，在第4章会详细介绍。`&str` 由两部分组成：**指针和长度信息**，如代码清单3-1所示。其中**指针是固定大小**的，存储的是 str 字符串序列的**起始地址**，**长度信息**也是**固定大小**的整数。

这样一来，`&str`就变成了可确定大小的类型，**编译器**就可以正确地为其分配**栈内存空间**，str也会在**运行时**在**堆**上开辟内存空间。

```rust
fn code3_1() {
	let str = "Hello Rust"; // type: &str
	let ptr = str.as_ptr(); // type: *const u8
	let len = str.len(); // type: usize
	println!("{:p}", ptr); // 0x55a08f1c8000
	println!("{:?}", len); // 10
}
```

声明了字符串字面量str，通过 `as_ptr（）`和 `len（）` 方法，可以分别获取该**字符串字面量存储的地址**和**长度信息**。这种包含了动态大小类型地址信息和携带了长度信息的指针，叫作**胖指针**（Fat Pointer），所以 `&str` 是一种胖指针。

Rust中的数组 `[T]` 是动态大小类型，编译器难以确定它的大小。

```rust
fn reset3_2(mut arr: [u32]) {
	arr[0] = 5;
	arr[1] = 4;
	arr[2] = 3;
	arr[3] = 2;
	arr[4] = 1;
	println!("reset arr {:?}", arr);
}

fn code3_2() {
	let arr: [u32] = [1, 2, 3, 4, 5];
	reset3_2(arr);
	println!("origin arr {:?}", arr);
}
```

编译报错

```
error[E0277]: the size for values of type `[u32]` cannot be known at compilation time
  --> src/main.rs:24:2
   |
24 |     reset3_2(arr);
   |     ^^^^^^^^ doesn't have a size known at compile-time
```

意思是，编译器无法确定参数 `[u32]` 类型的大小。

两种方式修复, 第一种是函数参数使用 `[u32; 5]` 类型

```rust
// 3-3
fn reset3_3(mut arr: [u32; 5]) { // [u32; 5]
	arr[0] = 5;
	arr[1] = 4;
	arr[2] = 3;
	arr[3] = 2;
	arr[4] = 1;
	println!("reset arr {:?}", arr); // [5, 4, 3, 2, 1]
}

fn code3_3() {
	let arr: [u32; 5] = [1, 2, 3, 4, 5]; // [u32; 5]
	reset3_3(arr);
	println!("origin arr {:?}", arr); // [1, 2, 3, 4, 5]
}
// 3-2 end
```

修改的数组并未影响原来的数组。这是因为u32类型是可复制的类型，实现了Copy trait，所以整个数组也是可复制的。所以当数组被传入函数中时就会被复制一份新的副本。这里值得注意的是，`[u32]` 和 `[u32；5]` 是两种不同的类型。

另一种方式, 使用胖指针. 类似于 `&str`, 只需要将参数类型改为 `&mut [u32]`. `&mut [u32]` 是对 `[u32]` 数组的借用, 会生成一个数组切片 `&[u32]`, 它会携带长度信息.

使用 `&mut [u32]` 作为参数类型:

```rust
fn reset3_4(mut arr: &mut [u32]) { // &mut [u32]
	arr[0] = 5;
	arr[1] = 4;
	arr[2] = 3;
	arr[3] = 2;
	arr[4] = 1;
	// 重置之后, 原始数组为 [5, 4, 3, 2, 1]
	println!("array length {:?}", arr.len()); // 5
	// arr 已经被重置为 [5, 4, 3, 2, 1]
	println!("reset array {:?}", arr); // [5, 4, 3, 2, 1]
}

fn code3_4() {
	let mut arr= [1, 2, 3, 4, 5]; // [u32; 5]
	// 重置之前, 原始数组为 [1, 2, 3, 4, 5]
	println!("reset before: origin array {:?}", arr); // [1, 2, 3, 4, 5]
	{
	    let mut_arr: &mut[u32] = &mut arr; // &mut [u32]
	    reset3_4(mut_arr);
	}
	println!("reset after: origin array {:?}", arr); // [5, 4, 3, 2, 1]
}
```

使用了 `&mut [u32]`，它是可变借用，`&[u32]` 是不可变借用。因为这里要修改数组元素，所以使用可变借用。

胖指针 `&mut [u32]` 包含了长度信息。将引用当作函数参数，意味着被修改的是原数组，而不是最新的数组，所以原数组在 reset 之后也发生了改变。

比较 `&[u32；5]` 和 `&mut [u32]` 两种类型的空间占用情况:

```rust
fn code3_5() {
    assert_eq!(std::mem::size_of::<&[u32; 5]>(), 8);
    assert_eq!(std::mem::size_of::<&mut [u32]>(), 16);
}
```
`std::mem::size_of::<&[u32; 5]>()` 函数可以返回类型的字节数. `&[u32; 5]` 类型是普通指针, 占 8 字节; `&mut [u32]` 类型为胖指针, 占 16 字节. 整整多了一倍的占用空间, 所以叫胖指针.

## 零大小类型

除了可确定大小类型和 DST 类型，Rust还支持**零大小类型**（`Zero Sized Type`，ZST），比如**单元类型**和**单元结构体**，大小都是零.

一组零大小的类型示例:

```rust
enum Void3_6 {}
struct Foo3_6;
struct Baz3_6 {
	foo: Foo3_6,
	qux: (),
	baz: [u8; 0],
}
fn main3_6() {
	assert_eq!(std::mem::size_of::<()>(), 0);
	assert_eq!(std::mem::size_of::<Foo3_6>(), 0);
	assert_eq!(std::mem::size_of::<Baz3_6>(), 0);
	assert_eq!(std::mem::size_of::<Void3_6>(), 0);
	assert_eq!(std::mem::size_of::<[(); 10]>(), 0);
}
```

单元类型和单元结构体大小为零，由**单元类型**组成的**数组大小也为零**。

ZST 类型的特点是，它们的**值就是其本身**，运行时并**不占用内存空间**。ZST类型代表的意义正是“**空**”。

使用单元类型**查看数据类型**的一个技巧:

```rust
fn main3_7() {
	let v: () = vec![(); 10];
}
```

编译报错如下:

```
|
|     let v: () = vec![(); 10];
|            --   ^^^^^^^^^^^^ expected `()`, found struct `Vec`
|            |
|            expected due to this
|
```

提示: 期望的是单元类型, 但是却发现 `struct Vec`. 这样我们就知道了右值 `vec![(); 10]` 是向量类型.

使用 `Vec<()>` 迭代类型的迭代技巧:

```rust
fn main3_8() {
	let v: Vec<()> = vec![(); 10];
	for i in v {
		println!("{:?}", i); // ()
	}
}
```

使用了 `Vec＜()＞` 类型，使用单元类型制造了一个长度为 10 的向量. 在一些**只需要迭代次数的场合**中，使用这种方式能获得**较高的性能**。因为 Vec 内部迭代器中会针对 ZST 类型做一些优化。

另外一个使用单元类型的示例是前面 `2.8` 中 `2_48` 的 Rust 官方标准库中的 `HashSet<T>` 和 `BTreeSet<T>`. 它们其实只是将 `HashMap<K, T>` 换成了 `HashMap<K, ()>`, 然后就可以公用 `HashMap<K, T>` 之前的代码, 而不需要重新实现一遍 `HashSet<T>` 了.

## 底类型

