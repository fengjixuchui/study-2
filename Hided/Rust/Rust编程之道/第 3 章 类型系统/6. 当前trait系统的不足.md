
虽然当前的trait系统很强大，但依然有很多需要改进的地方，主要包括以下三点:

* 孤儿规则的局限性
* 代码复用的效率不高
* 抽象表达能力有待改进

# 孤儿规则的局限性

在设计 trait 时，还需要考虑**是否会影响下游的使用者**。

比如在标准库实现一些trait时，还需要考虑**是否**需要为**所有**的 **T** 或 `&'a T` **实现该 trait**:

```rust
impl<T: Foo> Bar_3_73 for T { }
impl<'a, T: Bar_3_73> Bar_3_73 for &'a T { }
```

对于下游的子 crate, 要**避免孤儿规则**, **必须**使用 **NewType** 模式或其他方式**将远程类型包装成本地类型**.

另外，对于**一些本地类型**，如果将其**放到一些容器**中，比如 `Rc＜T＞` 或 `Option＜T＞`，那么这些**本地类型**就会变成**远程类型**（如下代码），因为**这些容器类型**都是在**标准库**中定义的，而**非本地**。

`Option<T>` 会**将本地类型变成远程类型**:

```rust
//use std::ops::Add;
#[derive(PartialEq)]
struct Int3_74(i32);
impl Add<i32> for Int3_74 {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
// impl Add<i32> for Option<Int3_74> {
//     // TODO
// }
impl Add<i32> for Box<Int3_74> {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
fn main_3_74() {
	assert_eq!(Int3_74(3) + 3, 6);
	assert_eq!(Box::new(Int3_74(3)) + 3, 6);
}
```

在**本地**创建了**自定义类型 Int**，然后为其**实现 Add trait**。Add trait 是定义于**标准库**中的，Int是在本地的，所以并**不违反孤儿规则**。

但是当给 `Option＜Int＞` 实现 Add 时，编译器就会报错，因为**触发了孤儿规则**。

但是当给 `Box＜Int＞` 实现 Add 时，则可以**正常编译执行**。看到这里是不是有些困惑？

这是因为`Box＜T＞`在Rust中属于**最常用的类型**，经常会遇到像上面代码的情况：从子 crate 为 `Box＜Int＞` 这种自定义类型扩展 trait 实现。标准库中根本做不到覆盖所有的 crate 中的各种可能性，所以必须将 `Box＜T＞` 开放出来，**脱离孤儿规则的限制**，否则就会**限制子 crate** 要实现的一些功能。

那么，`Box＜T＞`是怎么做到如此特殊的呢？这其实是因为 Rust内部使用了一个叫 `#[fundamental]` 的**属性标识**，Box＜T＞的实现源码如下。

```rust
#[fundamental]
pub struct Box<T: ?Sized>(Unique<T>);
```

该属性的作用就是告诉编译器，`Box＜T＞`享有“特权”，**不必遵循孤儿规则**。

还有Fn、FnMut、FnOnce、Sized等都加上了`#[fundamental]`属性，代表这些trait也同样不受孤儿规则的限制。所以，在阅读Rust源码的时候，如果看到**该属性标识**，就应该知道它和孤儿规则有关。

# 代码复用的效率不高

除了孤儿规则，Rust 其实还遵循另外一条规则：**重叠**（Overlap）**规则**。该规则规定了**不能为重叠的类型实现同一个 trait**。

什么叫重叠的类型？如代码

```rust
impl<T> AnyTrait for T {...}
impl<T> AnyTrait for T where T: Copy {...}
impl<T> AnyTrait for i32 {...}
```

分别为三种类型实现了AnyTrait。

* `T` 是**泛型**，指代**所有的类型**。
* `T where T：Copy` 是**受 trait 限定约束**的**泛型 T**，指代**实现了 Copy trait 的类型 T**，是**所有类型的子集**。
* i32 是一个**具体的类型**。

显而易见，上面三种类型发生了**重叠**。T **包含**了 `T：Copy`，而 `T：Copy` **包含**了 **i32**。这**违反了重叠规则**，所以编译会失败。这种实现 trait 的方式在 Rust 中叫**覆盖式实现**（`Blanket Impl`）。

重叠规则和孤儿规则一样，都是为了**保证 trait 一致性**，避免发生混乱，但是它也带来了一些问题，主要包括以下两个方面:

* 性能问题。
* 代码很难重用

性能会有什么问题呢？且看一个示例:

```rust
impl<R, T: Add<R> + Clone> AddAssign<R> for T {
	fn add_assign(&mut self, rhs: R) {
	    let tmp = self.clone() + rhs;
	    *self = tmp;
	}
}
```

为所有类型 T 实现了 AddAssign，该trait定义的 add_assign 方法是 `+=` 赋值操作对应的方法。这样实现虽然好，但是会带来性能问题，因为会强制所有类型都使用 clone 方法，clone 方法会有一定的成本开销，但实际上有的类型并不需要 clone。因为有重叠规则的限制，不能为某些不需要clone 的具体类型重新实现add_assign方法。所以，在标准库中，为了实现更好的性能，只好为每个具体的类型都各自实现一遍AddAssign。

从上面可以看出来, **重叠规则严重影响了代码的复用**。试想一下，如果没有重叠规则，则可以默认使用上面对泛型 T 的实现，然后对不需要 clone 的类型重新实现AddAssign，那么就完全没必要为每个具体类型都实现一遍add_assign方法，可以省掉很多重复代码。当然，此处只是为了说明重叠规则的问题，实际上在标准库中会使用宏来简化具体的实现代码。



# 抽象表达能力有待改进

