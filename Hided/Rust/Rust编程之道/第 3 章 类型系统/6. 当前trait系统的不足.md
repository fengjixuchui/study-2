
虽然当前的trait系统很强大，但依然有很多需要改进的地方，主要包括以下三点:

* 孤儿规则的局限性
* 代码复用的效率不高
* 抽象表达能力有待改进

# 孤儿规则的局限性

在设计 trait 时，还需要考虑**是否会影响下游的使用者**。

比如在标准库实现一些trait时，还需要考虑**是否**需要为**所有**的 **T** 或 `&'a T` **实现该 trait**:

```rust
impl<T: Foo> Bar_3_73 for T { }
impl<'a, T: Bar_3_73> Bar_3_73 for &'a T { }
```

对于下游的子 crate, 要**避免孤儿规则**, **必须**使用 **NewType** 模式或其他方式**将远程类型包装成本地类型**.

另外，对于**一些本地类型**，如果将其**放到一些容器**中，比如 `Rc＜T＞` 或 `Option＜T＞`，那么这些本地类型就会变成**远程类型**（如下代码），因为**这些容器类型**都是在**标准库**中定义的，而**非本地**。

```rust
//use std::ops::Add;
#[derive(PartialEq)]
struct Int3_74(i32);
impl Add<i32> for Int3_74 {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
// impl Add<i32> for Option<Int3_74> {
//     // TODO
// }
impl Add<i32> for Box<Int3_74> {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
fn main_3_74() {
	assert_eq!(Int3_74(3) + 3, 6);
	assert_eq!(Box::new(Int3_74(3)) + 3, 6);
}
```


# 代码复用的效率不高



# 抽象表达能力有待改进

