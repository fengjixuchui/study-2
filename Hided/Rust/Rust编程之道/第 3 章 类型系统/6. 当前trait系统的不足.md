
虽然当前的trait系统很强大，但依然有很多需要改进的地方，主要包括以下三点:

* 孤儿规则的局限性
* 代码复用的效率不高
* 抽象表达能力有待改进

# 孤儿规则的局限性

在设计 trait 时，还需要考虑**是否会影响下游的使用者**。

比如在标准库实现一些trait时，还需要考虑**是否**需要为**所有**的 **T** 或 `&'a T` **实现该 trait**:

```rust
impl<T: Foo> Bar_3_73 for T { }
impl<'a, T: Bar_3_73> Bar_3_73 for &'a T { }
```

对于下游的子 crate, 要**避免孤儿规则**, **必须**使用 **NewType** 模式或其他方式**将远程类型包装成本地类型**.

另外，对于**一些本地类型**，如果将其**放到一些容器**中，比如 `Rc＜T＞` 或 `Option＜T＞`，那么这些**本地类型**就会变成**远程类型**（如下代码），因为**这些容器类型**都是在**标准库**中定义的，而**非本地**。

`Option<T>` 会**将本地类型变成远程类型**:

```rust
//use std::ops::Add;
#[derive(PartialEq)]
struct Int3_74(i32);
impl Add<i32> for Int3_74 {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
// impl Add<i32> for Option<Int3_74> {
//     // TODO
// }
impl Add<i32> for Box<Int3_74> {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
fn main_3_74() {
	assert_eq!(Int3_74(3) + 3, 6);
	assert_eq!(Box::new(Int3_74(3)) + 3, 6);
}
```

在**本地**创建了**自定义类型 Int**，然后为其**实现 Add trait**。Add trait 是定义于**标准库**中的，Int是在本地的，所以并**不违反孤儿规则**。

但是当给 `Option＜Int＞` 实现 Add 时，编译器就会报错，因为**触发了孤儿规则**。

但是当给 `Box＜Int＞` 实现 Add 时，则可以**正常编译执行**。看到这里是不是有些困惑？

这是因为`Box＜T＞`在Rust中属于**最常用的类型**，经常会遇到像上面代码的情况：从子 crate 为 `Box＜Int＞` 这种自定义类型扩展 trait 实现。标准库中根本做不到覆盖所有的 crate 中的各种可能性，所以必须将 `Box＜T＞` 开放出来，**脱离孤儿规则的限制**，否则就会**限制子 crate** 要实现的一些功能。

那么，`Box＜T＞`是怎么做到如此特殊的呢？这其实是因为 Rust内部使用了一个叫 `#[fundamental]` 的**属性标识**，Box＜T＞的实现源码如下。

```rust
#[fundamental]
pub struct Box<T: ?Sized>(Unique<T>);
```

该属性的作用就是告诉编译器，`Box＜T＞`享有“特权”，**不必遵循孤儿规则**。

还有Fn、FnMut、FnOnce、Sized等都加上了`#[fundamental]`属性，代表这些trait也同样不受孤儿规则的限制。所以，在阅读Rust源码的时候，如果看到**该属性标识**，就应该知道它和孤儿规则有关。


# 代码复用的效率不高



# 抽象表达能力有待改进

