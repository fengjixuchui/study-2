
# 泛型

泛型（Generic）是一种参数化多态。使用泛型可以编写更为抽象的代码，减少工作量。

简单来说，泛型就是**把一个泛化的类型作为参数**，单个类型就可以抽象化为一簇类型。`Box＜T>`、`Option＜T>` 和 `Result＜T，E>` 等，都是泛型类型。

# 泛型函数

除了定义类型，泛型也可以应用于函数中.

```rust
fn foo3_16<T>(x: T) -> T {
	return x;
}

fn main3_16() {
	assert_eq!(foo3_16(1), 1);
	assert_eq!(foo3_16("hello"), "hello");
}
```

也可以在结构体中使用泛型.

```rust
struct  Point3_17<T> { x: T, y: T }
```

与枚举类型和函数一样，结构体名称旁边的`＜T>`叫作**泛型声明**。**泛型只有被声明之后才可以被使用**。

在**为泛型结构体实现具体方法**的时候，也需要**声明泛型类型**.

```rust
#[derive(Debug, PartialEq)]
struct Point3_18<T> { x: T, y: T }
impl<T> Point3_18<T> {
	fn new(x: T, y: T) -> Self {
		Point3_18{ x: x, y: y }
	}
}
fn main3_18() {
	let point1 = Point3_18::new(1, 2);
	let point2 = Point3_18::new("1", "2");
	assert_eq!(point1, Point3_18{ x: 1, y: 2 });
	assert_eq!(point2, Point3_18{ x: "1", y: "2" });
}
```

上面 `impl<T>`, 必须声明泛型 T.

Rust 标准库中提供的各种容器类型大多是泛型类型. 比如向量 `Vec<T>` 就是一个泛型结构体.

```rust
pub struct Vec<T> {
	buf: RawVec<T>,
	len: usize,
}
```


