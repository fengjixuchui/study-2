
在编程语言中, 类型转换分为:

* **隐式类型转换**(`Implicit TypeConversion`), 由**编译器**或**解释器**自动完成, 开发者并未参与, 所以又称之为**强制类型转换**(`Type Coercion`)
* **显式类型转换**(`Explicit TypeConversion`), 由**开发者指定的**, 就是一般意义上的类型转换(`Type Cast`)

Rust语言, 只要不乱用 **unsafe** 块来**跳过编译器检查**, 就不会因为类型转换出现安全问题.

# 1. Deref 解引用

一般来说, **引用**使用 `&` 操作符, 而**解引用**使用 `*` 操作符. 

Rust 中的隐式类型转换基本上只有**自动解引用**. 主要目的是方便开发者使用**智能指针**. 

Rust 中提供的 `Box<T>`、`Rc<T>`和 `String` 等类型, 实际上是一种**智能指针**. 它们的行为就像指针一样, 可以通过“**解引用**”操作符进行解引用, 获取其**内部的值**. 

第4章会介绍关于智能指针的更多细节. 

## 1.1. 自动解引用

自动解引用虽然是编译器来做的, 但是**自动解引用的行为**可以由开发者**自定义**. 

可以通过**实现 Deref trait** 来**自定义解引用操作**. 

Deref 有一个特性是**强制隐式转换**, 规则是这样的：如果**一个类型 T 实现**了`Deref<Target=U>`, 则**该类型 T 的引用**(或智能指针)在**应用**的时候会**被自动转换为类型U**. 

> 什么叫应用的时候? 都是 `&A` -> `XX`

Deref trait内部实现:

```rust
pub trait Deref {
	type Target: ?Sized;
	fn deref(&self) -> &Self::Target;
}
pub trait DerefMut: Deref {
	fn deref_mut(&mut self) -> &mut Self::Target;
}
```

> `&self` -> `&(Self::Target)`

DerefMut 和 Deref 类似, 只不过它是**返回可变引用**的. Deref中包含**关联类型 Target**, 它表示**解引用之后的目标类型**. 

String 类型实现了 Deref. 比如下面代码连接了两个String字符串. 

```rust
fn main_3_58() {
	let a = "hello".to_string(); // Sring
	let b = " world".to_string(); // String
	let c = a + &b; // String + &String = String
	print!("{:?}", c); // "hello world"
}
```

> `&String` -> `&str`

使用了 `&b`, 它是一个 `&String` 类型, 而 **String 类型**实现的 **add 方法**的**右值参数必须是 &str 类型**. 

按理说, 代码**应该编译出错**, 但现在它是可以正常运行的. 原因就是 **String 类型**实现了 `Deref<Target=str>`, 下面代码展示了其内部实现. 

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&self) -> &str {
        unsafe { str::from_utf8_unchecked(&self.vec) }
    }
}
```

所以 `&String` 类型会被**自动隐式转换**为 `&str`. 

> 为什么自动调用了 解引用

除了String类型, 标准库中常用的其他类型都实现了 Deref, 比如 `Vec<T>`、`Box<T>`、`Rc<T>`、`Arc<T>` 等. 实现 Deref 的目的只有一个, 就是简化编程. 

`Vec<T>` 实现 Deref:

```rust
fn foo_3_60(s: &[i32]) {
	println!("{:?}", s[0]);
}

fn main_3_60() {
	let v = vec![1, 2, 3]; // Vec<i32>
	foo_3_60(&v) // &v = &Vec<{integer}>
}
```

foo 函数的**参数**为 `&[T]` 类型. 而在调用 `foo(&v)` 的时候, `&v` 的类型为 `&Vec<T>`, 这里也发生了**自动解引用**, 因为 `Vec<T>` 实现了 `Deref<Target=[T]>`, 所以 `&Vec<T>` 会被自动转换为 `&[T]` 类型, foo 函数得以正确调用.

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T, A: Allocator> ops::Deref for Vec<T, A> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }
    }
}
```

> `&Vec<T>` -> `&[T]`

函数调用时, 自动解引用也提供了极大的方便. **Rc 指针**实现了 **Deref**, 使函数调用变得非常方便. 

```rust
use std::rc::Rc;
fn main_3_61() {
    let x = Rc::new("hello"); // Rc<&str>
    println!("{:?}", x.chars()); // Chars(['h', 'e', 'l', 'l', 'o'])
    println!("{:?}", &x.chars()); // Chars(['h', 'e', 'l', 'l', 'o'])
}
```

> 注意这里 x 是 `Rc<&str>`, 但是 Deref 是对**引用类型**进行的, 这里很明显**有其他语法**.

变量 x 是 `Rc<&str>` 类型, 它并没有实现过 `chars()` 方法. 但是现在可以**直接调用**, 因为 `Rc<T>` 实现了 `Deref<Target<T>>`. 

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> Deref for Rc<T> {
    type Target = T;

    #[inline(always)]
    fn deref(&self) -> &T {
        &self.inner().value
    }
}
```

`&Rc<&str>`(`&x`) -> `&&str`, T 是 `&str`

## 1.2. 手动解引用

但在有些情况下，就算实现了 Deref，编译器也不会自动解引用。`code 3_61` 是因为 Rc 没有 chars 方法, 所以


```rust

```

# 2. as 操作符



## 2.1. 无歧义完全限定语法



## 2.2. 类型和子类型相互转换



# 3. From 和 Into




