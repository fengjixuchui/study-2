
在编程语言中，类型转换分为:

* **隐式类型转换**（`Implicit TypeConversion`）, 由**编译器**或**解释器**自动完成，开发者并未参与，所以又称之为**强制类型转换**（`Type Coercion`）。
* **显式类型转换**（`Explicit TypeConversion`）, 由**开发者指定的**，就是一般意义上的类型转换（`Type Cast`）

Rust语言，只要不乱用 **unsafe** 块来**跳过编译器检查**，就不会因为类型转换出现安全问题.

# Deref 解引用

一般来说，**引用**使用 `&` 操作符，而**解引用**使用 `*` 操作符。

Rust 中的隐式类型转换基本上只有**自动解引用**。主要目的是方便开发者使用**智能指针**。

Rust 中提供的 `Box＜T＞`、`Rc＜T＞`和 `String` 等类型，实际上是一种**智能指针**。它们的行为就像指针一样，可以通过“**解引用**”操作符进行解引用，获取其**内部的值**。

第4章会介绍关于智能指针的更多细节。

## 自动解引用

自动解引用虽然是编译器来做的，但是**自动解引用的行为**可以由开发者**自定义**。

可以通过**实现 Deref trait** 来**自定义解引用操作**。

Deref 有一个特性是**强制隐式转换**，规则是这样的：如果**一个类型 T 实现**了`Deref＜Target=U＞`，则**该类型 T 的引用**（或智能指针）在**应用**的时候会**被自动转换为类型U**。

> 什么叫应用的时候?

Deref trait内部实现:

```rust
pub trait Deref {
	type Target: ?Sized;
	fn deref(&self) -> &Self::Target;
}
pub trait DerefMut: Deref {
	fn deref_mut(&mut self) -> &mut Self::Target;
}
```

DerefMut 和 Deref 类似，只不过它是**返回可变引用**的。Deref中包含**关联类型 Target**，它表示解引用之后的目标类型。

String 类型实现了 Deref。比如下面代码连接了两个String字符串。

```rust
fn main_3_58() {
	let a = "hello".to_string(); // Sring
	let b = " world".to_string(); // String
	let c = a + &b; // String + &String
	print!("{:?}", c); // "hello world"
}
```

变量 a 和 b 都是 **String** 类型字符串，当使用加号操作符将它们连接起来时，我们使用了 `&b`，它应该是一个 `&String` 类型，而 **String 类型**实现的 **add 方法**的**右值参数必须是 &str 类型**。

按理说，代码**应该编译出错**，但现在它是可以正常运行的。原因就是 **String 类型**实现了 `Deref＜Target=str＞`，下面代码展示了其内部实现。

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&self) -> &str {
        unsafe { str::from_utf8_unchecked(&self.vec) }
    }
}
```

所以 `&String` 类型会被**自动隐式转换**为 `&str`. 

> 为什么自动调用了 解引用

除了String类型，标准库中常用的其他类型都实现了 Deref，比如 `Vec＜T＞`（其实现Deref的代码参见代码 3-60）、Box＜T＞、Rc＜T＞、Arc＜T＞等。实现 Deref 的目的只有一个，就是简化编程。

`Vec<T>` 实现 Deref:

```rust
fn foo_3_60(s: &[i32]) {
	println!("{:?}", s[0]);
}

fn main_3_60() {
	let v = vec![1, 2, 3];
	foo_3_60(&v) // &Vec<{integer}>
}
```

foo 函数的**参数**为 `&[T]` 类型。而在调用 `foo（&v）` 的时候，`&v` 的类型为 `&Vec＜T＞`，这里也发生了**自动解引用**，因为 `Vec＜T＞` 实现了 `Deref＜Target=[T]＞`，所以 `&Vec＜T＞` 会被自动转换为 `&[T]` 类型，foo 函数得以正确调用.

函数调用时，自动解引用也提供了极大的方便. Rc 指针实现了Deref，使函数调用变得非常方便。

```rust
use std::rc::Rc;
fn main_3_61() {
    let x = Rc::new("hello");
    println!("{:?}", x.chars()); // Chars(['h', 'e', 'l', 'l', 'o'])
}
```

