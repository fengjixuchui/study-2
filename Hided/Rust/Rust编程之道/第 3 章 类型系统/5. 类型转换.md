
在编程语言中, 类型转换分为:

* **隐式类型转换**(`Implicit TypeConversion`), 由**编译器**或**解释器**自动完成, 开发者并未参与, 所以又称之为**强制类型转换**(`Type Coercion`)
* **显式类型转换**(`Explicit TypeConversion`), 由**开发者指定的**, 就是一般意义上的类型转换(`Type Cast`)

Rust语言, 只要不乱用 **unsafe** 块来**跳过编译器检查**, 就不会因为类型转换出现安全问题.

# 1. Deref 解引用

一般来说, **引用**使用 `&` 操作符, 而**解引用**使用 `*` 操作符.

Rust 中的隐式类型转换基本上只有**自动解引用**. 主要目的是方便开发者使用**智能指针**.

Rust 中提供的 `Box<T>`、`Rc<T>`和 `String` 等类型, 实际上是一种**智能指针**. 它们的行为就像指针一样, 可以通过“**解引用**”操作符进行解引用, 获取其**内部的值**.

第4章会介绍关于智能指针的更多细节.

## 1.1. 自动解引用

自动解引用虽然是编译器来做的, 但是**自动解引用的行为**可以由开发者**自定义**.

可以通过**实现 Deref trait** 来**自定义解引用操作**.

Deref 有一个特性是**强制隐式转换**, 规则是这样的:如果**一个类型 T 实现**了`Deref<Target=U>`, 则**该类型 T 的引用**(或智能指针)在**应用**的时候会**被自动转换为类型U**.

> 什么叫应用的时候? 都是 `&A` -> `XX`

Deref trait内部实现:

```rust
pub trait Deref {
	type Target: ?Sized;
	fn deref(&self) -> &Self::Target;
}
pub trait DerefMut: Deref {
	fn deref_mut(&mut self) -> &mut Self::Target;
}
```

> `&self` -> `&(Self::Target)`

DerefMut 和 Deref 类似, 只不过它是**返回可变引用**的. Deref中包含**关联类型 Target**, 它表示**解引用之后的目标类型**.

String 类型实现了 Deref. 比如下面代码连接了两个String字符串.

```rust
fn main_3_58() {
	let a = "hello".to_string(); // Sring
	let b = " world".to_string(); // String
	let c = a + &b; // String + &String = String
	print!("{:?}", c); // "hello world"
}
```

> `&String` -> `&str`

使用了 `&b`, 它是一个 `&String` 类型, 而 **String 类型**实现的 **add 方法**的**右值参数必须是 &str 类型**.

按理说, 代码**应该编译出错**, 但现在它是可以正常运行的. 原因就是 **String 类型**实现了 `Deref<Target=str>`, 下面代码展示了其内部实现.

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&self) -> &str {
        unsafe { str::from_utf8_unchecked(&self.vec) }
    }
}
```

所以 `&String` 类型会被**自动隐式转换**为 `&str`.

> 为什么自动调用了 解引用

除了String类型, 标准库中常用的其他类型都实现了 Deref, 比如 `Vec<T>`、`Box<T>`、`Rc<T>`、`Arc<T>` 等. 实现 Deref 的目的只有一个, 就是简化编程.

`Vec<T>` 实现 Deref:

```rust
fn foo_3_60(s: &[i32]) {
	println!("{:?}", s[0]);
}

fn main_3_60() {
	let v = vec![1, 2, 3]; // Vec<i32>
	foo_3_60(&v) // &v = &Vec<{integer}>
}
```

foo 函数的**参数**为 `&[T]` 类型. 而在调用 `foo(&v)` 的时候, `&v` 的类型为 `&Vec<T>`, 这里也发生了**自动解引用**, 因为 `Vec<T>` 实现了 `Deref<Target=[T]>`, 所以 `&Vec<T>` 会被自动转换为 `&[T]` 类型, foo 函数得以正确调用.

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T, A: Allocator> ops::Deref for Vec<T, A> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }
    }
}
```

> `&Vec<T>` -> `&[T]`

函数调用时, 自动解引用也提供了极大的方便. **Rc 指针**实现了 **Deref**, 使函数调用变得非常方便.

```rust
use std::rc::Rc;
fn main_3_61() {
    let x = Rc::new("hello"); // Rc<&str>
    println!("{:?}", x.chars()); // Chars(['h', 'e', 'l', 'l', 'o'])
    println!("{:?}", &x.chars()); // Chars(['h', 'e', 'l', 'l', 'o'])
}
```

> 注意这里 x 是 `Rc<&str>`, 但是 Deref 是对**引用类型**进行的, 这里很明显**有其他语法**.

变量 x 是 `Rc<&str>` 类型, 它并没有实现过 `chars()` 方法. 但是现在可以**直接调用**, 因为 `Rc<T>` 实现了 `Deref<Target<T>>`.

```rust
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: ?Sized> Deref for Rc<T> {
    type Target = T;

    #[inline(always)]
    fn deref(&self) -> &T {
        &self.inner().value
    }
}
```

`&Rc<&str>`(`&x`) -> `&&str`, T 是 `&str`

## 1.2. 手动解引用

但在有些情况下，就算实现了 Deref，编译器也不会自动解引用. `code 3_61` 是因为 Rc 没有 chars 方法, 所以会正常解引用, 但是当某类型和其解引用目标类型中包含了相同的方法时, 编译器就不知道该用哪一个了. 此时就需要手动解引用.

```rust
fn main_3_62() {
	let x = Rc::new("hello");
	let y = x.clone(); // Rc<&str>
	let z = (*x).clone(); // &str
}
```

clone方法在 Rc 和 &str 类型中都被实现了，所以调用时会直接调用Rc的clone方法，如果想调用 Rc 里面 &str 类型的 clone 方法，则需要使用“解引用”操作符手动解引用.

另外，match引用时也需要手动解引用，如代码清单3-63所示.

```rust
fn main_3_63() {
	let x = "hello".to_string(); // type x = String
	match &x { // &x = &String
		"hello" => { println!("hello") },
		_ => ()
	}
}
```

```
error[E0308]: mismatched types
   --> src/main.rs:539:3
    |
538 |     match &x { // &x = &String
    |           -- this expression has type `&String`
539 |         "hello" => { println!("hello") },
    |         ^^^^^^^ expected struct `String`, found `str`
    |
    = note:   expected type `&String`
            found reference `&'static str`
```

只能通过手动解引用把 &String 类型转换成 &str 类型，具体有下列几种方式.

* `match x.deref()`，直接调用deref方法，需要 `use std::ops::Deref`.
* `match x.as_ref()`，String 类型提供了 `as_ref` 方法来返回一个 `&str` 类似，该方法定义于 AsRef trait 中.
* `match x.borrow()`，方法borrow定义于Borrow trait中，行为和AsRef类型一样. 需要 `use std::borrow::Borrow`.
* `match &*x`，使用“解引用”操作符，将String转换为str，然后再用“引用”操作符转为&str.
* `match &x[..]`，这是因为String类型的index操作可以返回&str类型.

总体来说，除了自动解引用隐式转换，Rust还提供了不少显式的手动转换类型的方式. 平时编程还是要多翻阅标准库文档.

# 2. as 操作符

as 操作符最常用的场景就是转换 Rust 中的基本数据类型. 需要注意的是，as 关键字不支持重载. 原生类型使用as操作符进行转换的代码如代码清单3-64所示.

```rust
fn main_3_64() {
	let a = 1u32; // u32
	let b = a as u64; // u64
	let c = 3u64; // u64
	let d = c as u32; // u32
}
```

短(大小)类型转换为长(大小)类型的时候是没有问题的，但是如果反过来，则会被截断处理, 如下代码.

```rust
fn main_3_65() {
	let a = std::u32::MAX;
	let b = a as u16;
	assert_eq!(b, 65535);
	let e = -1i32;
	let f = e as u32;
	println!("{:?}", e.abs()); // 1
	println!("{:?}", f); // 4294967295
}
```

变量a被赋予了u32类型的最大值，当转换为u16类型的时候，被截断处理，变量b的值就变成了u16类型的最大值. 另外当从有符号类型向无符号类型转换的时候，最好使用标准库中提供的专门的方法，而不要直接使用as操作符.

## 2.1. 无歧义完全限定语法

为结构体实现多个trait时，可能会出现同名的方法，代码清单3-66就展示了这种情况. 此时使用as操作符可以帮助避免歧义.

为结构体实现多个trait时出现同名方法的情况:

```rust
struct S_3_66(i32);
trait A_3_66 {
	fn test(&self, i: i32);
}
trait B_3_66 {
	fn test(&self, i: i32);
}
impl A_3_66 for S_3_66 {
	fn test(&self, i: i32) {
		println!("From A: {:?}", i);
	}
}
impl B_3_66 for S_3_66 {
	fn test(&self, i: i32) {
		println!("From B: {:?}", i + 1);
	}
}
fn main_3_66() {
	let s = S_3_66(1);
	A_3_66::test(&s, 1); // From A: 1
	B_3_66::test(&s, 1); // From B: 2
	<S_3_66 as A_3_66>::test(&s, 1); // From A: 1
	<S_3_66 as B_3_66>::test(&s, 1); // From B: 2
}
```

结构体 S 实现了A和B两个trait，虽然包含了**同名的方法 test**，但是其行为不同. 有两种方式调用可以**避免歧义**.

* 第一种是直接当作 **trait 的静态函数**来调用，`A::test()`或`B::test()`.
* 第二种就是使用 **as 操作符**，`＜S as A＞::test()` 或 `＜S asB＞::test()`.

这两种方式叫作**无歧义完全限定语法**(`Fully QualifiedSyntax for Disambiguation`)，曾经也有另外一个名字: **通用函数调用语法**(`UFCS`). 这两种方式的共同之处就是都需要**将结构体实例变量 s 的引用显式地传入 test 方法**中. 但是**建议使用第二种方式**，因为 `＜S as A＞::test()` 语义比较完整，它表明了调用的是S结构体实现的A中的test方法. 而第一种方式遗漏了S结构体这一信息，可读性相对差一些. 这两种方式都可以看作对trait行为的转换.



## 2.2. 类型和子类型相互转换



# 3. From 和 Into




