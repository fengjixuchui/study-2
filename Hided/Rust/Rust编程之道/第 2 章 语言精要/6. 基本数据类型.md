
# 布尔类型

类型名: bool. 两个值: true 和 false.

```rust
fn code2_24() {
	let x = true;
	let y: bool = false;
	let x = 5;
	if x > 1 { println!("x is bigger than 1") };
	assert_eq!(x as i32, 1);
	assert_eq!(y as i32, 0);
}
```

那两个 bool 的声明语句写法是等价的. 即: 可以显式地指定其类型为 bool.

每个比较操作表达式都产生 bool 类型.

as 操作符可以将 bool 类型转换成数字 0 和 1. 但 Rust 并不支持将数字转换成 bool 类型.

# 基本数字类型

分为三类: 固定大小的类型、动态大小的类型和浮点数.

## 固定大小

包括无符号整数 (Unsigned Integer) 和符号整数 (Signed Integer).

无符号整数包括:

* u8, 范围 `0 ~ 2^(8-1)`, 占用 1 个字节. 通常表示字节序列. 文件 I/O 或网络 I/O 的数据流会使用 u8.
* u16, 范围 `0 ~ 2^(16-1)`, 占用 2 个字节.
* u32, 范围 `0 ~ 2^(32-1)`, 占用 4 个字节.
* u64, 范围 `0 ~ 2^(64-1)`, 占用 8 个字节.
* u128, 范围 `0 ~ 2^(128-1)`, 占用 16 个字节.

符号整数:

* i8, 范围为 `-27 ~ 27-1`, 占用 1 个字节.
* i16, 范围为 `-215 ~ 215-1`, 占用 2 个字节.
* i32, 范围为 `-231 ~ 231-1`, 占用 4 个字节.
* i64, 范围为 `-263 ~ 263-1`, 占用 8 个字节.
* i128, 范围为 `-2127 ~ 2127-1`, 占用 16 个字节.

## 动态大小

* usize, 范围为 `0 ~ 232-1` 或 `0 ~ 264-1`, 占用4个或8个字节, 具体取决于机器的字长.
* isize, 数值范围为 `-231 ~ 231-1` 或 `-263 ~ 263-1`, 占用4个或8个字节, 同样取决于机器的字长.

## 浮点数类型

* f32, 单精度32位浮点数, 至少6位有效数字, 范围为 `-3.4×1038 ~ 3.4×1038`.
* f64, 单精度64位浮点数, 至少15位有效数字, 数值范围为 `-1.8×10308 ~ 1.8×10308`. 

```rust
fn code2_25() {
	let num = 42u32;    	// u32, 42
	let num: u32 = 42;	    // u32, 42
	let num = 42;	    	// i32, decimalism 42
	let num = 0x2A;	    	// i32, hex 0x2A
	let num = 0o106;    	// i32, octonary
	let num = 0b1101_1011; 	// i32, binary
	assert_eq!(b'*', 42u8);	    // 字节字面量
	assert_eq!(b'\'', 39u8);
	let num = 3.1415926f64;	// f64
	assert_eq!(-3.14, -3.14f64);
	assert_eq!(2., 2.0f64);
	assert_eq!(2e4, 20000f64);
	println!("{:?}", std::f32::INFINITY);
	println!("{:?}", std::f32::NEG_INFINITY);
	println!("{:?}", std::f32::NAN);
	println!("{:?}", std::f32::MIN);
	println!("{:?}", std::f32::MAX);
}
```

```
inf
-inf
NaN
-340282350000000000000000000000000000000.0
340282350000000000000000000000000000000.0
```

创建的数字字面量后面可以直接使用**类型后缀**, 比如 42u32.

不加后缀或者没有指定类型, Rust 编译器会推断.

前缀 `0x`, `0o`, `0b` 分别代表十六进制, 八进制和二进制类型.

可以写字节字面量, 比如以b开头的字符 `b'*'`, 等价于 42u8.

标准库 `std::f32` 和 `std::f64` 提供了 IEEE 所需要的特殊常量值. 比如 INFINITY(无穷大), NEG_INFINITY(负无穷大), NAN(非数字值), MIN(最小有限值)和 MAX(最大有限值).

# 字符类型

使用**单引号**定义字符(Char)类型. 字符类型代表的是一个 **Unicode 标量值**, 每个字符占 4 个字节.

```rust
fn code2_26() {
	let x = 'r';
	let x = 'Ú';
	println!("{}", '\'');
	println!("{}", '\\');
	println!("{}", '\n');
	println!("{}", '\r');
	println!("{}", '\t');
	assert_eq!('\x2A', '*');
	assert_eq!('\x25', '%');
	assert_eq!('\u{CA0}', 'ಠ');
	assert_eq!('\u{151}', 'ő');
	assert_eq!('%' as i8, 37);
	assert_eq!('ಠ' as i8, -96);
	println!("{}", '\u{151}');
}
```

```
'
\




ő
```

前 2 行是用 **Unicode 值**来定义字符;

第 3 ~ 7 行是转义符;

字符也可以使用 **ASCII 码**和 **Unicode 码**来定义.

* `'2A'` 为 ASCII 码表中表示符号 `'*'` 的十六进制数, 格式为 `'\xHH'`;
* `'151'` 是 Unicode 码表中的十六进制数, 格式为 `'\u{HHH}`.

同样可以使用 as 操作符将字符转为数字类型.

* `'%'` 的十进制 ASCII 值为 37;
* `'ಠ'` 转换为 i8, 高位被截断, 最终得到 -96.

# 数组类型

数组(Array) 的特点:

* 大小固定
* 元素类型相同
* 默认不可变

类型签名为 `[T; N]`.

* T 是一个泛型标记, 代表元素的某个具体类型
* N 代表数组长度, 是一个编译时常量, 必须在编译时确定值.

```rust
fn code2_27() {
	let arr: [i32; 3] = [1, 2, 3];
	let mut mut_arr = [1, 2, 3];
	assert_eq!(1, mut_arr[0]);
	mut_arr[0] = 3;
	assert_eq!(3, mut_arr[0]);
	let init_arr = [0; 10];   // [i32; 10]
	assert_eq!(0, init_arr[5]);
	assert_eq!(10, init_arr.len());
	//println!("{:?}", arr[5]);	// Error: index out of bounds
}
```

let mut 定义可变绑定 mut_arr, 也只能修改索引位上的元素.

`[0; 10]` 创建了初始值为 0 且指定长度为 10 的数组.

