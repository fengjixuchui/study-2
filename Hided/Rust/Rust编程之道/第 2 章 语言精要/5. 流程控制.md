
一般语言都有常用的流程控制语句: 条件语句和循环语句. Rust 中不叫流程控制语句, 而叫流程控制表达式.

# 条件表达式

表达式一定会有值, 所以 **if 表达式的分支必须返回同一个类型的值**. 所以 Rust 没有三元操作符 `? : `. if 表达式的求值规则和快表达式一致.

```rust
fn code2_16() {
	let n = 13;
	let big_n = if (n < 10 && n > -10) {
		10 * n
	} else {
		n/2
	};
	assert_eq!(big_n, 6);
}
```

变量绑定 big_n 的赋值是由一个 if 表达式来完成的. 在 if 分支和 else 分支的求值结果类型都是 i32.

# 循环表达式

Rust 中三种循环表达式: while, loop 和 for...in 表达式.

```rust
fn code2_17() {
	for n in 1..101 {
		if n % 15 == 0 {
			println!("fizzbuzz");
		} else if n % 3 == 0 {
			println!("fizz");
		} else {
			println!("{}", n);
		}
	}
}
```

无限循环, 务必使用 loop 循环, 避免使用 while true 循环.

```rust
fn while_true(x: i32) -> i32 {
	while true {
		return x + 1;
	}
}

fn code2_18() {
	let y = while_true(5);
	assert_eq!(y, 6);
}
```

上面代码会引起 Rust 编译器报错.

```
warning: denote infinite loops with `loop { ... }`
   --> src/main.rs:163:2
    |
163 |     while true {
    |     ^^^^^^^^^^ help: use `loop`
    |
    = note: `#[warn(while_true)]` on by default

error[E0308]: mismatched types
   --> src/main.rs:163:2
    |
162 |   fn while_true(x: i32) -> i32 {
    |                            --- expected `i32` because of return type
163 | /     while true {
164 | |         return x + 1;
165 | |     }
    | |_____^ expected `i32`, found `()`
```

错误提示称 **while true 循环块**返回的是**单元值**, 而**函数 while_true 期望**的返回值是 **i32**, 所以不匹配. 但是在 while true 循环中使用了 return 关键字, 应该返回 i32 类型猜对, 为何会报错呢?

因为 Rust 编译器在对 while 循环做**流分析**(Flow Sensitive)的时候, 不会检查循环条件, 编译器会认为 while 循环条件可真可假, 所以循环体里的表达式也会被忽略, 此时编译器只知道 while true 循环返回的是单元值, 而函数返回的是 i32. 因为 CTFE 功能的限制了, **while 条件表达式无法作为编译器常量**来使用. 只能等将来 CTFE 功能完善了. 同理, if true 在只有一条分支的情况下, 也会发生类似情况.

修改:

```rust
fn while_true(x: i32) -> i32 {
	while true {
		return x + 1;
	}
	x
}
```

这是为了让编译器以为返回的类型是 i32 类型. 但实际上, 将永远在 while true 循环中.

# match 表达式与模式匹配



# if let和while let表达式

