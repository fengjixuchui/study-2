
Rust 中的语法可以分为两大类: 

* 语句(Statement): 要执行的操作和产生副作用的表达式
* 表达式(Expression): 用于计算求值

语句又分为两种:

* 声明语句(Declaration statement): 用于声明各种语言项(Item)

* 表达式语句(Expression statement): 特指以分号结尾的表达式. 此类表达式求值结果会被舍弃, 并总是返回单元类型().

```rust
1. // extern crate std;
2. // use std::prelude::v1::*;
3. fn main() {
4. 	pub fn answer() -> () {
5. 		let a = 40;
6. 		let b = 2;
7. 		assert_eq!(sum(a, b), 42);
8. 	}
9. 	pub fn sum(a: i32, b: i32) -> i32 {
10.	 	a + b
11.	}
12.	answer();
13. }
```

第 1 行和第 2 行是声明语句, 引入标准库以及 prelude 模块. 注释掉是因为 Rust 为每个 crate 都自动引入标准库模块, 除非 `#[no_std]` 属性明确指定不需要标准库.

函数 answer 没有输入参数, 且返回值为**单元类型()**. 单元类型拥有唯一的值就是它本身, 称为单元值. 单元类型表示 "没什么特殊的价值". 所以将单元类型作为函数返回值, 表示该函数没有返回值.

函数answer中, let声明了两个变量, 其后必须加分号; `assert_eq!` 这种以叹号结尾并且像函数一样被调用的语句, 被叫做**宏**.

可以将代码去掉换行符, 完全写成一整行, 不影响编译.

Rust 编译器解析代码: 遇到分号, 继续后面执行; 遇到语句, 执行语句; 遇到表达式, 对表达式求值, 如果分号后面什么都没有, Rust 编译器会补上单元值().

遇到函数, 将函数体的花括号识别为块表达式(Block Expression). 块表达式由一堆花括号和一系列表达式组成, 它总是返回块中**最后一个表达式的值**. answer函数最后一个表达式是宏语句, 返回`单元值()`. sum函数最后一行是一个表达式, 因为没有分号, 直接返回求值结果.

所以, 可以将 Rust 看做**一切皆表达式**. 分号后面什么都没有自动部`单元值()`, 所以可将语句看做计算结果为 () 的特殊表达式. 而普通的表达式, 则得到正常的求值结果.




