
main 函数代表程序的入口.

# 函数定义

函数是通过关键字 fn 定义的.

```rust
pub fn fizz_buzz(num: i32) -> String {
	if num % 15 == 0 {
		return "fizzbuzz". to_string();
	} else if num % 3 == 0 {
		return "fizz". to_string();
	} else if num % 5 == 0 {
		return "buzz". to_string();
	}
	return num.to_string();
}

fn main() {
	//test();
	assert_eq! (fizz_buzz(15), "fizzbuzz". to_string());
	assert_eq! (fizz_buzz(3), "fizz". to_string());
	assert_eq! (fizz_buzz(5), "buzz". to_string());
	assert_eq! (fizz_buzz(13), "13". to_string());
}
```

函数签名 `pub fn fizz_buzz(num: i32) -> String` 反映了**函数的类型约定**: 传入 i32 类型, 返回 String 类型. Rust 会严格遵守.

函数体由花括号括起来, 它是一个块表达式, 最终只返回块中最后一个表达式的求值结果. 提前返回, 使用 return 关键字.

return 表达式会退出一个函数, 并返回一个值. return 后面没有值, 默认返回单元值.

# 作用域与生命周期

Rust 的作用域是静态作用域, 即词法作用域(Lexical Scope). 由一对花括号开辟作用域, 其作用域在词法分析阶段就确定了, 不会动态改变.

```rust
fn main() {
	let v = "hello world! ";
	assert_eq! (v, "hello world! ");
	let v = "hello Rust! ";
	assert_eq! (v, "hello Rust! ");
	{
		let v = "hello World! ";
		assert_eq! (v, "hello World! ");
	}
	assert_eq! (v, "hello Rust! ");
}
```

连续用 let 定义同名变量的做法叫变量遮蔽(Variable Shadow). 但是最终的变量v的值是由最后一个变量定义所决定的.

中间用花括号开辟了一个块空间, 实际上就是一段词法作用域. 同样适用 let 声明了变量绑定.

最后一行验证 v 的值, 该值 仍然等于 `hello Rust! `, 并没有因为块代码中的重新声明发生改变.

这证明, 在词法作用域内部使用花括号开辟新的词法作用域后, 两个作用域是相互独立的. 在不同的词法作用域内声明的变量绑定, 拥有不同的生命周期(LifeTime). 尽管如此, 变量绑定的生命周期总是遵循这样的规律: 从使用 let 声明创建变量绑定开始, 到超出词法作用域的范围时结束.

# 函数指针



