
泛型，顾名思义，就是泛指的类型. 

有一些函数，可能将其用在很多类型中。如果为每个类型都实现一遍，那么工作量会成倍增加。泛型就是为了方便代码的复用.

trait, 借鉴了 Haskell 的 Typeclass. trait是Rust实现零成本抽象的基石，它有如下机制:

* trait是Rust唯一的接口抽象方式
* 可以静态生成，也可以动态调用
* 可以当作标记类型拥有某些特定行为的“标签”来使用

简单来说，trait是对类型行为的抽象

# 泛型

Rust 标准库中定义了很多泛型类型. 其中 `Option＜T＞` 就是一种典型的使用了泛型的类型.

在泛型的类型签名中，通常使用字母T来代表一个泛型。

```rust
// std::option::Option
enum Option<T> {
    Some(T),
    None,
}
```

这个 `Option＜T＞` 枚举类型对于任何类型都适用。这样的话，我们就没必要给每个类型都定义一遍Option枚举，比如 `Option＜u32＞` 或 `Option＜String＞` 等.

标准库提供的 `Option＜T＞` 类型已经通过 `use std::prelude::v1::*` 自动引入了每个 Rust 包中，所以可以直接使用 `Some(T)` 或 `None` 来表示一个 `Option＜T＞` 类型，而不需要写 `Option::Some(T)` 或 `Option::None`。

```rust
use std::fmt::Debug;
fn match_option<T: Debug>(o: Option<T>) {
	match o {
	    Some(i) => println!("{:?}", i),
	    None => println!("nothing"),
	}
}

fn code2_52() {
	let a: Option<i32> = Some(3);
	let b: Option<&str> = Some("hello");
	let c: Option<&str> = Some("A");
	let d: Option<&str> = None;
	match_option(a);  // 3
	match_option(b); // "hello"
	match_option(c); // "A"
	match_option(d); // nothing
}
```

`＜T：Debug＞` 是增加了 trait 限定的泛型. 即, 只有实现了 Debug trait 的类型才适用. 只有实现了Debug trait的类型才拥有使用`＂{:?}＂`格式化打印的行为.

如果去掉 Debug 限定, 编译器会报错`＇T＇ cannot beformatted using ＇：？＇`, 这也充分体现了Rust的类型安全保证.

上面代码中, Rust编译器会在编译期间自动为这4种类型生成`Option＜i32＞`、`Option＜&str＞`、`Option＜char＞`和`Option＜u32＞`这4种具体的代码实现. 

# trait

trait和类型的行为有关

```rust
struct Duck;
struct Pig;
trait Fly {
	fn fly(&self) -> bool;
}
impl Fly for Duck {
	fn fly(&self) -> bool {
		return true;
	}
}
impl Fly for Pig {
	fn fly(&self) -> bool {
		return false;
	}
}
fn fly_static<T: Fly>(s: T) -> bool {
	s.fly()
}
fn fly_dyn(s: &Fly) -> bool {
	s.fly()
}
fn code2_53() {
	let pig = Pig;
	assert_eq!(fly_static::<Pig>(pig), false);
	let duck = Duck;
	assert_eq!(fly_static::<Duck>(duck), true);
	assert_eq!(fly_dyn(&Pig), false);
	assert_eq!(fly_dyn(&Duck), true);
}
```

第 1 行和第 2 行, 定义了两个结构体 Duck 和 Pig.

使用 trait 关键字定义了一个 Fly trait. **在 Rust 中, trait 是唯一的接口抽象方式**. 使用 trait 可以让不同的类型实现同一种行为，也可以为类型添加新的行为。在 Fly trait 中只包含了一个函数签名 fly，包含了参数及参数类型、返回值类型，但没有函数体。函数签名已经基本反映了该函数的所有意图，在返回值类型中甚至还可以包含错误处理相关的信息。这就是类型系统带来的好处之一：提升了可读性。当然，在trait中也可以定义函数的默认实现。

`impl Trait for Type` 就是一种接口抽象。Duck和Pig根据自身的类型针对同一个接口进行Fly，实现了不同的行为。Rust中并没有传统面向对象语言中的继承的概念。Rust通过trait将类型和行为明确地进行了区分，充分贯彻了**组合优于继承**和**面向接口编程**的编程思想。

`fly_static` **泛型函数**，其中**泛型参数**(`s: T`)声明为 `T`，代表任意类型。`T: Fly`这种语法形式使用 Fly trait 对**泛型 T** 进行**行为上的限制**，代表实现了Fly trait的类型，或者拥有fly这种行为的类型。这种限制在Rust中称为**trait限定**(`traitbound`)。通过trait限定，限制了 `fly_static` 泛型函数**参数的类型范围**。如果有不满足该限定的类型传入，编译器就会识别并报错。



