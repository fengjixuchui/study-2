
泛型，顾名思义，就是泛指的类型. 

有一些函数，可能将其用在很多类型中。如果为每个类型都实现一遍，那么工作量会成倍增加。泛型就是为了方便代码的复用.

trait, 借鉴了 Haskell 的 Typeclass. trait是Rust实现零成本抽象的基石，它有如下机制:

* trait是Rust唯一的接口抽象方式
* 可以静态生成，也可以动态调用
* 可以当作标记类型拥有某些特定行为的“标签”来使用

简单来说，trait是对类型行为的抽象

# 泛型

Rust 标准库中定义了很多泛型类型. 其中 `Option＜T＞` 就是一种典型的使用了泛型的类型.

在泛型的类型签名中，通常使用字母T来代表一个泛型。

```rust
// std::option::Option
enum Option<T> {
    Some(T),
    None,
}
```

这个 `Option＜T＞` 枚举类型对于任何类型都适用。这样的话，我们就没必要给每个类型都定义一遍Option枚举，比如 `Option＜u32＞` 或 `Option＜String＞` 等.

标准库提供的 `Option＜T＞` 类型已经通过 `use std::prelude::v1::*` 自动引入了每个 Rust 包中，所以可以直接使用 `Some(T)` 或 `None` 来表示一个 `Option＜T＞` 类型，而不需要写 `Option::Some(T)` 或 `Option::None`。

```rust
use std::fmt::Debug;
fn match_option<T: Debug>(o: Option<T>) {
	match o {
	    Some(i) => println!("{:?}", i),
	    None => println!("nothing"),
	}
}

fn code2_52() {
	let a: Option<i32> = Some(3);
	let b: Option<&str> = Some("hello");
	let c: Option<&str> = Some("A");
	let d: Option<&str> = None;
	match_option(a);  // 3
	match_option(b); // "hello"
	match_option(c); // "A"
	match_option(d); // nothing
}
```

