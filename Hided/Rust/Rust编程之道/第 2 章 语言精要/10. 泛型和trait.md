
泛型，顾名思义，就是泛指的类型. 

有一些函数，可能将其用在很多类型中。如果为每个类型都实现一遍，那么工作量会成倍增加。泛型就是为了方便代码的复用.

trait, 借鉴了 Haskell 的 Typeclass. trait是Rust实现零成本抽象的基石，它有如下机制:

* trait是Rust唯一的接口抽象方式
* 可以静态生成，也可以动态调用
* 可以当作标记类型拥有某些特定行为的“标签”来使用

简单来说，trait是对类型行为的抽象

# 泛型

Rust 标准库中定义了很多泛型类型. 其中 `Option＜T＞` 就是一种典型的使用了泛型的类型.

在泛型的类型签名中，通常使用字母T来代表一个泛型。

```rust
// std::option::Option
enum Option<T> {
    Some(T),
    None,
}
```

这个 `Option＜T＞` 枚举类型对于任何类型都适用。这样的话，我们就没必要给每个类型都定义一遍Option枚举，比如Option＜u32＞或 Option＜String＞等。标准库提供的Option＜T＞类型已经通过 use std：：prelude：：v1：：*自动引入了每个Rust包中，所以可以直接使用Some（T）或None来表示一个Option＜T＞类型，而不需要写Option：：Some（T）或Option：：None。
