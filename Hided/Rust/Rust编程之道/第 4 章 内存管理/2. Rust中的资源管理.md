
采用虚拟内存空间在栈和堆上分配内存, 这是诸多编程语言通用的内存管理基石, Rust 当然也不例外.

Rust **不需要**开发者**显式**地通过 `malloc/new` 或 `free/delete` 之类的函数去分配和回收堆内存.

Rust 可以**静态**地在**编译时**确定**何时需要释放内存**,而**不需要**在**运行时去确定**. Rust 有一套完整的内存管理机制来保证资源的合理利用和良好的性能.

# 变量和函数

前面提到, **变量**有两种:

* **全局变量**. 分为**常量变量**和**静态变量**.
* **局部变量**. 是指在**函数中定义的变量**.

**常量**使用 **const** 关键字定义，并且需要**显式指明类型**，只能进行**简单赋值**，只能使用支持 **CTFE** 的**表达式**。**常量没有固定的内存地址**，因为其**生命周期是全局的**，随着程序消亡而消亡，并且会被**编译器**有效地**内联**到每个使用到它的地方。

**静态变量**使用 **static** 关键字定义，跟常量一样需要**显式指明类型**，进行简单赋值，而**不能使用任何表达式**。静态变量的生命周期也是全局的，但它**并不会被内联**，每个静态变量都有一个**固定的内存地址**。

静态变量**并非被分配到栈**中，也**不是在堆**中，而是和程序代码一起被存储于**静态存储区**中。静态存储区是伴随着程序的**二进制文件的生成（编译时）被分配**的，并且在程序的**整个运行期都会存在**。Rust 中的**字符串字面量**同样是存储于**静态内存**中的。

## 检测是否声明未初始化变量

在**函数**中定义的**局部变量**都会被默认存储到**栈**中。这和 `C/C++` 语言，甚至更多的语言行为都一样，但**不同的是**，Rust 编译器可以**检查未初始化的变量**，以保证内存安全，如代码所示。

```rust
fn main_4_4() {
	let x: i32;
	println!("{}", x);
}
```

编译会报如下错误:

```
error[E0381]: borrow of possibly-uninitialized variable: `x`
  --> src/main.rs:29:17
   |
29 |     println!("{}", x);
   |                    ^ use of possibly-uninitialized `x`
```

Rust编译器会对代码做基本的**静态分支流程分析**。

x **没有绑定任何值**，可能会存在内存不安全，比如**计算结果非预期**、**程序崩溃**等，所以 Rust 编译器必须报错。

## 检测分支流程是否产生未初始化变量

Rust编译器的**静态分支流程分析比较严格**。下面代码展示了if语句中初始化变量的情况。

```rust
fn main_4_5() {
	let x: i32;
	if true {
		x = 1;
	} else {
		x = 2;
	}
	println!("{}", x);
}
```

if **分支的所有情况**都给**变量 x 绑定了值**，所以它可以正确运行。但是如果**去掉 else 分支**，编译器就会报以下错误：

```
error[E0381]: borrow of possibly-uninitialized variable: `x`
  --> src/main.rs:39:17
   |
39 |     println!("{}", x);
   |                    ^ use of possibly-uninitialized `x`
```

这说明编译器已经检查出变量 x 并**未正确初始化**。这可能有点反直觉，去掉了else分支之后，编译器的静态分支流程分析判断出在if表达式之外的 `println!` 也用到了变量x，但并未有任何值绑定行为。第2章提到过，编译器的**静态分支流程分析**并不能识别 if 表达式中的条件是 true，所以它要检查所有的分支情况。

如果把 else 分支和 `println!` 语句都去掉，则可以正常编译运行。因为在 **if 表达式之外**再**没有使用到 x** 的地方，在唯一使用到 x 的 if 表达式中已经绑定了值，所以编译正常。

## 检测循环中是否产生未初始化变量

当在循环中使用 break 关键字的时候，break会将分支中的变量值返回。

> 

在loop循环中使用break关键字:

```rust
fn main_4_6() {
	let x: i32;
	loop {
		if true {
			x = 2;
			break;
		}
	}
	println!("{}", x); // 2
}
```

从Rust编译器的静态分支流程分析可以知道，break会将x的值返回，所以在loop循环之外的println！语句可以正常打印x的值。

## 空数组或向量可以初始化变量

当变量绑定**空的数组**或**向量**时，需要**显式指定类型**，否则编译器无法推断其类型。

绑定空数组或向量:

```rust
fn main_4_7() {
	let a: Vec<i32> = vec![];
	let b: [i32; 0] = [];
}
```

如果不加显式类型标注，编译器会报如下错误：

`let a = vec![];`

```
error[E0282]: type annotations needed for `Vec<T>`
```

`let b  = [];`

```
error[E0282]: type annotations needed for `[_; 0]`
```

空数组或向量可以用来初始化变量，但目前暂时无法用于初始化常量或静态变量。

## 转移所有权产生了未初始化变量

如下面代码, 当将一个**已初始化的变量** y 绑定给**另外一个变量** y2 时，Rust会把变量 **y** 看作逻辑上的**未初始化变量**。

将已初始化变量绑定给另外一个变量:

```

```

变量 x 为**原生整数类型**，默认存储在**栈**上。变量 y 属于指针类型，通过 `Box：：new` 方法在**堆上分配的内存返回指针**，并与y绑定，而**指针 y** 被存储于**栈**上，可以通过 `println！` 语句打印指针地址验证这一点，代码中的 main 函数的变量内存布局如图所示。

main函数中变量内存布局示意图:

![2022-01-05-08-55-58.png](./images/2022-01-05-08-55-58.png)

第5行代码让变量 x2 绑定了变量 x，因为x是原生整数类型，**实现**了 `Copy trait`，所以这里变量x并未发生任何变化。

但第6行代码中，变量 y2绑定了变量y，因为y是 `Box＜T＞` 指针，并**未实现**`Copy trait`，所以此时 y 的值会**移动**给 y2，而变量 y 会被编译器看作一个未初始化的变量，所以当第7行代码再次使用变量y时，编译器就会报错。但是此时如果给y再重新绑定一个新值，y依然可用，这个过程称为**重新初始化**。

当 main 函数调用完毕时，**栈帧**会**被释放**，变量 x 和 y 也会被清空。变量 x 为原生类型，本就存储在栈上，所以被释放是没关系的。但是**变量 y 是指针**，如果就这样被清空，那么其指向的**已分配堆内存**怎么办？代码中并没有使用 free 之类的函数去清空堆内存，这会引起内存泄漏的问题吗？答案是不会，因为 `Box＜T＞` 类型的**指针**会在**变量 y 被清空**之时，**自动清空其指向的已分配堆内存**。

像 `Box＜T＞` 这样的**指针**被称为**智能指针**。使用**智能指针**，可以让 Rust 利用**栈**来**隐式自动释放堆内存**，从而**避免显式调用 free 之类的函数去释放内存**.

# 智能指针与RAII

Rust中的指针大致可以分为三种：**引用**、**原生指针**（裸指针）和**智能指针**。

**引用**就是 Rust 提供的**普通指针**，用 `&` 和 `&mut` 操作符来创建，形如 `&T` 和 `&mut T`。**原生指针**是指形如 `*const T` 和 `*mut T` 这样的类型。

引用和原生指针类型之间的异同如下:

* 可以通过as操作符随意转换，例如 `&T as*const T` 和 `&mut Tas*mut T`。
* 原生指针可以在 unsafe 块下任意使用，不受 Rust 的安全检查规则的限制，而引用则必须受到编译器安全检查规则的限制。

## 智能指针

智能指针（smart pointer）实际上是一种结构体，只不过它的行为类似指针。智能指针是对指针的一层封装，提供了一些额外的功能，比如自动释放堆内存。智能指针区别于常规结构体的特性在于，它实现了 **Deref** 和 **Drop** 这两个trait。Deref提供了解引用能力，Drop提供了自动析构的能力，正是这两个trait让智能指针拥有了类似指针的行为。类型决定行为，同时类型也取决于行为，不是指针胜似指针，所以称其为智能指针。开发者也可以编写自己的智能指针。

第3章已经着重介绍过Deref，用它可以重载解引用运算符*。智能指针结构体中实现了Deref，重载了解引用运算符的行为。其实String和Vec类型也是一种智能指针（如代码清单4-9所示），它们也都实现了Deref和Drop。

代码：String 和 Vec 类型也是一种智能指针

```rust

```

String 类型和 Vec 类型的值都是被分配到堆内存并返回指针的，通过将返回的指针封装来实现Deref和Drop，以自动化管理解引用和释放堆内存。代码清单4-9中第3行代码对变量s进行了解引用操作，其返回的是str类型，因为str是大小不确定的类型，所以编译器会报错，这里将其注释掉了，String 类型和 Vec 类型虽然是智能指针的一种，但并不是让开发者把它们当作指针来使用的。这里只是为了演示说明，真实代码中并不会这样用。同理，第5行代码对变量v解引用，返回的是[u32]类型，依然是大小不确定的类型，所以这里也将其注释掉了。

当main函数执行完毕，栈帧释放，变量s和v被清空之后，其对应的已分配堆内存会被自动释放。这是因为它们实现了Drop。

Drop对于智能指针来说非常重要，因为它可以帮助智能指针在被丢弃时自动执行一些重要的清理工作，比如释放堆内存。更重要的是，除了释放内存，Drop还可以做很多其他的工作，比如释放文件和网络连接。Drop的功能有点类似GC，但它比GC的应用更加广泛，GC只能回收内存，而Drop可以回收内存及内存之外的一切资源。

## 确定性析构

其实这种资源管理的方式有一个术语，叫RAII（ResourceAcquisition Is Initialization），意思是资源获取及初始化。RAII和智能指针均起源于现代 C++，智能指针就是基于RAII机制来实现的。

在现代 C++ 中，RAII的机制是使用构造函数来初始化资源，使用析构函数来回收资源。看上去RAII所要做的事确实跟GC差不多。但RAII和GC最大的不同在于，RAII将资源托管给创建堆内存的指针对象本身来管理，并保证资源在其生命周期内始终有效，一旦生命周期终止，资源马上会被回收。而GC是由第三方只针对内存来统一回收垃圾的，这样就很被动。正是因为RAII的这些优势，Rust也将其纳入了自己的体系中。

Rust中并没有现代C++所拥有的那种构造函数（constructor），而是直接对每个成员的初始化来完成构造，也可以直接通过封装一个静态函数来构造“构造函数”。而Rust中的Drop就是析构函数（Destructor）。

Drop被定义于std：：ops模块中，其内部实现如代码清单4-10所示。

Drop的内部实现:

```rust

```

Drop已经被标记为语言项，这表明该trait为语言本身所用，比如智能指针被丢弃后自动触发析构函数时，编译器知道该去哪里找Drop。

为结构体实现Drop:

```rust

```

代码中定义了元组结构体S，通过impl为结构体S实现了Drop定义的drop方法，令其在被调用的时候执行指定的打印输出。main函数中声明了两个结构体实例x和y，y被置于内部scope中。

代码的输出结果如下:

```

```

在代码清单4-11中，变量x的作用域范围是整个main函数，而变量y的作用域范围是内部scope所界定的范围。通过输出结果来看，在变量x和y分别离开其作用域时，都执行了drop方法。所以RAII也有另外一个别名，叫作用域界定的资源管理（Scope-Bound ResourceManagement，SBRM）。

这也正是Drop的特性，它允许在对象即将消亡之时，自行调用指定代码（drop方法）。

Rust中的一些常用类型，比如Vec、String和File等，均实现了Drop，所以不管是开发者使用Vec创建的动态数组被丢弃时，还是使用String类型创建的字符串被丢弃时，都不需要显式地释放堆内存，也不需要使用File进行文件读取，甚至不需要显式地关闭文件，因为Rust会自动完成这些操作。

## 使用Valgrind来检测内存泄漏

代码清单4-13使用了Box＜T＞指针来分配堆内存，并配合一款知名的专门用于内存调试和检测内存泄漏的工具Valgrind来验证其是否有内存泄漏。

使用 `Box＜T＞` 指针分配内存:

```rust

```

将代码保存到box.rs文件中，使用rustc命令将其编译为二进制文件box:

```
rustc box.rs
```

然后再执行如下命令：

```
valgrind ./box
```

输出结果为：

```

```

Valgrind给出了提示：所有堆内存都已释放。证明了Box＜T＞指针随着栈帧销毁而被丢弃时，自动调用了析构函数，释放了堆内存。

## drop-flag

在代码清单4-13中，变量box1和box3的析构函数分别是在离开main函数和create_box函数之后调用的。而变量 box2 是在离开由花括号构造的显式内部作用域时调用的。它们的析构函数调用顺序是在编译期（而非运行时）就确定好的。这是因为Rust编译器使用了名为drop-flag 的“魔法”，在函数调用栈中为离开作用域的变量自动插入布尔标记，标注是否调用析构函数，这样，在运行时就可以根据编译期做的标记来调用析构函数了。

对于结构体或枚举体这种复合类型来说，并不存在隐式的drop-flag。只有在函数调用时，这些复合结构实例被初始化之后，编译器才会加上drop-flag。如果复合结构本身实现了Drop，则会调用它自己的析构函数；否则，会调用其成员的析构函数。

当变量被绑定给另外一个变量，值发生移动时，也会被加上drop-flag，在运行时会调用析构函数。加上drop-flag的变量意味着其生命周期的结束，之后再也不能被访问。这其实就是第5章会讲到的所有权机制。

这意味着，可以使用花括号构造显式作用域来“主动析构”那些需要提前结束生命周期的变量，如代码清单4-14所示。

代码：使用花括号构造显式作用域主动析构局部变量

```rust

```

在代码清单4-14中，变量v被置于花括号构造的显式内部作用域中，当其离开此内部作用域时，就会调用v的析构函数，所以如果在内部作用域外使用push方法，则会报错，因为变量v已经被释放了。

值得注意的是，对于实现Copy的类型，是没有析构函数的。因为实现了Copy的类型会复制，其生命周期不受析构函数的影响，所以也就没必要存在析构函数。

同时，变量遮蔽（shadowing）并不会导致其生命周期提前结束，如代码清单4-15所示。

代码清单4-15：变量遮蔽不等于生命周期提前结束

```rust

```

代码清单4-15的输出结果表明，变量遮蔽并不会主动析构原来的变量，它会一直存在，直到函数退出。