
采用虚拟内存空间在栈和堆上分配内存, 这是诸多编程语言通用的内存管理基石, Rust 当然也不例外.

Rust **不需要**开发者**显式**地通过 `malloc/new` 或 `free/delete` 之类的函数去分配和回收堆内存.

Rust 可以**静态**地在**编译时**确定**何时需要释放内存**,而**不需要**在**运行时去确定**. Rust 有一套完整的内存管理机制来保证资源的合理利用和良好的性能.

# 变量和函数

前面提到, **变量**有两种:

* **全局变量**. 分为**常量变量**和**静态变量**.
* **局部变量**. 是指在**函数中定义的变量**.

**常量**使用 **const** 关键字定义，并且需要**显式指明类型**，只能进行**简单赋值**，只能使用支持 **CTFE** 的**表达式**。**常量没有固定的内存地址**，因为其**生命周期是全局的**，随着程序消亡而消亡，并且会被**编译器**有效地**内联**到每个使用到它的地方。

**静态变量**使用 **static** 关键字定义，跟常量一样需要**显式指明类型**，进行简单赋值，而**不能使用任何表达式**。静态变量的生命周期也是全局的，但它**并不会被内联**，每个静态变量都有一个**固定的内存地址**。

静态变量**并非被分配到栈**中，也**不是在堆**中，而是和程序代码一起被存储于**静态存储区**中。静态存储区是伴随着程序的**二进制文件的生成（编译时）被分配**的，并且在程序的**整个运行期都会存在**。Rust 中的**字符串字面量**同样是存储于**静态内存**中的。

检测是否声明未初始化变量

在**函数**中定义的**局部变量**都会被默认存储到**栈**中。这和 `C/C++` 语言，甚至更多的语言行为都一样，但**不同的是**，Rust 编译器可以**检查未初始化的变量**，以保证内存安全，如代码所示。

```rust
fn main_4_4() {
	let x: i32;
	println!("{}", x);
}
```

编译会报如下错误:

```
error[E0381]: borrow of possibly-uninitialized variable: `x`
  --> src/main.rs:29:17
   |
29 |     println!("{}", x);
   |                    ^ use of possibly-uninitialized `x`
```

Rust编译器会对代码做基本的静态分支流程分析。

代码中的x在整个 main 函数中并没有绑定任何值，这样的代码会引起很多内存不安全的问题，比如计算结果非预期、程序崩溃等，所以Rust编译器必须报错。
