
采用虚拟内存空间在栈和堆上分配内存, 这是诸多编程语言通用的内存管理基石, Rust 当然也不例外.

Rust **不需要**开发者**显式**地通过 `malloc/new` 或 `free/delete` 之类的函数去分配和回收堆内存.

Rust 可以**静态**地在**编译时**确定**何时需要释放内存**,而**不需要**在**运行时去确定**. Rust 有一套完整的内存管理机制来保证资源的合理利用和良好的性能.

# 变量和函数

前面提到, **变量**有两种:

* **全局变量**. 分为**常量变量**和**静态变量**.
* **局部变量**. 是指在**函数中定义的变量**.

**常量**使用 **const** 关键字定义，并且需要**显式指明类型**，只能进行**简单赋值**，只能使用支持 **CTFE** 的**表达式**。**常量没有固定的内存地址**，因为其**生命周期是全局的**，随着程序消亡而消亡，并且会被**编译器**有效地**内联**到每个使用到它的地方。

**静态变量**使用 **static** 关键字定义，跟常量一样需要**显式指明类型**，进行简单赋值，而**不能使用任何表达式**。静态变量的生命周期也是全局的，但它**并不会被内联**，每个静态变量都有一个**固定的内存地址**。

静态变量**并非被分配到栈**中，也**不是在堆**中，而是和程序代码一起被存储于**静态存储区**中。静态存储区是伴随着程序的**二进制文件的生成（编译时）被分配**的，并且在程序的**整个运行期都会存在**。Rust 中的**字符串字面量**同样是存储于**静态内存**中的。

## 检测是否声明未初始化变量

在**函数**中定义的**局部变量**都会被默认存储到**栈**中。这和 `C/C++` 语言，甚至更多的语言行为都一样，但**不同的是**，Rust 编译器可以**检查未初始化的变量**，以保证内存安全，如代码所示。

```rust
fn main_4_4() {
	let x: i32;
	println!("{}", x);
}
```

编译会报如下错误:

```
error[E0381]: borrow of possibly-uninitialized variable: `x`
  --> src/main.rs:29:17
   |
29 |     println!("{}", x);
   |                    ^ use of possibly-uninitialized `x`
```

Rust编译器会对代码做基本的**静态分支流程分析**。

x **没有绑定任何值**，可能会存在内存不安全，比如**计算结果非预期**、**程序崩溃**等，所以 Rust 编译器必须报错。

## 检测分支流程是否产生未初始化变量

Rust编译器的**静态分支流程分析比较严格**。下面代码展示了if语句中初始化变量的情况。

```rust
fn main_4_5() {
	let x: i32;
	if true {
		x = 1;
	} else {
		x = 2;
	}
	println!("{}", x);
}
```

if **分支的所有情况**都给**变量 x 绑定了值**，所以它可以正确运行。但是如果**去掉 else 分支**，编译器就会报以下错误：

```
error[E0381]: borrow of possibly-uninitialized variable: `x`
  --> src/main.rs:39:17
   |
39 |     println!("{}", x);
   |                    ^ use of possibly-uninitialized `x`
```

这说明编译器已经检查出变量 x 并**未正确初始化**。这可能有点反直觉，去掉了else分支之后，编译器的静态分支流程分析判断出在if表达式之外的 `println!` 也用到了变量x，但并未有任何值绑定行为。第2章提到过，编译器的**静态分支流程分析**并不能识别 if 表达式中的条件是 true，所以它要检查所有的分支情况。

如果把 else 分支和 `println!` 语句都去掉，则可以正常编译运行。因为在 **if 表达式之外**再**没有使用到 x** 的地方，在唯一使用到 x 的 if 表达式中已经绑定了值，所以编译正常。

## 检测循环中是否产生未初始化变量

当在循环中使用 break 关键字的时候，break会将分支中的变量值返回。

> 

在loop循环中使用break关键字:

```rust
fn main_4_6() {
	let x: i32;
	loop {
		if true {
			x = 2;
			break;
		}
	}
	println!("{}", x); // 2
}
```

从Rust编译器的静态分支流程分析可以知道，break会将x的值返回，所以在loop循环之外的println！语句可以正常打印x的值。

## 空数组或向量可以初始化变量

当变量绑定**空的数组**或**向量**时，需要**显式指定类型**，否则编译器无法推断其类型。

绑定空数组或向量:

```rust
fn main_4_7() {
	let a: Vec<i32> = vec![];
	let b: [i32; 0] = [];
}
```

如果不加显式类型标注，编译器会报如下错误：

`let a = vec![];`

```
error[E0282]: type annotations needed for `Vec<T>`
```

`let b  = [];`

```
error[E0282]: type annotations needed for `[_; 0]`
```

空数组或向量可以用来初始化变量，但目前暂时无法用于初始化常量或静态变量。

## 转移所有权产生了未初始化变量

当将一个已初始化的变量y绑定给另外一个变量y2时（如代码清单4-8所示），Rust会把变量y看作逻辑上的未初始化变量。

将已初始化变量绑定给另外一个变量:

```

```

变量x为原生整数类型，默认存储在栈上。变量y属于指针类型，通过Box：：new方法在堆上分配的内存返回指针，并与y绑定，而指针y被存储于栈上，可以通过第4行println！语句打印指针地址验证这一点，代码清单4-8中的main函数的变量内存布局如图4-9所示。

main函数中变量内存布局示意图:

![2022-01-05-08-55-58.png](./images/2022-01-05-08-55-58.png)

第5行代码让变量 x2 绑定了变量 x，因为x是原生整数类型，**实现**了 `Copy trait`，所以这里变量x并未发生任何变化。

但第6行代码中，变量 y2绑定了变量y，因为y是Box＜T＞指针，并**未实现**`Copy trait`，所以此时y的值会移动给y2，而变量y会被编译器看作一个未初始化的变量，所以当第7行代码再次使用变量y时，编译器就会报错。但是此时如果给y再重新绑定一个新值，y依然可用，这个过程称为**重新初始化**。

