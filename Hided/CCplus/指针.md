
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 前言: 复杂类型说明](#1-前言-复杂类型说明)
  - [1.1. int p](#11-int-p)
  - [1.2. int *p](#12-int-p)
  - [1.3. int p[3]](#13-int-p3)
  - [1.4. int *p[3]](#14-int-p3)
  - [1.5. int (*p)[3]](#15-int-p3)
  - [1.6. int **p](#16-int-p)
  - [1.7. int p(int)](#17-int-pint)
  - [1.8. int (*p)(int)](#18-int-pint)
  - [1.9. int *(*p(int))[3]](#19-int-pint3)
- [2. 细说指针](#2-细说指针)
  - [2.1. 指针的类型](#21-指针的类型)
  - [2.2. 指针所指向的类型](#22-指针所指向的类型)
  - [2.3. 指针的值 --- 或叫指针所指向的内存区或地址](#23-指针的值-或叫指针所指向的内存区或地址)
  - [2.4. 指针本身所占据的内存区](#24-指针本身所占据的内存区)
- [3. 指针的算术运算](#3-指针的算术运算)
- [4. 运算符&和*](#4-运算符和)
- [5. 指针表达式](#5-指针表达式)
- [6. 数组和指针的关系](#6-数组和指针的关系)
- [7. 指针和结构类型的关系](#7-指针和结构类型的关系)
- [8. 指针和函数的关系](#8-指针和函数的关系)
- [9. 指针类型转换](#9-指针类型转换)
- [10. 指针的安全问题](#10-指针的安全问题)
- [11. 结束语](#11-结束语)
- [12. 参考](#12-参考)

<!-- /code_chunk_output -->

# 1. 前言: 复杂类型说明

要了解指针,多多少少会出现一些比较复杂的类型, 所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单, **一个类型**里会出现**很多运算符**, 他们也像**普通的表达式**一样, 有**优先级**, 其优先级和**运算优先级**一样, 所以我总结了一下其原则:

>从**变量名**处起,根据**运算符优先级结合**,一步一步分析

注: 指针是一个**带有大小范围的地址**

下面让我们先从简单的类型开始慢慢分析吧:

## 1.1. int p

```c
int p;
```

这是一个普通的整型变量

## 1.2. int *p

```c
int *p;
```

**首先从 P 处开始**, 先**与\*结合**, 所以说明 P 是**一个指针**, 然后再**与 int 结合**, 说明**指针所指向的内容**的**类型为 int 型**.

所以 P 是**一个返回整型数据的指针**

## 1.3. int p[3]

```c
int p[3];
```

首先从 P 处开始, **先与[]结合**,说明 **P 是一个数组**, 然后**与 int 结合**, 说明**数组里的元素是整型的**.

所以 P 是一个**由整型数据组成的数组**

## 1.4. int *p[3]

```c
int *p[3];
```

首先从 P 处开始, **先与[]结合**, 因为其**优先级比\*高**, 所以 **P 是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针类型**, 然后**再与 int 结合**, 说明**指针所指向的内容的类型是整型**的.

所以 P 是一个由**返回整型数据的指针**所**组成的数组**

## 1.5. int (*p)[3]

```
int (*p)[3];
```

首先从 P 处开始, **先与\*结合**, 说明 P 是**一个指针**, 然后**再与[]结合**(与"()"这步可以忽略, 只是为了改变优先级), 说明**指针所指向的内容是一个数组**, 然后**再与 int 结合**, 说明**数组里的元素是整型**的.

所以 P 是一个指向由**整型数据组成的数组**的**指针**

## 1.6. int **p

```c
int **p;
```

首先从 P 开始, **先与\*结合**, 说是 P 是**一个指针**, 然后**再与\*结合**, 说明**指针所指向的元素是指针**, 然后**再与 int 结合**, 说明**该指针所指向的元素是整型数据**. 由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针.

## 1.7. int p(int)

```c
int p(int);
```

从 P 处起, **先与()结合**, 说明 P 是**一个函数**,然后进入()里分析, 说明该函数**有一个整型变量的参数**, 然后再与外面的 int 结合, 说明**函数的返回值**是一个**整型数据**

## 1.8. int (*p)(int)

```c
int (*p)(int);
```

从 P 处开始, **先与指针结合**, 说明 P 是**一个指针**, 然后**与()结合**, 说明**指针指向的是一个函数**, 然后再与()里的int 结合, 说明函数有一个 int 型的参数, 再与最外层的int 结合, 说明函数的返回类型是整型, 所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针

## 1.9. int *(*p(int))[3]

```c
int *(*p(int))[3];
```

从 P 开始, **先与()结合**, 说明 **P 是一个函数**, 然后进入()里面, 与 int 结合, 说明**函数有一个整型变量参数**, 然后再与外面的\*结合, 说明函数**返回的是一个指针**, 然后到最外面一层, 先与[]结合, 说明**返回的指针指向的是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针**, 然后再与 int 结合, 说明**指针指向的内容是整型数据**.

所以 P 是一个**参数为一个整数据**且返回一个指向由整型指针变量组成的数组的指针变量的函数.

# 2. 细说指针

指针是一个**特殊的变量**, 它里面**存储的数值**被解释成为**内存里的一个地址**.

要搞清一个指针需要搞清指针的**四方面的内容**:

* **指针的类型**、
* 指针**所指向的类型**、
* 指针的**值**或者叫指针**所指向的内存区**、
* 指针**本身所占据的内存区**.

让我们分别说明.

先声明几个指针放着做例子:

(1) `int *ptr`;

(2) `char *ptr`;

(3) `int **ptr`;

(4) `int (*ptr)[3]`;

(5) `int *(*ptr)[4]`;

## 2.1. 指针的类型

从语法的角度看, 你只要把**指针声明语句**里的**指针名字去掉**, 剩下的部分就是这个**指针的类型**. 这是指针本身所具有的类型. 让我们看看例一中各个指针的类型:

(1) `int *ptr`; //指针的类型是 `int*`

(2) `char *ptr`; //指针的类型是 `char*`

(3) `int **ptr`; //指针的类型是 `int**`

(4) `int (*ptr)[3]`; //指针的类型是 `int(*)[3]`

(5) `int *(*ptr)[4]`; //指针的类型是 `int*(*)[4]`

## 2.2. 指针所指向的类型

当你通过指针来访问**指针所指向的内存区**时, **指针所指向的类型**决定了**编译器**将把**那片内存区里的内容**当做什么来看待.

从语法上看, 你只须把**指针声明语句**中的**指针名字**和**名字左边的指针声明符\*去掉**, 剩下的就是指针所指向的类型. 例如:

(1) `int *ptr`; //指针所指向的类型是 `int`

(2) `char *ptr`; //指针所指向的的类型是 `char`

(3) `int **ptr`; //指针所指向的的类型是 `int*`

(4) `int (*ptr)[3]`; //指针所指向的的类型是`int()[3]`

(5) `int *(*ptr)[4]`; //指针所指向的的类型是 `int*()[4]`

在指针的算术运算中, 指针所指向的类型有很大的作用.  指针的类型(即指针本身的类型)和指针所指向的类型是两个概念. 当你对 C 越来越熟悉时, 你会发现, 把与指针搅和在一起的"类型"这个概念分成 "指针的类型"和"指针所指向的类型"两个概念, 是精通指针的关键点之一.  我看了不少书, 发现有些写得差的书中, 就把指针的这两个概念搅在一起了,  所以看起书来前后矛盾, 越看越糊涂.

## 2.3. 指针的值 --- 或叫指针所指向的内存区或地址

**指针的值**是指针**本身存储的数值**, 这个值将被**编译器当作一个地址**, 而不是一个一般的数值.

在 32 位程序里, **所有类型**的**指针的值**都是一个 **32 位整数**, 因为 **32 位程序**里**内存地址**全都是 **32 位长**.  **指针所指向的内存区**就是从**指针的值**所代表的**那个内存地址开始**, 长度为 **sizeof(指针所指向的类型**)的**一片内存区**.

以后, 我们说**一个指针的值**是 **XX**, 就相当于说**该指针指向了以 XX 为首地址**的**一片内存区域**; 我们说**一个指针**指向了**某块内存区域**,  就相当于说该指针的值是**这块内存区域的首地址**.

指针所指向的内存区和指针所指向的类型是两个完全不同的概念. 在例一中, 指针所指向的类型已经有了, 但由于指针还未初始化, 所以它所指向的内存区是不存在的, 或者说是无意义的.

以后, 每遇到一个指针, 都应该问问:这个指针的类型是什么?指针指的类型是什么?该指针指向了哪里?(重点注意)

## 2.4. 指针本身所占据的内存区

**指针本身**占了**多大的内存**? 你只要用函数 **sizeof(指针的类型**) 测一下 就知道了. 在 **32 位平台**里, 指针本身占据了 **4 个字节的长度**.

指针本身占据的内存这个概念在判断一个**指针表达式**(后面会解释)是否是**左值**时很有用.

# 3. 指针的算术运算


# 4. 运算符&和*

这里`&`是**取地址运算符**, `*`是**间接运算符**.

`&a` 的**运算结果**是**一个指针**, **指针的类型**是 **a 的类型加个**`*`, 指针**所指向的类型**是 **a 的类型**, 指针所指向的地址嘛, 那就是 **a 的地址**.

`*p` 的运算结果就五花八门了. 总之 `*p` 的结果是 **p 所指向的东西**,  这个东西有这些特点:它的类型是 **p 指向的类型**, 它所占用的地址是 p 所指向的地址.

例子:

```c
int a=12;
int b;
int *p;
int **ptr;

p=&a;
*p=24;
ptr=&p;
*ptr=&b;
**ptr=34;
```

`p = &a`;      // `&a` 的结果是一个指针, 类型是 `int*`, 指向的类型是int, 指向的地址是 a 的地址.

`*p = 24`;     // `*p` 的结果, 在这里它的类型是 int, 它所占用的地址是p 所指向的地址, 显然, `*p` 就是变量 a

`ptr = &p`;    // `&p` 的结果是个指针, 该指针的类型是 p 的类型加个\*, 在这里是 `int **`. 该指针所指向的类型是 p 的类型, 这里是 `int*`. 该指针所指向的地址就是指针 p 自己的地址.

`*ptr = &b`;  // `*ptr` 是个指针, `&b` 的结果也是个指针, 且这两个指针的类型和所指向的类型是一样的, 所以用 `&b` 来给`*ptr` 赋值就是毫无问题的了.

`**ptr = 34`; // `*ptr` 的结果是 ptr 所指向的东西, 在这里是一个指针, 对这个指针再做一次`*`运算, 结果是一个 int 类型的变量.

# 5. 指针表达式

一个**表达式的结果**如果是**一个指针**, 那么这个表达式就叫指针表式.

下面是一些指针表达式的例子:

```c
int a,b;

int array[10];

int *pa;

pa=&a;          // &a 是一个指针表达式.

int **ptr=&pa;  // &pa 也是一个指针表达式.

*ptr=&b;        // *ptr 和&b 都是指针表达式.

pa=array;

pa++;           //这也是指针表达式.
```






# 6. 数组和指针的关系

# 7. 指针和结构类型的关系

# 8. 指针和函数的关系

# 9. 指针类型转换

# 10. 指针的安全问题

# 11. 结束语

C 中唯一的难点就是指针, 指针搞定其它小菜而已, 重要的是实践.

C\+\+是一门难学易用的语言, 要真正掌握C\+\+可不是那么容易的, 将基本的学完后, 就学数据结构吧, 算法才是永恒的, 程序设计语言层出不穷, 永远学不完. 学完之后就认真啃下 STL 这根骨头吧, 推荐书籍--------《范型编程与STL》 和 《STL源码剖析》. STL里有大量的精华而高效的算法.


# 12. 参考

网络资源: <让你不再害怕指针>