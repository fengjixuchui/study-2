







参照: https://blog.csdn.net/geshifei/article/details/120590183

机械硬盘时代，由于其**随机访问**性能差，内核开发者主要放在**缓存** I/O、**合并** I/O 等方面，并**没有**考虑**多队列**的设计；而 Flash 的出现，性能出现了戏剧性的反转，因为**单个 CPU 每秒**发出 IO **请求数量**是**有限**的，所以促进了 **IO 多队列**开发。

驱动中的队列创建，通过函数 kcalloc_node 如下，可以看到队列数量是和系统中所拥有的 cpu 数量有关






为了便于理解NVMe的处理流程, 我们给出了传统SCSI及NVMe数据处理的对比流程. 如图所示, 整个流程是从**通用块层的接口**(`submit_bio`)开始的, 这个函数大家都非常清楚了.

![2023-02-09-21-45-27.png](./images/2023-02-09-21-45-27.png)

对于 NVMe 设备来说, 在初始化的时候初始化函数指针 `make_request_fn` 为 `nvme_queue_rq`, 该函数就是 NVMe 驱动程序的**请求处理接口**. 该函数最终会**将请求**写入 NVMe 中的 **SQ 队列**当中, 并通知控制器处理请求.

```cpp
static const struct blk_mq_ops nvme_mq_admin_ops = {
	.queue_rq	= nvme_queue_rq, // 请求处理函数
	.complete	= nvme_pci_complete_rq, // 请求完成时调用的函数
	.init_hctx	= nvme_admin_init_hctx,
	.init_request	= nvme_pci_init_request,
	.timeout	= nvme_timeout,
};

static const struct blk_mq_ops nvme_mq_ops = {
	.queue_rq	= nvme_queue_rq,        // 请求处理函数
	.queue_rqs	= nvme_queue_rqs,       // 请求处理函数
	.complete	= nvme_pci_complete_rq, // 请求完成时调用的函数
	.commit_rqs	= nvme_commit_rqs,
	.init_hctx	= nvme_init_hctx,
	.init_request	= nvme_pci_init_request,
	.map_queues	= nvme_pci_map_queues,
	.timeout	= nvme_timeout,
	.poll		= nvme_poll,
};

// 中断处理函数
static irqreturn_t nvme_irq(int irq, void *data)
{
	struct nvme_queue *nvmeq = data;
	DEFINE_IO_COMP_BATCH(iob);

	if (nvme_poll_cq(nvmeq, &iob)) {
		if (!rq_list_empty(iob.req_list))
			nvme_pci_complete_batch(&iob);
		return IRQ_HANDLED;
	}
	return IRQ_NONE;
}

static irqreturn_t nvme_irq_check(int irq, void *data)
{
	struct nvme_queue *nvmeq = data;

	if (nvme_cqe_pending(nvmeq))
		return IRQ_WAKE_THREAD;
	return IRQ_NONE;
}
```