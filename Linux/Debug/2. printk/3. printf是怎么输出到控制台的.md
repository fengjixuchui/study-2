
在 Linux 下，printf 输出到控制台经历了 `app`->`libc`->`syscall`->`console` 驱动四个阶段。

# app

首先是用户态代码调用 printf 函数。printf 函数首先会检查其格式字符串中的特殊字符，如%d、%s 等，并根据这些特殊字符和传递给 printf 函数的参数来生成要输出的字符串。

```cpp
printf("hello, world!\n");
```

# libc

要能使用 printf 需要先包含: 

```cpp
#include <stdio.h>
```

因为 printf 它是一个 libc 实现的标准库函数，定义如下: 

```cpp
int printf(const char *format, ...);
```

想了解它怎么实现的, 最快速的办法不是看源码, 而是看 `man 3 printf`

![2023-07-04-10-43-03.png](./images/2023-07-04-10-43-03.png)

总结下来就是 2 个关键词，分别是 “格式字符串的格式化”、“打印到标准输出”.

标准输出? 通过 strace 查看

```
# strace printf "hello,world\n"
execve("/usr/bin/printf", ["printf", "hello,world\\n"], 0x7fff41e16358 /* 38 vars */) = 0
......
newfstatat(1, "", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}, AT_EMPTY_PATH) = 0
write(1, "hello,world\n", 12hello,world
)           = 12
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
```

标准输出就是 fd 1.

更详细的就是去看 glibc 源码.

```
$ git clone https://sourceware.org/git/glibc.git
$ vim glibc/stdio-common/printf.c
```

glibc 中源码 printf 的入口:

```cpp
// stdio-common/printf.c
#undef printf

/* Write formatted output to stdout from the format string FORMAT.  */
/* VARARGS1 */
int
__printf (const char *format, ...)
{
  va_list arg;
  int done;

  va_start (arg, format);
  done = __vfprintf_internal (stdout, format, arg, 0);
  va_end (arg);

  return done;
}

#undef _IO_printf
ldbl_strong_alias (__printf, printf);
ldbl_strong_alias (__printf, _IO_printf);
```

根据前面可知, 在 Linux 中，为了将格式化的输出发送到控制台上，printf 函数会调用 write 系统调用。write 系统调用会将生成的要输出的字符串写入到**标准输出流**中。而标准输出流（stdout）是一个**文件描述符**，它**与控制台相关联**。

首先要理解**控制台**的概念，控制台设备的实现方式可能因不同的 Linux 发行版而有所不同。例如，在我的 Ubuntu 虚拟机上，控制台是一个 “`/dev/pts/2`”: 

```
$ sleep 10000 &
[1] 7134
ubuntu@haiwei-pc:~/codes/glibc$ lsof -c sleep
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
sleep   7134 ubuntu  cwd    DIR  259,1     4096 42357042 /home/ubuntu/codes/glibc
sleep   7134 ubuntu  rtd    DIR  259,1     4096        2 /
sleep   7134 ubuntu  txt    REG  259,1    35328 47711307 /usr/bin/sleep
sleep   7134 ubuntu  mem    REG  259,1 14575936 47715643 /usr/lib/locale/locale-archive
sleep   7134 ubuntu  mem    REG  259,1  2216304 47716616 /usr/lib/x86_64-linux-gnu/libc.so.6
sleep   7134 ubuntu  mem    REG  259,1   240936 47716279 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
sleep   7134 ubuntu    0u   CHR  136,2      0t0        5 /dev/pts/2
sleep   7134 ubuntu    1u   CHR  136,2      0t0        5 /dev/pts/2
sleep   7134 ubuntu    2u   CHR  136,2      0t0        5 /dev/pts/2
```

在嵌入式 Linux 设备上，控制台是一个 "/dev/console": 

```
$ ll /dev/console
crw--w---- 1 root tty 5, 1  7 月  4 06:09 /dev/console
```

另外，特别要注意的是标准输出它仅仅是一个描述符，它**不等同**于**一个具体的设备**, 也不会永远与之绑定，在某些应用场景下比如日志单独存储时可以**被重定向**，如下例子: 

```
$ sleep 10000 > test &
[1] 7379
$ lsof -c sleep
sleep   7379 ubuntu  cwd    DIR  259,1     4096 41681148 /home/ubuntu/codes
sleep   7379 ubuntu  rtd    DIR  259,1     4096        2 /
sleep   7379 ubuntu  txt    REG  259,1    35328 47711307 /usr/bin/sleep
sleep   7379 ubuntu  mem    REG  259,1 14575936 47715643 /usr/lib/locale/locale-archive
sleep   7379 ubuntu  mem    REG  259,1  2216304 47716616 /usr/lib/x86_64-linux-gnu/libc.so.6
sleep   7379 ubuntu  mem    REG  259,1   240936 47716279 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
sleep   7379 ubuntu    0u   CHR  136,3      0t0        6 /dev/pts/3
sleep   7379 ubuntu    1w   REG  259,1        0 41714694 /home/ubuntu/codes/test
sleep   7379 ubuntu    2u   CHR  136,3      0t0        6 /dev/pts/3
```

那么**标准输出 fd 描述符**究竟是如何**与控制台相关联**的呢？当 **write 系统调用**被调用时，数据又是怎样**从用户空间下发到控制台**的呢？

那无疑是先要看**标准数据 fd** 即控制台式什么时候被打开的。这时又遇到问题了，你会发现我前面通过 strace 跟踪“sleep ...”运行的过程其实根本**没有去显式打开标准输出 fd** 的，那么怎么回事呢？

我们知道，**子进程 fork** 时默认**继承父进程打开的文件描述符**。又知，在 Linux 的天下，用户进程兼为 **init 进程**的子民。所以，具体要看 rootfs 启动后 init 进程是如何初始化控制台的，手头是 busybox-1.34.1/init/init.c: 



`console_init()` 获取 console 文件相关环境变量，默认为空的情况下赋值为 "`dev/console`"，然后打开并将 `STDIN_FILENO` 和 `STDOUT_FILENO` **重定向到 console**。

讲到这里，我们总结下，printf 打印的内容本质上就是**先打开一个控制台设备**（嵌入式 Linux 下默认为 `/dev/console`），这个描述符固定是标准输出（fd=1），然后往这个 fd 写内容。

# syscall

当使用 open 系统调用打开 “`/dev/console`” 时，发生了什么呢？

当 write 系统调用被调用时，它会将数据从用户空间复制到内核空间。那么进一步又写到哪里去呢？

这就要考 Linux 下设备驱动框架了，请耐心继续往下看：

前面已知道，这个是由标准输出关联的控制台在打开时就已经决定了。Linux 下的文件分为设备文件、常规文件、管道、套接字等，不同的文件有它固有的写入方法。其中设备文件又分块设备文件和字符设备文件，而 `/dev/console` 就是后者：

