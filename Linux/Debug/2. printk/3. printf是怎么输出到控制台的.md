
在 Linux 下，printf 输出到控制台经历了 `app`->`libc`->`syscall`->`console` 驱动四个阶段。

# app

首先是用户态代码调用 printf 函数。printf 函数首先会检查其格式字符串中的特殊字符，如%d、%s 等，并根据这些特殊字符和传递给 printf 函数的参数来生成要输出的字符串。

```cpp
printf("hello, world!\n");
```

# libc

要能使用 printf 需要先包含：

```cpp
#include <stdio.h>
```

因为 printf 它是一个 libc 实现的标准库函数，定义如下：

```cpp
int printf(const char *format, ...);
```

想了解它怎么实现的, 最快速的办法不是看源码, 而是看 `man 3 printf`

![2023-07-04-10-43-03.png](./images/2023-07-04-10-43-03.png)

总结下来就是 2 个关键词，分别是 “格式字符串的格式化”、“打印到标准输出”.

标准输出? 通过 strace 查看

```
# strace printf "hello,world\n"
execve("/usr/bin/printf", ["printf", "hello,world\\n"], 0x7fff41e16358 /* 38 vars */) = 0
......
newfstatat(1, "", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}, AT_EMPTY_PATH) = 0
write(1, "hello,world\n", 12hello,world
)           = 12
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
```

标准输出就是 fd 1.

更详细的就是去看 glibc 源码.

```
$ git clone https://sourceware.org/git/glibc.git
$ vim glibc/stdio-common/printf.c
```

glibc 中源码 printf 的入口:

```cpp
// stdio-common/printf.c
#undef printf

/* Write formatted output to stdout from the format string FORMAT.  */
/* VARARGS1 */
int
__printf (const char *format, ...)
{
  va_list arg;
  int done;

  va_start (arg, format);
  done = __vfprintf_internal (stdout, format, arg, 0);
  va_end (arg);

  return done;
}

#undef _IO_printf
ldbl_strong_alias (__printf, printf);
ldbl_strong_alias (__printf, _IO_printf);
```

根据前面可知, 在 Linux 中，为了将格式化的输出发送到控制台上，printf 函数会调用 write 系统调用。write 系统调用会将生成的要输出的字符串写入到**标准输出流**中。而标准输出流（stdout）是一个**文件描述符**，它**与控制台相关联**。

首先要理解**控制台**的概念，控制台设备的实现方式可能因不同的 Linux 发行版而有所不同。例如，在我的 Ubuntu 虚拟机上，控制台是一个 “`/dev/pts/2`”：

```
$ sleep 10000 &
[1] 7134
ubuntu@haiwei-pc:~/codes/glibc$ lsof -c sleep
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
sleep   7134 ubuntu  cwd    DIR  259,1     4096 42357042 /home/ubuntu/codes/glibc
sleep   7134 ubuntu  rtd    DIR  259,1     4096        2 /
sleep   7134 ubuntu  txt    REG  259,1    35328 47711307 /usr/bin/sleep
sleep   7134 ubuntu  mem    REG  259,1 14575936 47715643 /usr/lib/locale/locale-archive
sleep   7134 ubuntu  mem    REG  259,1  2216304 47716616 /usr/lib/x86_64-linux-gnu/libc.so.6
sleep   7134 ubuntu  mem    REG  259,1   240936 47716279 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
sleep   7134 ubuntu    0u   CHR  136,2      0t0        5 /dev/pts/2
sleep   7134 ubuntu    1u   CHR  136,2      0t0        5 /dev/pts/2
sleep   7134 ubuntu    2u   CHR  136,2      0t0        5 /dev/pts/2
```

在嵌入式 Linux 设备上，控制台是一个 "/dev/console"：

```
$ ll /dev/console
crw--w---- 1 root tty 5, 1  7 月  4 06:09 /dev/console
```

