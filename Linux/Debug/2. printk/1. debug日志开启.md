

# 电源管理的 pm_pr_dbg

调试函数为 `pm_pr_dbg`，开启了需要开启 `CONFIG_PM_SLEEP_DEBUG`.

开启后还是不能用

```cpp
// include/linux/suspend.h
#ifdef CONFIG_PM_SLEEP_DEBUG
extern bool pm_print_times_enabled;
extern bool pm_debug_messages_on;
// 这里
extern __printf(2, 3) void __pm_pr_dbg(bool defer, const char *fmt, ...);
#else
#define pm_print_times_enabled  (false)
#define pm_debug_messages_on    (false)

#include <linux/printk.h>

// 不会这个
#define __pm_pr_dbg(defer, fmt, ...) \
        no_printk(KERN_DEBUG fmt, ##__VA_ARGS__)
#endif


// kernel/power/main.c
#ifdef CONFIG_PM_SLEEP_DEBUG
...
bool pm_debug_messages_on __read_mostly;

static ssize_t pm_debug_messages_show(struct kobject *kobj,
                                      struct kobj_attribute *attr, char *buf)
{
        return sprintf(buf, "%d\n", pm_debug_messages_on);
}

static ssize_t pm_debug_messages_store(struct kobject *kobj,
                                       struct kobj_attribute *attr,
                                       const char *buf, size_t n)
{
        unsigned long val;

        if (kstrtoul(buf, 10, &val))
                return -EINVAL;

        if (val > 1)
                return -EINVAL;

        pm_debug_messages_on = !!val;
        return n;
}
power_attr(pm_debug_messages);

static int __init pm_debug_messages_setup(char *str)
{
        pm_debug_messages_on = true;
        return 1;
}
__setup("pm_debug_messages", pm_debug_messages_setup);

/**
 * __pm_pr_dbg - Print a suspend debug message to the kernel log.
 * @defer: Whether or not to use printk_deferred() to print the message.
 * @fmt: Message format.
 *
 * The message will be emitted if enabled through the pm_debug_messages
 * sysfs attribute.
 */
void __pm_pr_dbg(bool defer, const char *fmt, ...)
{
        struct va_format vaf;
        va_list args;
        // 默认这里会直接返回
        if (!pm_debug_messages_on)
                return;

        va_start(args, fmt);

        vaf.fmt = fmt;
        vaf.va = &args;

        if (defer)
                printk_deferred(KERN_DEBUG "PM: %pV", &vaf);
        else
                printk(KERN_DEBUG "PM: %pV", &vaf);

        va_end(args);
}

#else /* !CONFIG_PM_SLEEP_DEBUG */
static inline void pm_print_times_init(void) {}
#endif /* CONFIG_PM_SLEEP_DEBUG */
```

所以需要 `pm_debug_messages_on` 置 1 才能打印。

```
echo 1 > /sys/power/pm_debug_messages
```

原理如下:

```cpp
// kernel/power/main.c
#ifdef CONFIG_PM_SLEEP_DEBUG
...
bool pm_debug_messages_on __read_mostly;

static ssize_t pm_debug_messages_show(struct kobject *kobj,
                                      struct kobj_attribute *attr, char *buf)
{
        return sprintf(buf, "%d\n", pm_debug_messages_on);
}

static ssize_t pm_debug_messages_store(struct kobject *kobj,
                                       struct kobj_attribute *attr,
                                       const char *buf, size_t n)
{
        unsigned long val;

        if (kstrtoul(buf, 10, &val))
                return -EINVAL;

        if (val > 1)
                return -EINVAL;

        pm_debug_messages_on = !!val;
        return n;
}
power_attr(pm_debug_messages);

#else /* !CONFIG_PM_SLEEP_DEBUG */
static inline void pm_print_times_init(void) {}
#endif /* CONFIG_PM_SLEEP_DEBUG */
```

或者直接在 cmdline 中添加 `pm_debug_messages_on` 就可以开启开关了

```cpp
// kernel/power/main.c
#ifdef CONFIG_PM_SLEEP_DEBUG
...
static int __init pm_debug_messages_setup(char *str)
{
        pm_debug_messages_on = true;
        return 1;
}
__setup("pm_debug_messages", pm_debug_messages_setup);

#else /* !CONFIG_PM_SLEEP_DEBUG */
static inline void pm_print_times_init(void) {}
#endif /* CONFIG_PM_SLEEP_DEBUG */
```

注意可以配合no_console_suspend来获取状态执行时的log，这个参数保证了串口是工作的。