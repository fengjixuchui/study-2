
透明巨型页(Transparent Huge Page, THP) 对进程是透明的, 如果虚拟内存区域足够大, 并且允许使用巨型页, 那么内核在分配内存的时候首先选择分配巨型页, 如果分配巨型页失败, 回退分配普通页. 

# 使用方法

透明巨型页的配置宏如下所示. 

(1) CONFIG_TRANSPARENT_HUGEPAGE: 支持透明巨型页. 

(2) CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS: 总是使用透明巨型页. 

(3) CONFIG_TRANSPARENT_HUGEPAGE_MADVISE: 只在进程使用madvise(MADV_HUGEPAGE)指定的虚拟地址范围内使用透明巨型页. 

(4) CONFIG_TRANSPARENT_HUGE_PAGECACHE: 文件系统的页缓存使用透明巨型页. 

可以在引导内核的时候通过内核参数开启或关闭透明巨型页. 

(1) transparent_hugepage=always

(2) transparent_hugepage=madvise

(3) transparent_hugepage=never

可以在运行过程中开启或关闭透明巨型页. 

(1) 总是使用透明巨型页. 

```
echo always > /sys/kernel/mm/transparent_hugepage/enabled
```

(2) 只在进程使用 madvise(MADV_HUGEPAGE) 指定的虚拟地址范围内使用透明巨型页. 

```
echo madvise > /sys/kernel/mm/transparent_hugepage/enabled
```

(3) 禁止使用透明巨型页. 

```
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

分配透明巨型页失败的时候, 页分配器采取什么消除内存碎片的策略？可以配置以下策略. 

(1) 直接回收页, 执行同步模式的内存碎片整理. 

```

```

(2) 异步回收页, 执行异步模式的内存碎片整理. 

```

```

(3) 只针对madvise(MADV_HUGEPAGE)指定的虚拟内存区域, 异步回收页, 执行异步模式的内存碎片整理. 

```

```

(4) 只针对madvise(MADV_HUGEPAGE)指定的虚拟内存区域, 直接回收页, 执行同步模式的内存碎片整理. 这是默认策略. 

```

```

(5) 不采取任何策略. 

```

```

可以查看透明巨型页的长度, 单位是字节: 

```

```

透明巨型页扫描线程定期扫描允许使用透明巨型页的虚拟内存区域, 尝试把普通页合并成透明巨型页. 


可以通过文件 “`/sys/kernel/mm/transparent_hugepage/khugepaged/pages_to_scan`” 配置每次扫描多少页(指普通页) , 默认值是一个巨型页包含的普通页数量的8倍. 可以通过文件 “`/sys/kernel/mm/transparent_hugepage/khugepaged/scan_sleep_millisecs`” 配置两次扫描的时间间隔, 单位是毫秒, 默认值是10秒. 

系统调用madvise针对透明巨型页提供了两个Linux私有的建议值. 

(1) MADV_HUGEPAGE表示指定的虚拟地址范围允许使用透明巨型页. 

(2) MADV_NOHUGEPAGE表示指定的虚拟地址范围不要合并成巨型页. 

# 实现原理

虚拟内存区域 vm_area_struct 的成员 vm_flags 增加了以下两个标志. 

(1) VM_HUGEPAGE表示允许虚拟内存区域使用透明巨型页, 进程使用madvise(MADV_HUGEPAGE)给虚拟内存区域设置这个标志. 

(2) VM_NOHUGEPAGE表示不允许虚拟内存区域使用透明巨型页, 进程使用madvise(MADV_NOHUGEPAGE)给虚拟内存区域设置这个标志. 

注意: 标志VM_HUGETLB表示允许使用标准巨型页. 

虚拟内存区域满足以下条件才允许使用透明巨型页. 

(1) 以下条件二选一. 

1) 总是使用透明巨型页. 

2) 只在进程使用madvise(MADV_HUGEPAGE)指定的虚拟地址范围内使用透明巨型页, 并且虚拟内存区域设置了允许使用透明巨型页的标志. 

(2) 虚拟内存区域没有设置不允许使用透明巨型页的标志. 

假设一个虚拟内存区域允许使用透明巨型页, 访问虚拟内存区域的时候, 如果没有映射到物理页, 那么生成页错误异常, 页错误异常处理程序的处理过程如下. 

(1) 首先尝试在页上层目录分配巨型页. 如果触发异常的虚拟地址所属的虚拟巨型页超出虚拟内存区域, 或者分配巨型页失败, 那么回退, 尝试在页中间目录分配巨型页. 

(2) 尝试在页中间目录分配巨型页. 如果触发异常的虚拟地址所属的虚拟巨型页超出虚拟内存区域, 或者分配巨型页失败, 那么回退, 尝试分配普通页. 

(3) 分配普通页. 

页上层目录级别的巨型页和页中间目录级别的巨型页仅仅大小不同, 页上层目录级别的巨型页大. 以页中间目录级别的巨型页为例说明, 分配巨型页的时候, 会分配直接页表, 把直接页表添加到页中间目录的直接页表寄存队列中. 直接页表寄存队列有什么用处呢？当释放巨型页的一部分时, 巨型页分裂成普通页, 需要从直接页表寄存队列取一个直接页表. 直接页表寄存队列分两种情况. 

(1) 如果每个页中间目录使用独立的锁, 那么每个页中间目录一个直接页表寄存队列, 头节点是页中间目录的页描述符的成员pmd_huge_pte(见图3.69) . 

图3.69 每个页中间目录一个直接页表寄存队列:



(2) 如果一个进程的所有页中间目录共用一个锁, 那么每个进程一个直接页表寄存队列, 头节点是内存描述符的成员pmd_huge_pte(见图3.70) . 

图3.70 每个进程一个直接页表寄存队列:



内核有一个透明巨型页线程(线程名称是khugepaged) , 定期地扫描允许使用透明巨型页的虚拟内存区域, 尝试把普通页合并成巨型页. 

在分配透明巨页时, 会把进程的内存描述符加入透明巨型页线程的扫描链表中, 如果分配透明巨型页失败, 回退使用普通页, 透明巨型页线程将会尝试把普通页合并成巨型页. 

透明巨型页线程的数据结构如图3.71所示:



(1) 扫描游标khugepaged_scan: 成员mm_head是扫描链表的头节点, 扫描链表的成员是内存描述符插槽；成员mm_slot指向当前正在扫描的内存描述符插槽, 成员address是即将扫描的下一个虚拟地址. 

(2) 内存描述符插槽mm_slot: 成员mm指向进程的内存描述符, 成员hash用来加入散列表, 成员mm_node用来加入扫描链表. 

(3) 内存描述符插槽散列表mm_slots_hash. 

(4) 加入扫描链表的内存描述符设置了标志MMF_VM_HUGEPAGE. 

当进程使用munmap释放巨型页的一部分时, 需要把巨型页分裂成普通页. 以页中间目录级别的巨型页为例说明, 执行过程如下. 

(1) 先把巨型页分裂成普通页. 从直接页表寄存队列取一个直接页表, 页中间目录表项指向直接页表, 直接页表的每个表项指向巨型页中的一个普通页. 

(2) 释放普通页, 把直接页表表项删除. 

透明巨型页分裂前如图3.72所示:

(1) 分配透明巨型页. 

函数 handle_mm_fault 是页错误异常处理程序的核心函数, 如果触发异常的虚拟内存区域使用普通页或透明巨型页, 把主要工作委托给函数 __handle_mm_fault, 如图3.74所示, 函数 __handle_mm_fault 的执行过程如下. 

透明巨型页的页错误异常处理:



1) 在页全局目录中查找表项. 

2) 在页四级目录中查找表项, 如果页四级目录不存在, 先创建页四级目录. 

3) 在页上层目录中查找表项, 如果页上层目录不存在, 先创建页上层目录. 

4) 如果页上层目录表项是空表项, 并且虚拟内存区域允许使用透明巨型页, 那么分配巨型页, 页上层目录表项指向巨型页. 如果触发异常的虚拟地址所属的虚拟巨型页超出虚拟内存区域, 或者分配巨型页失败, 那么回退使用页中间目录级别的巨型页. 

5) 如果页上层目录表项指向巨型页, 表项没有设置写权限, 但是虚拟内存区域有写权限, 那么执行写时复制. 如果分配巨型页失败, 那么回退使用页中间目录级别的巨型页. 

6) 在页中间目录中查找表项, 如果页中间目录不存在, 先创建页中间目录. 

7) 如果页中间目录表项是空表项, 并且虚拟内存区域允许使用透明巨型页, 那么分配巨型页, 页中间目录表项指向巨型页. 如果触发异常的虚拟地址所属的虚拟巨型页超出虚拟内存区域, 或者分配巨型页失败, 那么回退使用普通页. 

8) 如果页中间目录表项指向巨型页, 表项没有设置写权限, 但是虚拟内存区域有写权限, 那么执行写时复制. 如果分配巨型页失败, 那么回退使用普通页. 

9) 在直接页表中分配并映射到普通页. 

函数create_huge_pmd负责分配页中间目录级别的巨型页, 执行流程如图3.75所示. 

图3.75 分配透明巨型页的执行流程:



1) 如果是私有匿名映射, 调用函数 do_huge_pmd_anonymous_page 来处理. 

- 如果触发异常的虚拟地址所属的虚拟巨型页超出虚拟内存区域, 那么回退使用普通页. 

- 调用函数anon_vma_prepare, 为反向映射准备结构体anon_vma. 

- 调用函数khugepaged_enter, 把内存描述符添加到透明巨型页线程的扫描链表中. 如果分配巨型页失败, 回退使用普通页, 透明巨型页线程将会尝试把普通页合并成巨型页. 

- 如果是读操作, 并且允许使用巨型零页, 那么映射到全局的巨型零页. 

- 分配巨型页. 

- 调用函数__do_huge_pmd_anonymous_page, 设置页中间目录表项, 映射到巨型页. 

2) 如果是文件映射或者共享匿名映射, 调用虚拟内存区域的虚拟内存操作集合中的huge_fault方法来处理. 

函数 __do_huge_pmd_anonymous_page 负责为私有匿名映射设置页中间目录表项, 映射到巨型页, 如图3.76所示, 执行流程如下. 

图3.76 映射到透明巨型页的执行流程:



1) 分配直接页表. 

2) 把巨型页清零. 

3) 设置页描述符的标志位PG_uptodate, 表示物理页包含有效的数据. 

4) 锁住页表. 

5) 如果锁住页表以后发现页中间目录表项不是空表项, 说明其他处理器正在竞争, 已经分配并且映射到物理页, 那么当前处理器放弃操作. 

6) 构造页中间目录表项的值. 

7) 为匿名巨型页添加反向映射. 

8) 把巨型页添加到LRU链表中. 

9) 把直接页表添加到寄存队列中. 当释放巨型页的一部分时, 需要把巨型页分裂成普通页, 从寄存队列取出直接页表使用. 

10) 设置页中间目录表项指向巨型页. 

11) 释放页表锁. 

(2) 透明巨型页线程. 

透明巨型页线程负责定期扫描允许使用透明巨型页的虚拟内存区域, 尝试把普通页合并成巨型页, 执行流程如图3.77所示. 每次从上次结束的位置继续扫描内存描述符插槽链表, 对扫描的页数(指普通页的数量) 有限制, 如果扫描的页数达到限制, 睡眠一段时间后继续扫描. 函数khugepaged_do_scan的执行过程是, 如果扫描的页数没有达到限制, 重复执行下面的步骤. 

图3.77 透明巨型页线程的执行流程:



1) 调用函数khugepaged_prealloc_page, 预先分配一个巨型页. 在NUMA系统上函数khugepaged_prealloc_page不会分配巨型页, 执行到函数collapse_huge_page的时候才分配巨型页. 

2) 调用函数khugepaged_scan_mm_slot, 扫描一个内存描述符插槽, 针对进程的每个虚拟内存区域, 处理如下. 

- 调用函数hugepage_vma_check, 检查虚拟内存区域是否允许使用透明巨型页. 

- 如果是共享内存, 调用函数khugepaged_scan_shmem来处理. 

- 如果不是共享内存, 调用函数khugepaged_scan_pmd来处理. 

函数 khugepaged_scan_pmd 的执行过程是: 如果页中间目录表项指向直接页表, 至少一个页有写权限, 并且至少一个页刚刚被访问过, 那么调用函数 collapse_huge_page, 把普通页合并成巨型页. 如果全部是只读页, 或者最近都没有访问过, 那么不会合并成巨型页. 

函数 collapse_huge_page 负责把普通页合并成巨型页, 执行流程如图3.78所示. 

图3.78 把普通页合并成巨型页的执行流程:



1) 调用函数khugepaged_alloc_page以分配巨型页. 这个函数只会在NUMA系统上分配巨型页, 如果不是NUMA系统, 函数khugepaged_do_scan已经分配了巨型页. 

2) 部分普通页可能换出到交换区, 需要把这些普通页从交换区读到内存中. 

3) 隔离准备合并的所有普通页. 

4) 把数据从普通页复制到巨型页, 释放普通页. 

5) 为巨型页添加反向映射. 

6) 把巨型页加入LRU链表. 

7) 把直接页表添加到寄存队列中. 

8) 设置页中间目录表项指向巨型页. 

9) 更新页表缓存. 

(3) 释放透明巨型页. 

假设进程使用munmap释放虚拟内存区域, 而这个虚拟内存区域可能映射到透明巨型页, 可能是释放巨型页的一部分, 也可能是释放整个巨型页. 

函数 unmap_single_vma 负责删除一个虚拟内存区域, 执行流程如图3.79所示. 如果虚拟内存区域使用普通页或透明巨型页, 把主要工作委托给函数 unmap_page_range. 

图3.79 释放透明巨型页的执行流程:



函数 unmap_page_range 负责处理页全局目录, 针对每个需要删除的页全局目录表项, 调用函数zap_p4d_range来处理页四级目录. 

函数zap_p4d_range负责处理页四级目录, 针对每个需要删除的页四级目录表项, 调用函数zap_pud_range来处理页上层目录. 

函数zap_pud_range负责处理页上层目录, 针对每个需要删除的页上层目录表项, 执行过程如下. 

1) 如果页上层目录表项指向透明巨型页, 处理如下. 

- 如果释放巨型页的一部分, 那么调用函数split_huge_pud以分裂巨型页. 

- 如果释放整个巨型页, 那么调用函数zap_huge_pud以删除页上层目录表项, 释放巨型页. 

2) 如果页上层目录表项指向页中间目录, 或者释放巨型页的一部分, 那么调用函数 zap_pmd_range 以处理页中间目录. 

函数zap_pmd_range负责处理页中间目录, 针对每个需要删除的页中间目录表项, 执行过程如下. 

1) 如果页中间目录表项指向透明巨型页, 处理如下. 

- 如果释放巨型页的一部分, 那么调用函数__split_huge_pmd以分裂巨型页. 

- 如果释放整个巨型页, 那么调用函数zap_huge_pmd以删除页中间目录表项, 释放巨型页. 

2) 如果页中间目录表项指向直接页表, 或者释放巨型页的一部分, 那么调用函数zap_pte_range以处理直接页表. 

函数__split_huge_pmd负责把页中间目录级别的透明巨型页分裂成普通页, 执行流程如图3.80所示. 把主要工作委托给函数__split_huge_pmd_locked, 执行过程如下. 

图3.80 分裂透明巨型页的执行流程:



1) 如果是文件映射或者共享匿名映射, 说明巨型页在文件的页缓存中, 因为可能有多个进程共享, 所以不能把巨型页分裂成普通页, 只需要删除映射, 处理如下. 

- 删除页中间目录表项. 

- 从寄存队列中取一个直接页表并删除. 

- 删除反向映射. 

- 把巨型页的引用计数减1. 

2) 如果是私有匿名映射, 映射到巨型零页, 那么调用函数 __split_huge_zero_page_pmd 以分裂巨型零页. 

3) 如果是私有匿名映射, 没有映射到巨型零页, 那么把巨型页分裂成普通页, 处理如下. 

- 从寄存队列中取一个直接页表. 

- 填充直接页表, 每个表项指向巨型页中的一个普通页. 

- 清除页中间目录表项. 

- 页中间目录表项指向直接页表. 

