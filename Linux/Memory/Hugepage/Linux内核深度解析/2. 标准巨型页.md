

# 使用方法

编译内核时需要打开配置宏 `CONFIG_HUGETLBFS` 和`CONFIG_HUGETLB_PAGE`(打开配置宏 `CONFIG_HUGETLBFS` 的时候会自动打开) . 



通过文件 “`/proc/sys/vm/nr_hugepages`” 指定**巨型页池**中**永久巨型页**的**数量**, 预先分配指定数量的永久巨型页到巨型页池中. 另一种方法是在**引导内核时**指定**内核参数** “`hugepages=N`” 以分配永久巨型页, 这是分配巨型页最可靠的方法, 因为**内存还没有碎片化**. 

有些平台支持**多种巨型页长度**. 如果要分配特定长度的巨型页, 必须在内核参数 “`hugepages`” 前面添加选择**巨型页长度的参数** “`hugepagesz=<size>[kKmMgG]`”. 可以使用**内核参数** “`default_hugepagesz=<size>[kKmMgG]`” 选择**默认的巨型页长度**. 文件 “`/proc/sys/vm/nr_hugepages`” 表示**默认长度的永久巨型页的数量**. 

通过文件 “`/proc/sys/vm/nr_overcommit_hugepages`” 指定**巨型页池**中**临时巨型页的数量**, 当**永久巨型页用完**的时候, 可以从页分配器**申请临时巨型页**. 

`nr_hugepages` 是**巨型页池**的**最小长度**, (`nr_hugepages + nr_overcommit_hugepages`) 是巨型页池的**最大长度**. 这两个参数的默认值都是0, 至少要设置一个, 不然分配巨型页会失败. 


创建**匿名的巨型页映射**, 其代码如下: 

```
#define MAP_LENGTH (10 * 1024 * 1024)
addr = mmap(0, MAP_LENGTH, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);
```

创建**基于文件的巨型页映射**, 首先管理员需要在**某个目录**下**挂载 hugetlbfs 文件系统**: 

```
mount -t hugetlbfs \
-o uid=<value>,gid=<value>,mode=<value>,pagesize=<value>,size=<value>, \
min_size=<value>,nr_inodes=<value> none <目录>
```

各选项的意思如下. 

(1) 选项 uid 和 gid 指定**文件系统的根目录**的**用户**和**组**, 默认取**当前进程的用户和组**. 

(2) 选项 mode 指定文件系统的根目录的模式, 默认值是0755. 

(3) 如果**平台支持多种巨型页长度**, 可以使用选项 pagesize 指定巨型页长度和关联的巨型页池. 如果不使用选项 pagesize, 表示使用**默认的巨型页长度**. 

(4) 选项 size 指定允许文件系统使用的**巨型页**的**最大数量**. 如果不指定选项size, 表示没有限制. 

(5) 选项 `min_size` 指定允许文件系统使用的**巨型页**的**最小数量**. 挂载文件系统的时候, 申请巨型页池为这个文件系统**预留**选项 `min_size` 指定的巨型页数量. 如果不指定选项`min_size`, 表示没有限制. 

(6) 选项 `nr_inodes` 指定文件系统中文件(一个文件对应一个索引节点) 的最大数量. 如果不指定选项nr_inodes, 表示没有限制. 



假设在**目录** “`/mnt/huge`” 下**挂载**了 **hugetlbfs** 文件系统, **应用程序**在 hugetlbfs 文件系统中**创建文件**, 然后**创建基于文件的内存映射**, 这个内存映射就会使用巨型页. 

```
#define MAP_LENGTH (10 * 1024 * 1024)
fd = open("/mnt/huge/test", O_CREAT | O_RDWR, S_IREXU);
addr = mmap(0, MAP_LENGTH, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
```

**应用程序**可以使用**开源**的 **hugetlbfs 库**, 这个库**对 hugetlbfs 文件系统做了封装**. 使用 hugetlbfs 库的好处如下. 

(1) **启动程序**时使用**环境变量** “`LD_PRELOAD=libhugetlbfs.so`” 把 **hugetlbfs 库**设置成优先级最高的**动态库**, `malloc()` **使用巨型页**, 对应用程序完全透明, **应用程序不需要修改代码**. 

(2) 可以把代码段、数据段和未初始化数据段都放在巨型页中. 



执行命令 “`cat /proc/meminfo`” 可以看到巨型页的信息:

```
...
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
```

这些字段的意思如下. 

(1) `HugePages_Total`: **巨型页池**的**大小**. 

(2) `HugePages_Free`: 巨型页池中**没有分配**的巨型页的**数量**. 

(3) `HugePages_Rsvd`: “Rsvd”是“Reserved”的缩写, 意思是“预留的”, 是**已经承诺从巨型页池中分配**但是**还没有分配**的巨型页的**数量**. 预留的巨型页保证**应用程序**在**发生缺页异常**的时候能够从巨型页池中分配一个巨型页. 

(4) `HugePages_Surp`: “Surp”是“Surplus”的缩写, 意思是“**多余的**”, 是巨型页池中**临时巨型页**的数量. 临时巨型页的最大数量由“`/proc/sys/vm/nr_overcommit_hugepages`”控制. 

(5) Hugepagesize: 巨型页的大小. 

# 实现原理

(1) 巨型页池

内核使用**巨型页池**管理巨型页. 有的**处理器架构**支持多种巨型页长度, **每种巨型页长度**对应一个, 有一个**默认的巨型页长度**, 默认只创建巨型页长度是默认长度的巨型页池. 例如 ARM64 架构在页长度为4KB的时候支持的巨型页长度是1GB、32MB、2MB和64KB, 默认的巨型页长度是2MB, 默认只创建巨型页长度是2MB的巨型页池. 如果需要创建巨型页长度不是默认长度的巨型页池, 可以在引导内核时指定内核参数 “`hugepagesz=<size>[kKmMgG]`”, 长度必须是处理器支持的长度. 可以使用内核参数 “`default_hugepagesz=<size>[kKmMgG]`” 选择默认的巨型页长度. 

**巨型页池**的数据结构是结构体 `hstate`, **全局数组 hstates** 是**巨型页池数组**, **全局变量** `hugetlb_max_hstate` 是**巨型页池的数量**, 全局变量 `default_hstate_idx` 是**默认巨型页池**的**索引**. 

```

```

**巨型页池**中的**巨型页**分为两种. 

1) **永久巨型页**: 永久巨型页是保留的, 不能有其他用途, 被预先分配到巨型页池, 当进程释放永久巨型页的时候, 永久巨型页被归还到巨型页池. 

2) **临时巨型页**: 也称为**多余的**(`surplus`) 巨型页, 当永久巨型页用完的时候, 可以从**页分配器**分配**临时巨型页**；进程释放临时巨型页的时候, **直接释放到页分配器**. 当设备长时间运行后, 内存可能碎片化, 分配临时巨型页可能失败. 

巨型页池的数据结构hstate的主要成员如表3.7所示. 

表3.7 巨型页池的数据结构hstate的主要成员:

![2022-02-21-22-39-30.png](./images/2022-02-21-22-39-30.png)

(2) 预先分配永久巨型页. 

预先分配指定数量的永久巨型页到巨型页池中有两种方法. 

1) 最可靠的方法是在引导内核时指定内核参数“hugepages=N”来分配永久巨型页, 因为内核初始化的时候内存还没有碎片化. 

有些处理器架构支持多种巨型页长度. 如果要分配特定长度的巨型页, 必须在内核参数“hugepages”前面添加选择巨型页长度的参数
“`hugepagesz=<size>[kKmMgG]`”. 

2) 通过文件“/proc/sys/vm/nr_hugepages”指定默认长度的永久巨型页的数量. 

内核参数 “`hugepages=N`” 的处理函数是 `hugetlb_nrpages_setup`, 其代码如下: 

```

```

第6～10行代码, 如果内核参数“hugepagesz=”指定的巨型页长度是非法的, 直接返回. 

第16行和第17行代码, 如果前面没有内核参数“hugepagesz=”, 那么内核参数“hugepages=”指定默认巨型页池的永久巨型页的数量. 

第18行和第19行代码, 如果前面有内核参数“hugepagesz=”指定巨型页长度, 那么内核参数“hugepages=”指定该巨型页长度对应的巨型页池的永久巨型页的数量. 

第26行代码, 解析并保存内核参数“hugepagesz=”的值. 

第29行和第30行代码, 如果前面有内核参数“hugepagesz=”指定巨型页长度, 并且巨型页长度超过页分配器支持的最大阶数, 那么需要从引导内存分配器分配巨型页. 如果巨型页长度小于或等于页分配器支持的最大阶数, 巨型页子系统在初始化的时候从页分配器分配巨型页. 

函数hugetlb_hstate_alloc_pages负责预先分配指定数量的永久巨型页, 其代码如下: 

```

```

第6行和第7行代码, 如果巨型页长度超过页分配器支持的最大阶数, 那么从引导内存分配器分配巨型页. 

第9行代码, 如果巨型页长度小于或等于页分配器支持的最大阶数, 那么从页分配器分配巨型页. 

函数alloc_bootmem_huge_page负责从引导内存分配器分配巨型页, 其代码如下: 

```

```

第9行代码, 从内存节点分配巨型页. 

第22行代码, 把巨型页添加到链表huge_boot_pages中. 

在巨型页子系统初始化时, 把链表huge_boot_pages中的巨型页添加到对应的巨型页池中, 其代码如下: 

```

```

第17行代码, 把巨型页组织成复合页. 

第19行代码, 把巨型页添加到对应的巨型页池中. 

如果巨型页长度小于或等于页分配器支持的最大阶数, 那么在巨型页子系统初始化的时候从页分配器预先分配永久巨型页, 其代码如下: 

```

```

针对每个巨型页池, 如果巨型页长度小于或等于页分配器支持的最大阶数, 那么从页分配器分配永久巨型页, 添加到巨型页池中. 

文件“/proc/sys/vm/nr_hugepages”的处理函数是hugetlb_sysctl_handler, 最终调用函数set_max_huge_pages来增加或减少永久巨型页, 其代码如下: 

```

```

参数count指定永久巨型页的最大数量. 

第10～32行代码, 如果增加永久巨型页的数量, 处理如下. 

* 第10～13行代码, 如果有临时巨型页, 那么把临时巨型页转换为永久巨型页. 

* 第15～32行代码, 如果永久巨型页的数量不够, 那么分配巨型页. 

第34行和第45行代码, 如果减小永久巨型页的数量, 处理如下. 

* 第34行代码, min_count等于(巨型页总数 −(空闲巨型页数量 − 预留巨型页数量) ) , 即扣除没有预留的空闲巨型页. 注意预留巨型页数量包含在空闲巨型页数量里面, 进程创建内存映射的时候已经申请预留巨型页. 

* 第35行代码, min_count不能小于count. 

* 第36行代码, 如果支持高端内存区域, 优先把从低端内存区域分配的没有预留的空闲巨型页归还给页分配器. 

* 第37～41行代码, 如果永久巨型页的数量超过min_count, 那么把没有预留的空闲巨型页归还给页分配器. 

* 第42～45行代码, 如果永久巨型页的数量超过指定的最大数量, 那么把永久巨型页转换为临时巨型页. 

(3) 挂载hugetlbfs文件. 

hugetlbfs文件系统在初始化的时候, 调用函数register_filesystem以注册hugetlbfs文件系统, hugetlbfs文件系统的结构体如下: 

```

```

挂载hugetlbfs文件系统的时候, 挂载函数调用hugetlbfs文件系统的挂载函数hugetlbfs_mount, 创建超级块和根目录, 把文件系统和巨型页池关联起来. 

如图3.66所示, 超级块的成员s_fs_info指向hugetblfs文件系统的私有信息；成员s_blocksize是块长度, 被设置为巨型页的长度. 

图3.66 hugetlbfs文件系统关联巨型页池

![2022-02-22-10-51-48.png](./images/2022-02-22-10-51-48.png)

结构体hugetlbfs_sb_info描述hugetblfs文件系统的私有信息. 

1) 成员max_inode是允许的索引节点最大数量. 

2) 成员free_inodes是空闲的索引节点数量. 

3) 成员hstate指向关联的巨型页池. 

4) 如果指定了最大巨型页数量或最小巨型页数量, 那么为巨型页池创建一个子池, 成员spool指向子池. 

结构体hugepage_subpool描述子池的信息. 

1) 成员max_hpages是允许的最大巨型页数量. 

2) used_hpages是已使用的巨型页数量, 包括分配的和预留的. 

3) 成员hstate指向巨型页池. 

4) 成员min_hpages是最小巨型页数量. 

5) 成员rsv_hpages是子池向巨型页池申请预留的巨型页的数量. 

(4) 创建文件. 

调用系统调用open(), 在hugetlbfs文件系统的一个目录下创建一个文件的时候, 系统调用open最终调用函数hugetlbfs_create()为文件分配索引节点(结构体inode) 并且初始化, 索引节点的成员i_fop指向hugetlbfs文件系统特有的文件操作集合hugetlbfs_file_operations, 这个文件操作集合的成员mmap方法是函数hugetlbfs_file_mmap(), 这个函数在创建内存映射的时候很关键. 

(5) 创建内存映射. 

在hugetlbfs文件系统中打开文件, 然后基于这个文件创建内存映射时, 系统调用mmap将会调用函数hugetlbfs_file_mmap(). 

函数hugetlbfs_file_mmap()的主要功能如下. 

1) 设置标准巨型页标志VM_HUGETLB和不允许扩展标志VM_DONTEXPAND. 

2) 虚拟内存区域的成员vm_ops指向巨型页特有的虚拟内存操作集合hugetlb_vm_ops. 

3) 检查文件的偏移是不是巨型页长度的整数倍. 

4) 调用函数hugetlb_reserve_pages(), 向巨型页池申请预留巨型页. 

函数hugetlb_reserve_pages()的主要功能如下. 

1) 如果设置标志位VM_NORESERVE指定不需要预留巨型页, 直接返回. 

2) 如果是共享映射, 那么使用文件的索引节点的预留图(结构体resv_map) , 如图3.67所示, 在预留图中查看从文件的起始偏移到结束偏移有哪些部分以前没有预留, 计算需要预留的巨型页的数量N. 

图3.67 共享映射的预留图:

![2022-02-22-10-53-33.png](./images/2022-02-22-10-53-33.png)

3) 如果是私有映射, 那么创建预留图, 虚拟内存区域的成员vm_private_data指向预留图, 并且设置标志HPAGE_RESV_OWNER指明该虚拟内存区域拥有这个预留, 如图3.68所示. 计算需要预留的巨型页的数量N =(文件的结束偏移 − 起始偏移) , 偏移的单位是巨型页长度. 

图3.68 私有映射的预留图:

![2022-02-22-10-54-16.png](./images/2022-02-22-10-54-16.png)

虚拟内存区域的成员vm_private_data的最低两位用来存储标志位. 

* 标志位HPAGE_RESV_OWNER, 值为1, 指明当前进程是预留的拥有者. 
* 标志位HPAGE_RESV_UNMAPPED, 值为2. 对于私有映射, 如果创建映射的进程在执行写时复制时分配巨型页失败, 那么删除所有子进程的映射, 设置该标志, 让子进程在发生页错误异常时被杀死. 

4) 如果文件系统创建了巨型页子池, 计算子池需要向巨型页池申请预留的巨型页的数量, 否则需要向巨型页池申请预留的巨型页的数量是N. 

如果子池以前申请预留的巨型页数量大于或等于N, 那么子池不需要向巨型页池申请预留. 

如果子池以前申请预留的巨型页数量小于N, 那么子池需要向巨型页池申请预留的数量等于(N − 子池以前申请预留的巨型页数量) . 

5) 向巨型页池申请预留指定数量的巨型页. 

6) 如果是共享映射, 那么在预留图的区域链表中增加1个file_region实例, 记录预留区域. 

(6) 分配和映射到巨型页. 

第一次访问巨型页的时候触发缺页异常, 函数handle_mm_fault发现虚拟内存区域设置了标志VM_HUGETLB, 调用巨型页的页错误处理函数hugetlb_fault. 

函数hugetlb_fault发现页表项是空表项, 调用函数hugetlb_no_page以分配并且映射到巨型页. 

函数hugetlb_no_page的执行过程如下. 

1) 在文件的页缓存中根据文件的页偏移查找页. 

2) 如果在页缓存中没有找到页, 调用函数alloc_huge_page以分配巨型页. 如果是共享映射, 那么把巨型页加入文件的页缓存, 以便和其他进程共享页. 

3) 设置页表项. 

4) 如果第一步在页缓存中找到页, 映射是私有的, 并且执行写操作, 那么执行写时复制. 

函数alloc_huge_page的执行过程如下. 

1) 检查预留图, 确定进程是否预留过要分配的巨型页. 

2) 如果进程没有预留巨型页, 检查分配是否超过子池的限制. 

3) 从巨型页池中目标内存节点的空闲链表中分配永久巨型页. 

4) 如果分配永久巨型页失败, 那么尝试从页分配器分配临时巨型页. 

(7) 写时复制. 

假设进程1创建了私有的巨型页映射, 然后进程1分叉生成进程2和进程3. 其中一个进程试图写巨型页的时候, 触发页错误异常, 巨型页的页错误处理函数hugetlb_fault调用函数hugetlb_cow以执行写时复制. 

函数hugetlb_cow的执行过程如下. 

1) 如果只有一个虚拟页映射到该物理页, 并且是匿名映射, 那么不需要复制, 直接修改页表项设置可写. 

2) 分配巨型页. 

3) 处理分配巨型页失败的情况. 

如果触发页错误异常的进程是创建私有映射的进程, 那么删除所有子进程的映射, 为子进程的虚拟内存区域的成员vm_private_data设置标志HPAGE_RESV_UNMAPPED, 让子进程在发生页错误异常的时候被杀死. 如果触发页错误异常的进程不是创建私有映射的进程, 返回错误. 

4) 把旧页的数据复制到新页. 

5) 修改页表项, 映射到新页, 并且设置可写. 