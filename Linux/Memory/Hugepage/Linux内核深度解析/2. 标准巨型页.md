

# 使用方法

编译内核时需要打开配置宏 `CONFIG_HUGETLBFS` 和`CONFIG_HUGETLB_PAGE`（打开配置宏 `CONFIG_HUGETLBFS` 的时候会自动打开）。



通过文件 “`/proc/sys/vm/nr_hugepages`” 指定**巨型页池**中**永久巨型页**的**数量**，预先分配指定数量的永久巨型页到巨型页池中。另一种方法是在**引导内核时**指定**内核参数** “`hugepages=N`” 以分配永久巨型页，这是分配巨型页最可靠的方法，因为**内存还没有碎片化**。

有些平台支持**多种巨型页长度**。如果要分配特定长度的巨型页，必须在内核参数 “`hugepages`” 前面添加选择**巨型页长度的参数** “`hugepagesz=<size>[kKmMgG]`”。可以使用内核参数 “`default_hugepagesz=<size>[kKmMgG]`” 选择**默认的巨型页长度**。文件 “`/proc/sys/vm/nr_hugepages`” 表示**默认长度的永久巨型页的数量**。

通过文件 “`/proc/sys/vm/nr_overcommit_hugepages`” 指定**巨型页池**中**临时巨型页的数量**，当**永久巨型页用完**的时候，可以从页分配器**申请临时巨型页**。

`nr_hugepages` 是**巨型页池**的**最小长度**，（`nr_hugepages + nr_overcommit_hugepages`）是巨型页池的**最大长度**。这两个参数的默认值都是0，至少要设置一个，不然分配巨型页会失败。


创建匿名的巨型页映射，其代码如下：

```

```

如果要创建基于文件的巨型页映射，首先管理员需要在某个目录下挂载hugetlbfs文件系统：

```

```

各选项的意思如下。（1）选项uid和gid指定文件系统的根目录的用户和组，默认取当前进程的用户和组。

（2）选项mode指定文件系统的根目录的模式，默认值是0755。

（3）如果平台支持多种巨型页长度，可以使用选项pagesize指定巨型页长度和关联的巨型页池。如果不使用选项pagesize，表示使用默认的巨型页长度。

（4）选项size指定允许文件系统使用的巨型页的最大数量。如果不指定选项size，表示没有限制。

（5）选项min_size指定允许文件系统使用的巨型页的最小数量。挂载文件系统的时候，申请巨型页池为这个文件系统预留选项min_size指定的巨型页数量。如果不指定选项min_size，表示没有限制。

（6）选项nr_inodes指定文件系统中文件（一个文件对应一个索引节点）的最大数量。如果不指定选项nr_inodes，表示没有限制。



假设在目录 “`/mnt/huge`” 下挂载了 hugetlbfs 文件系统，应用程序在 hugetlbfs 文件系统中创建文件，然后创建基于文件的内存映射，这个内存映射就会使用巨型页。



应用程序可以使用开源的hugetlbfs库，这个库对hugetlbfs文件系统做了封装。使用hugetlbfs库的好处如下。

（1）启动程序时使用环境变量“LD_PRELOAD=libhugetlbfs.so”把hugetlbfs库设置成优先级最高的动态库，malloc()使用巨型页，对应用程序完全透明，应用程序不需要修改代码。

（2）可以把代码段、数据段和未初始化数据段都放在巨型页中。



执行命令 “`cat /proc/meminfo`” 可以看到巨型页的信息:

```
...
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
```

这些字段的意思如下。

（1）HugePages_Total：巨型页池的大小。

（2）HugePages_Free：巨型页池中没有分配的巨型页的数量。

（3）HugePages_Rsvd:“Rsvd”是“Reserved”的缩写，意思是“预留的”，是已经承诺从巨型页池中分配但是还没有分配的巨型页的数量。预留的巨型页保证应用程序在发生缺页异常的时候能够从巨型页池中分配一个巨型页。

（4）HugePages_Surp:“Surp”是“Surplus”的缩写，意思是“多余的”，是巨型页池中临时巨型页的数量。临时巨型页的最大数量由“/proc/sys/vm/nr_overcommit_hugepages”控制。

（5）Hugepagesize：巨型页的大小。

# 实现原理

## 巨型页池

内核使用巨型页池管理巨型页。有的处理器架构支持多种巨型页长度，每种巨型页长度对应一个巨型页池，有一个默认的巨型页长度，默认只创建巨型页长度是默认长度的巨型页池。例如ARM64架构在页长度为4KB的时候支持的巨型页长度是1GB、32MB、2MB和64KB，默认的巨型页长度是2MB，默认只创建巨型页长度是2MB的巨型页池。如果需要创建巨型页长度不是默认长度的巨型页池，可以在引导内核时指定内核参数 “`hugepagesz=<size>[kKmMgG]`”，长度必须是处理器支持的长度。可以使用内核参数 “`default_hugepagesz=<size>[kKmMgG]`” 选择默认的巨型页长度。

巨型页池的数据结构是结构体hstate，全局数组hstates是巨型页池数组，全局变量hugetlb_max_hstate是巨型页池的数量，全局变量default_hstate_idx是默认巨型页池的索引。

```

```

巨型页池中的巨型页分为两种。

1）永久巨型页：永久巨型页是保留的，不能有其他用途，被预先分配到巨型页池，当进程释放永久巨型页的时候，永久巨型页被归还到巨型页池。

2）临时巨型页：也称为多余的（surplus）巨型页，当永久巨型页用完的时候，可以从页分配器分配临时巨型页；进程释放临时巨型页的时候，直接释放到页分配器。当设备长时间运行后，内存可能碎片化，分配临时巨型页可能失败。

巨型页池的数据结构hstate的主要成员如表3.7所示。

表3.7 巨型页池的数据结构hstate的主要成员:

![2022-02-21-22-39-30.png](./images/2022-02-21-22-39-30.png)

（2）预先分配永久巨型页。

预先分配指定数量的永久巨型页到巨型页池中有两种方法。1）最可靠的方法是在引导内核时指定内核参数“hugepages=N”来分配永久巨型页，因为内核初始化的时候内存还没有碎片化。有些处理器架构支持多种巨型页长度。如果要分配特定长度的巨型页，必须在内核参数“hugepages”前面添加选择巨型页长度的参数“hugepagesz=<size>[kKmMgG]”。2）通过文件“/proc/sys/vm/nr_hugepages”指定默认长度的永久巨型页的数量。内核参数“hugepages=N”的处理函数是hugetlb_nrpages_setup，其代码如下：