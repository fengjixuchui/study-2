
# 概述

## 需求背景

Cgroup的memory子系统，即memory cgroup(本文以下简称memcg)，提供了对系统中**一组进程**的**内存行为**的管理，从而对整个系统中对内存有不用需求的进程或应用程序区分管理，实现更有效的资源利用和隔离。

在实际业务场景中，为了防止一些应用程序对资源的滥用(可能因为应用本身的bug，如内存泄露)，导致对同一主机上其他应用造成影响，我们往往希望可以控制应用程序的内存使用量，这是memcg提供的主要功能之一，当然它还可以做的更多。

Memcg的应用场景，往往来自一些虚拟化的业务需求，所以memcg往往作为cgroup的一个子系统与容器方案一起应用。在容器方案中，与一般的虚拟化方案不同，memcg在管理内存时，并不会在物理内存上对每个容器做区分，也就是说所有的容器使用的是同一个物理内存(有一种例外情况，如果存在多个内存节点，则可以通过cgroup中的cpuset子系统将不同的内存节点应用到不同的容器中)。对于共用的物理内存，memcg也不会对不同的容器做物理页面的**预分配**，也就是说同一个内存page，可能会被容器A使用，也可能被容器B使用。

所以memcg应用在容器方案中，虽然没有实现真正意义上的内存虚拟化，但是通过内核级的内存管理，依然可以实现某种意义上的虚拟化的内存管理，而且是真正的轻量级的。

## 应用场景

Memcg的主要**应用场景**有: 

a. 隔离一个或一组应用程序的内存使用

对于内存饥渴型的应用程序，我们可以通过memcg将其可用内存限定在一定的数量以内，实现与其他应用程序内存使用上的隔离。

b. 创建一个有内存使用限制的控制组

比如在启动的时候就设置mem=XXXX。

c. 在虚拟化方案中，控制虚拟机的内存大小

比如可应用在LXC的容器方案中。

d. 确保应用的内存使用量

比如在录制CD/DVD时，通过限制系统中其他应用可以使用的内存大小，可以保证录制CD/DVD的进程始终有足够的内存使用，以避免因为内存不足导致录制失败。

e. 其他

各种通过memcg提供的特性可应用到的场景。

## 功能特性

为了支撑以上场景，这里也简单列举一下memcg可以提供的**功能特性**: 

a. 统计anonymous pages, file caches, swap caches的使用并限制它们的使用；

b. 所有page都链接在per-memcg的LRU链表中，将不再存在global的LRU；

c. 可以选择统计和限制memory+swap的内存；

d. 对hierarchical的支持；

e. Soft limit；

f. 可以选择在移动一个进程的时候，同时移动对该进程的page统计计数；

g. 内存使用量的阈值超限通知机制；

h. 可以选择关闭oom-killer，并支持oom的通知机制；

i. Root cgroup不存在任何限制；

## 代码分析

基于

```
VERSION = 5
PATCHLEVEL = 11
SUBLEVEL = 0
EXTRAVERSION = -rc4
```

# 总体设计

## Memcg

Memcg在cgroup体系中提供memory隔离的功能，它跟cgroup中其他子系统一样可以由admin创建，形成一个树形结构，可以将进程加入到这些memcg中管理。

Memcg设计的核心是一个叫做`res_counter`的结构体，该结构体跟踪记录当前的内存使用和与该memcg关联的一组进程的内存使用限制值，每个memcg都有一个与之相关的`res_counter`结构。





> 整个统计和限制的实现过程可简单描述为: 
>某进程在需要统计的地方调用mem_cgroup_charge()来进行必要的结构体设置(增加计数等)，判断增加计数后进程所在的cgroup的内存使用是否超过限制，如果超过了，则触发reclaim机制进行内存回收，如果回收后依然超过限制，则触发oom或阻塞机制等待；如果增加计数后没有超过限制，则更新相应page对应的page_cgroup，完成统计计数的修改，并将相应的page放到对应的LRU中进行管理。


>对于charge(统计)功能的实现:
>a. 统计针对每一个cgroup进行；
>b. 每个cgroup中的进程，它的mm_struct知道自己属于哪个cgroup；
>c. 每个page对应一个page_cgroup，而page_cgroup知道自己属于哪个memcg；





https://blog.csdn.net/tanzhe2017/article/details/81001507