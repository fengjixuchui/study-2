
Linux 电源管理存在的几种方式, 如何查看这几种方式, 以及最后的如何睡眠唤醒等. 通过 `echo mem > /sys/power/state` 就可以达到睡眠, 所以可以根据此节点的 sys 代码分析 suspend 的流程.

# 分析方法

利用虚拟化进行分析.

## guest kernel

确保 guest kernel 有 CONFIG_PM_SLEEP_DEBUG 这个选项

```
mkdir build

cp kernel_config build/.config

make olddefconfig O=build

make -j 12 O=build

make modules_install INSTALL_MOD_PATH=rootfs O=build

tar zcvf /home/ubuntu/haiwei/modules.tar.gz ./build/rootfs/lib/modules

cp ./build/arch/x86_64/boot/bzImage /home/ubuntu/haiwei/
```

需要将 modules 拷贝到 guest image 中

## OVMF

```
git clone https://github.com/tianocore/edk2.git
cd edks
git submodule update --init

cp BaseTool/Conf/target.template Conf/target.txt
```

编辑 Conf/target.txt

```
ACTIVE_PLATFORM       = OvmfPkg/OvmfPkgX64.dsc
TARGET                = DEBUG
TARGET_ARCH           = X64
TOOL_CHAIN_TAG        = GCC5
```

```
OvmfPkg/build.sh -a X64 -D DEBUG_ON_SERIAL_PORT
ll Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd
```

## 命令行

debug ovmf:

>qemu-system-x86_64 -name ubuntu -accel kvm -drive file=/home/ubuntu/haiwei/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd,format=raw,if=pflash -cpu host -m 2G -smp 2 -drive file=/home/ubuntu/haiwei/ubuntu22.04.qcow2,format=qcow2,if=none,id=drive-virtio-disk0,cache=none -object iothread,id=iothread0 -device virtio-blk-pci,iothread=iothread0,scsi=off,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1 -netdev user,id=hostnet0 -device rtl8139,netdev=hostnet0,id=net0,mac=52:54:00:36:32:aa,bus=pci.0,addr=0x5 -chardev socket,id=montest,server=on,wait=off,path=/tmp/mon_test -mon chardev=montest,mode=readline -serial mon:stdio -nographic

debug kernel:

> qemu-system-x86_64 -name ubuntu -accel kvm -cpu host,host-cache-info=true -m 2G -smp 2 -hda /home/ubuntu/haiwei/ubuntu22.04.qcow2 -netdev user,id=hostnet0 -device rtl8139,netdev=hostnet0,id=net0,mac=52:54:00:36:32:aa,bus=pci.0,addr=0x5 -kernel /home/ubuntu/haiwei/linux/build/arch/x86_64/boot/bzImage -append "root=/dev/sda1 ro console=tty1 console=ttyS0 intel_iommu=sm_on,on loglevel=8 pm_debug_messages dyndbg='file pciehp* +p'" -chardev socket,id=montest,server=on,wait=off,path=/tmp/mon_test -mon chardev=montest,mode=readline -serial mon:stdio -nographic -full-screen

## 相关操作

在 guest 中触发 kernel suspend

```
echo 8 4 1 7 > /proc/sys/kernel/printk

echo 1 > /sys/power/pm_debug_messages

loglevel=8 i915.nuclear_pageflip=1 swiotlb=131072 dyndbg='file pciehp* +p'

systemctl restart rsyslog

echo mem > /sys/power/state
```

在 qemu monitor 中触发 kernel resume

```
# nc -U /tmp/mon_test
QEMU 6.2.0 monitor - type 'help' for more information
(qemu) system_wakeup
system_wakeup
```

## 结果


guest 本身日志


```
[   38.671957] PM: suspend entry (deep)
[   38.671977] ACPI: PM: acpi_suspend_state_valid 662
[   39.044905] Filesystems sync: 0.372 seconds
[   39.044918] PM: Preparing system for sleep (deep)
[   39.044923] ACPI: PM: acpi_suspend_state_valid 662
[   39.045527] Freezing user space processes
[   39.047035] Freezing user space processes completed (elapsed 0.001 seconds)
[   39.047049] OOM killer disabled.
[   39.047053] Freezing remaining freezable tasks
[   39.048322] Freezing remaining freezable tasks completed (elapsed 0.001 seconds)
[   39.048351] PM: Suspending system (deep)
[   39.048356] ACPI: PM: acpi_suspend_state_valid 662
[   39.048362] ACPI: PM: acpi_suspend_begin 566 1
[   39.048367] ACPI: PM: acpi_suspend_begin 576
[   39.048371] ACPI: PM: acpi_pm_start 522
[   39.048375] ACPI: PM: acpi_sleep_tts_switch 40 3
[   39.048407] printk: Suspending console(s) (use no_console_suspend to debug)
[   39.052935] ------------[ cut here ]------------
[   39.052947] WARNING: CPU: 0 PID: 667 at kernel/workqueue.c:3167 __flush_work.isr0
[   39.052965] Modules linked in: binfmt_misc nls_iso8859_1 intel_rapl_msr intel_ra4
[   39.053118] CPU: 0 PID: 667 Comm: kworker/u4:8 Not tainted 6.3.0-dirty #4
[   39.053125] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-14
[   39.053129] Workqueue: events_unbound async_run_entry_fn
[   39.053140] RIP: 0010:__flush_work.isra.0+0x7c/0x90
[   39.053150] Code: 48 2b 14 25 28 00 00 00 75 26 4c 8b 65 f8 c9 c3 cc cc cc cc 480
[   39.053156] RSP: 0000:ffffaadb40ddbc38 EFLAGS: 00010246
[   39.053162] RAX: 0000000000000001 RBX: 0000000000000000 RCX: ffffffffa7dc7b60
[   39.053167] RDX: 0000000000000001 RSI: 0000000000000001 RDI: ffff907ac3556b30
[   39.053171] RBP: ffffaadb40ddbc98 R08: 0000000000000000 R09: ffff907ac9b88f74
[   39.053174] R10: 000000000000000f R11: 000000000000000f R12: ffff907ac3556b30
[   39.053177] R13: 0000000000000001 R14: ffff907ac2f70000 R15: 0000000000000002
[   39.053181] FS:  0000000000000000(0000) GS:ffff907b3dc00000(0000) knlGS:000000000
[   39.053186] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   39.053191] CR2: 00007fb063930768 CR3: 000000000dc1a001 CR4: 0000000000370ef0
[   39.053202] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   39.053206] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   39.053210] Call Trace:
[   39.053223]  <TASK>
[   39.053226]  ? native_send_call_func_single_ipi+0x1b/0x30
[   39.053248]  ? try_to_grab_pending+0xe8/0x190
[   39.053257]  __cancel_work_timer+0x11d/0x1a0
[   39.053267]  ? _raw_spin_unlock_irq+0xe/0x30
[   39.053274]  ? __wait_for_common+0x15b/0x190
[   39.053280]  ? _raw_spin_unlock_irqrestore+0xe/0x40
[   39.053291]  cancel_delayed_work_sync+0x13/0x20
[   39.053301]  drm_kms_helper_poll_disable+0x33/0x50 [drm_kms_helper]
[   39.053518]  drm_mode_config_helper_suspend+0x21/0x80 [drm_kms_helper]
[   39.053573]  ? __pm_runtime_resume+0x60/0x90
[   39.053582]  bochs_pm_suspend+0x12/0x20 [bochs]
[   39.053605]  pci_pm_suspend+0x87/0x1b0
[   39.053613]  ? __pfx_pci_pm_suspend+0x10/0x10
[   39.053620]  dpm_run_callback+0x51/0x190
[   39.053631]  __device_suspend+0x14c/0x550
[   39.053641]  async_suspend+0x1f/0x80
[   39.053650]  async_run_entry_fn+0x30/0x120
[   39.053658]  process_one_work+0x21c/0x430
[   39.053669]  worker_thread+0x50/0x3e0
[   39.053678]  ? __pfx_worker_thread+0x10/0x10
[   39.053687]  kthread+0xee/0x120
[   39.053692]  ? __pfx_kthread+0x10/0x10
[   39.053699]  ret_from_fork+0x29/0x50
[   39.053715]  </TASK>
[   39.053718] ---[ end trace 0000000000000000 ]---
[   39.069215] sd 0:0:0:0: [sda] Synchronizing SCSI cache
[   39.088687] sd 0:0:0:0: [sda] Stopping disk
[   39.091265] PM: suspend of devices complete after 42.674 msecs
[   39.091277] PM: start suspend of devices complete after 42.863 msecs
[   39.091803] PM: late suspend of devices complete after 0.497 msecs
[   39.095185] PM: noirq suspend of devices complete after 3.036 msecs
[   39.095228] ACPI: PM: acpi_sleep_prepare 78 0x991f0
[   39.095236] ACPI: PM: Preparing to enter system sleep state S3
[   39.095393] ACPI: PM: Saving platform NVS memory
[   39.095425] Disabling non-boot CPUs ...
[   39.098174] smpboot: CPU 1 is now offline
[   39.099593] Checking wakeup interrupts
[   39.099596] Calling kvm_suspend+0x0/0x40 [kvm]
[   39.100325] Calling mce_syscore_suspend+0x0/0x30
[   39.100336] Calling ledtrig_cpu_syscore_suspend+0x0/0x20
[   39.100347] Calling timekeeping_suspend+0x0/0x2e0
[   39.100399] Calling irq_gc_suspend+0x0/0x80
[   39.100414] Calling save_ioapic_entries+0x0/0x160
[   39.101278] Calling i8259A_suspend+0x0/0x30
[   39.101296] Calling fw_suspend+0x0/0x20
[   39.101304] Calling acpi_save_bm_rld+0x0/0x30
[   39.101343] Calling lapic_suspend+0x0/0x220
[   39.101873] Calling kvm_suspend+0x0/0x60
[   39.102037] ACPI Error: !acpi_gbl_reduced_hardware (20221020/hwxfsleep-301)
[   43.626252] ACPI: PM: Low-level resume complete
[   43.626299] ACPI Error: 2    !acpi_gbl_reduced_hardware (20221020/hwxfsleep-333)
[   43.626340] ACPI: PM: Restoring platform NVS memory
[   43.626344] Calling kvm_resume+0x0/0x50
[   43.626360] Calling lapic_resume+0x0/0x2e0
[   43.626470] Calling acpi_restore_bm_rld+0x0/0x60
[   43.626476] Calling irqrouter_resume+0x0/0x50
[   43.626715] Calling i8259A_resume+0x0/0x40
[   43.626845] Calling i8237A_resume+0x0/0xb0
[   43.626960] Calling ioapic_resume+0x0/0x140
[   43.627173] Calling irq_gc_resume+0x0/0x80
[   43.627177] Calling irq_pm_syscore_resume+0x0/0x20
[   43.627193] Calling timekeeping_resume+0x0/0x160
[   43.627236] Timekeeping suspended for 5.214 seconds
[   43.627314] Calling ledtrig_cpu_syscore_resume+0x0/0x20
[   43.627321] Calling mce_syscore_resume+0x0/0x30
[   43.627361] Calling kvm_resume+0x0/0x60 [kvm]
[   43.627494] Enabling non-boot CPUs ...
[   43.627619] x86: Booting SMP configuration:
[   43.627620] smpboot: Booting Node 0 Processor 1 APIC 0x1
[   43.628438] CPU1 is up
[   43.628564] ACPI: PM: Waking up from system sleep state S3
[   43.630229] PM: noirq resume of devices complete after 1.595 msecs
[   43.630323] PM: early resume of devices complete after 0.077 msecs
[   43.630355] pci 0000:00:01.0: PIIX3: Enabling Passive Release
[   43.630443] sd 0:0:0:0: [sda] Starting disk
[   43.788863] ata1: found unknown device (class 0)
[   43.792837] ata2: found unknown device (class 0)
[   43.793043] PM: resume of devices complete after 162.718 msecs
[   43.815034] ACPI: PM: acpi_sleep_tts_switch 40 0
[   43.815071] PM: Finishing wakeup.
[   43.815462] OOM killer enabled.
[   43.815465] Restarting tasks ... done.
[   43.822100] random: crng reseeded on system resumption
[   43.822109] PM: suspend exit
```

`PM: suspend entry (deep)`, `pm_suspend()`, 

`Filesystems sync: 0.001 seconds`, `pm_suspend()` -> `enter_state()` -> `ksys_sync_helper()`, `kernel/power/main.c`

`PM: Preparing system for sleep (deep)`, `pm_suspend()` -> `enter_state()`, `kernel/power/suspend.c`

`Freezing user space processes ... (elapsed 0.001 seconds) done.`, `pm_suspend()` -> `enter_state()` -> `suspend_prepare()` -> `suspend_freeze_processes()` -> `freeze_processes()`, `kernel/power/process.c`

`OOM killer disabled.`,  -> `oom_killer_disable()`, `mm/oom_kill.c`

`Freezing remaining freezable tasks ... (elapsed 0.000 seconds) done.`,  -> `freeze_kernel_threads()`, `kernel/power/process.c`

`PM: Suspending system (deep)`, `pm_suspend()` -> `enter_state()`, `kernel/power/suspend.c`

`printk: Suspending console(s) (use no_console_suspend to debug)`, `suspend_devices_and_enter()` -> `suspend_console()`, `kernel/printk/printk.c`

`e1000e: EEE TX LPI TIMER: 00000011`, `e1000_pm_ops->suspend`, `e1000e_pm_suspend()` -> `e1000e_flush_lpic()`, `drivers/net/ethernet/intel/e1000e/netdev.c`

`ACPI: EC: interrupt blocked`, `SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(acpi_ec_suspend_noirq, acpi_ec_resume_noirq)`, `acpi_ec_suspend_noirq()` -> `acpi_ec_enter_noirq()`, `drivers/acpi/ec.c`

`ACPI: PM: Preparing to enter system sleep state S3`, `acpi_sleep_prepare()`, 其中会调用 `acpi_set_waking_vector(acpi_wakeup_address);`, 设置 waking vector

qemu monitor 触发 system_wakeup, guest 那边 OVMF 日志:

```
SecCoreStartupWithStack(0xFFFCC000, 0x820000)
SecCoreStartupWithStack(0xFFFCC000, 0x820000)
Register PPI Notify: DCD0BE23-9586-40F4-B643-06522CED4EDE
Install PPI: 8C8CE578-8A3D-4F1C-9935-896185C32DD3
Install PPI: 5473C07A-3DCB-4DCA-BD6F-1E9689E7349A
The 0th FV start address is 0x00000820000, size is 0x000E0000, handle is 0x820000
Register PPI Notify: 49EDB1C1-BF21-4761-BB12-EB0031AABB39
Register PPI Notify: EA7CA24B-DED5-4DAD-A389-BF827E8F9B38
Install PPI: B9E0ABFE-5979-4914-977F-6DEE78C278A6
Install PPI: DBE23AA9-A345-4B97-85B6-B226F1617389
Install PPI: 138F9CF4-F0E7-4721-8F49-F5FFECF42D40
DiscoverPeimsAndOrderWithApriori(): Found 0x8 PEI FFS files in the 0th FV
Loading PEIM 9B3ADA4F-AE56-4C24-8DEA-F03B7558AE50
Loading PEIM at 0x0000082BF40 EntryPoint=0x0000082F2CE PcdPeim.efi
Install PPI: 06E81C58-4AD7-44BC-8390-F10265F72480
Install PPI: 01F34D25-4DE2-23AD-3FF3-36353FF323F1
Install PPI: 4D8B155B-C059-4C8F-8926-06FD4331DB8A
Install PPI: A60C6B59-E459-425D-9C69-0BCC9CB27D81
Register PPI Notify: 605EA650-C65C-42E1-BA80-91A52AB618C6
Loading PEIM A3610442-E69F-4DF3-82CA-2360C4031A23
Loading PEIM at 0x00000830EC0 EntryPoint=0x00000832377 ReportStatusCodeRouterPei.efi
Install PPI: 0065D394-9951-4144-82A3-0AFC8579C251
Install PPI: 229832D3-7A30-4B36-B827-F40CB7D45436
Loading PEIM 9D225237-FA01-464C-A949-BAABC02D31D0
Loading PEIM at 0x00000833040 EntryPoint=0x000008343E6 StatusCodeHandlerPei.efi
Loading PEIM 222C386D-5ABC-4FB4-B124-FBB82488ACF4
Loading PEIM at 0x000008351C0 EntryPoint=0x0000083CE9E PlatformPei.efi
Platform PEIM Loaded
CMOS:
00: 00 00 03 00 09 00 05 29 06 23 26 02 00 80 00 FE
10: 50 00 00 00 07 80 02 FF FF 00 00 00 00 00 00 00
20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
30: FF FF 20 00 00 7F 00 20 30 00 00 00 00 12 00 00
40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01
60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
QemuFwCfgProbe: Supported 1, DMA 1
Select Item: 0x19
Select Item: 0x29
S3 support was detected on QEMU
BootModeInitialization
2 BootModeInitialization
Install PPI: 7408D748-FC8C-4EE6-9288-C4BEC092A410
Select Item: 0x19
Select Item: 0x19
Select Item: 0x25
Select Item: 0x19
Select Item: 0x19
PlatformAddressWidthFromCpuid: Signature: 'GenuineIntel', PhysBits: 39, QemuQuirk: On, Valid: Yes
PlatformDynamicMmioWindow: using dynamic mmio window
PlatformDynamicMmioWindow:   Addr Space 0x8000000000 (512 GB)
PlatformDynamicMmioWindow:   MMIO Space 0x1000000000 (64 GB)
Select Item: 0x19
Select Item: 0x25
PlatformDynamicMmioWindow:   Pci64 Base 0x7000000000
PlatformDynamicMmioWindow:   Pci64 Size 0x1000000000
Select Item: 0x5
PlatformMaxCpuCountInitialization: BootCpuCount=2 MaxCpuCount=2
Select Item: 0x19
Select Item: 0x25
PlatformGetLowMemoryCB: LowMemory=0x80000000
PeiInstallPeiMemory MemoryBegin 0x7FF70000, MemoryLength 0x90000
Select Item: 0x19
Select Item: 0x25
PlatformQemuInitializeRam called
Select Item: 0x19
Select Item: 0x25
Register PPI Notify: EE16160A-E8BE-47A6-820A-C6900DB0250A
Select Item: 0x19
Select Item: 0x26
Register PPI Notify: EE16160A-E8BE-47A6-820A-C6900DB0250A
Temp Stack : BaseAddress=0x818000 Length=0x8000
Temp Heap  : BaseAddress=0x810000 Length=0x8000
Total temporary memory:    65536 bytes.
  temporary memory stack ever used:       29960 bytes.
  temporary memory heap used for HobList: 6128 bytes.
  temporary memory heap occupied by memory pages: 0 bytes.
Old Stack size 32768, New stack size 131072
Stack Hob: BaseAddress=0x7FF70000 Length=0x20000
Heap Offset = 0x7F780000 Stack Offset = 0x7F770000
TemporaryRamMigration(0x810000, 0x7FF88000, 0x10000)
Reinstall PPI: 8C8CE578-8A3D-4F1C-9935-896185C32DD3
Reinstall PPI: 5473C07A-3DCB-4DCA-BD6F-1E9689E7349A
Reinstall PPI: B9E0ABFE-5979-4914-977F-6DEE78C278A6
Install PPI: F894643D-C449-42D1-8EA8-85BDD8C65BDE
Loading PEIM 86D70125-BAA3-4296-A62F-602BEBBB9081
Loading PEIM at 0x00000842640 EntryPoint=0x00000845B05 DxeIpl.efi
Register PPI Notify: F894643D-C449-42D1-8EA8-85BDD8C65BDE
Install PPI: 0AE8CE5D-E448-4437-A8D7-EBF5F194F731
Notify: PPI Guid: F894643D-C449-42D1-8EA8-85BDD8C65BDE, Peim notify entry point: 843FD6
Install PPI: 1A36E4E7-FAB6-476A-8E75-695A0576FDD7
Loading PEIM 89E549B0-7CFE-449D-9BA3-10D8B2312D71
Loading PEIM at 0x000008472C0 EntryPoint=0x00000849E18 S3Resume2Pei.efi
Install PPI: 6D582DBC-DB85-4514-8FCC-5ADF6227B147
Loading PEIM EDADEB9D-DDBA-48BD-9D22-C1C169C8C5C6
Loading PEIM at 0x0000084BC40 EntryPoint=0x00000851787 CpuMpPei.efi
Register PPI Notify: F894643D-C449-42D1-8EA8-85BDD8C65BDE
Notify: PPI Guid: F894643D-C449-42D1-8EA8-85BDD8C65BDE, Peim notify entry point: 85499C
AP Loop Mode is 1
AP Vector: non-16-bit = 7FFE6000/447
WakeupBufferStart = 9F000, WakeupBufferSize = 1000
AP Vector: 16-bit = 9F000/39, ExchangeInfo = 9F039/A4
CpuMpPei: 5-Level Paging = 0
APIC MODE is 1
MpInitLib: Find 2 processors in system.
GetMicrocodePatchInfoFromHob: Microcode patch cache HOB is not found.
CpuMpPei: 5-Level Paging = 0
CPU[0000]: Microcode revision = 00000000, expected = 00000000
CPU[0001]: Microcode revision = 00000000, expected = 00000000
Register PPI Notify: 8F9D4825-797D-48FC-8471-845025792EF6
Does not find any stored CPU BIST information from PPI!
  APICID - 0x00000000, BIST - 0x00000000
  APICID - 0x00000001, BIST - 0x00000000
Install PPI: 9E9F374B-8F16-4230-9824-5846EE766A97
Install PPI: 5CB9CB3D-31A4-480C-9498-29D269BACFBA
Install PPI: EE16160A-E8BE-47A6-820A-C6900DB0250A
Notify: PPI Guid: EE16160A-E8BE-47A6-820A-C6900DB0250A, Peim notify entry point: 8372F1
PlatformPei: ClearCacheOnMpServicesAvailable
CpuMpPei: 5-Level Paging = 0
Notify: PPI Guid: EE16160A-E8BE-47A6-820A-C6900DB0250A, Peim notify entry point: 838B44
CpuMpPei: 5-Level Paging = 0

DXE IPL Entry

Enter S3 PEIM
AcpiS3Context = 7FB65000
Waking Vector = 9A1F0
AcpiS3Context->AcpiFacsTable = 7FBDD000
AcpiS3Context->IdtrProfile = 7FB64000
AcpiS3Context->S3NvsPageTableAddress = 7FB59000
AcpiS3Context->S3DebugBufferAddress = 7FB50000
AcpiS3Context->BootScriptStackBase = 7FB51000
AcpiS3Context->BootScriptStackSize = 8000
EfiBootScriptExecutorVariable->BootScriptExecutorEntrypoint = 7FB3B49F
S3NvsPageTableAddress - 7FB59000 (1)

S3ResumeExecuteBootScript()
PeiS3ResumeState - 7FF92908
transfer control to Standalone Boot Script Executor

S3BootScriptExecutorEntryFunction
S3BootScriptExecute:
TableHeader - 0x7FB4C000
TableHeader.Version - 0x0001
TableHeader.TableLength - 0x0000001B
ExecuteBootScript - 7FB4C00D
EFI_BOOT_SCRIPT_INFORMATION_OPCODE
BootScriptExecuteInformation - 0x7FB4C014
BootScriptInformation: DE AD BE EF
ExecuteBootScript - 7FB4C018
S3_BOOT_SCRIPT_LIB_TERMINATE_OPCODE
S3BootScriptDone - Success
Call SwitchStack() to return to S3 Resume in PEI Phase

S3ResumeBootOs
Install PPI: 88C9D306-0900-4EB5-8260-3E2DBEDA1F89
Install PPI: 605EA650-C65C-42E1-BA80-91A52AB618C6
Notify: PPI Guid: 605EA650-C65C-42E1-BA80-91A52AB618C6, Peim notify entry point: 82DE4F
Signal EndOfS3Resume
Signal 96F5296D-05F7-4F3C-8467-E456890E0CB5 to SMM - Enter
Locate Smm Communicate Ppi failed (Not Found)!
Transfer to 16bit OS waking vector - 9A1F0
```

# 流程总结


```cpp
state_store() // 入口
 ├─ pm_autosleep_lock() // autosleep 锁
 ├─ decode_state() // 解析状态
 └─ pm_suspend() // 进入流程
     ├─ pr_info("suspend entry (%s)\n", mem_sleep_labels[state]); // PM: suspend entry (deep)
     ├─ enter_state(); //
     |   ├─ trace_suspend_resume(TPS("suspend_enter"), state, true); // trace point
     |   ├─ if valid_state() // 检查平台是否支持, 会调用平台相关的 valid 函数, 对应的是 acpi_suspend_state_valid
     |   |   └─ return sleep_states[acpi_suspend_states[pm_state]];
     |   ├─ mutex_trylock(); // 拿锁
     |   ├─ trace_suspend_resume(TPS("sync_filesystems"), 0, true); // 文件系统 trace point
     |   ├─ ksys_sync_helper(); // 文件系统 sync, 其中会打印 Filesystems sync: 0.444 seconds
     |   ├─ trace_suspend_resume(TPS("sync_filesystems"), 0, false); // 文件系统 trace point
     |   ├─ pm_pr_dbg("Preparing system for sleep (%s)\n", mem_sleep_labels[state]); // debug log, PM: Preparing system for sleep (deep)
     |   ├─ pm_suspend_clear_flags(); // 
     |   ├─ suspend_prepare(state); //
     |   |   ├─ pm_prepare_console(); // 切换控制台
     |   |   ├─ pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND); // 发送 PM_SUSPEND_PREPARE 消息
     |   |   ├─ trace_suspend_resume(TPS("freeze_processes"), 0, true); // trace point
     |   |   ├─ suspend_freeze_processes(); // 冻结用户进程以及内核线程
     |   |   |   ├─ freeze_processes(); 
     |   |   |       ├─ 
     |   |   ├─ trace_suspend_resume(TPS("freeze_processes"), 0, false); // trace point
     |   |   ├─ // 下面两个调用是失败了调用
     |   |   ├─ pm_notifier_call_chain(PM_POST_SUSPEND); // 通知
     |   |   └─ pm_restore_console(); // 恢复控制台
     |   ├─ if (suspend_test(TEST_FREEZER)) // 如果是 freezer, 则到下面的 Finishing log, 不需要做设备和系统的 suspend
     |   ├─ trace_suspend_resume(TPS("suspend_enter"), state, false); // trace point
     |   ├─ pm_pr_dbg("Suspending system (%s)\n", mem_sleep_labels[state]); // debug log, PM: Suspending system (deep)
     |   ├─ suspend_devices_and_enter(); // 设备和系统的 suspend
     |   |   ├─ if (!sleep_state_supported(state)) // 判断平台是否实现了 suspend_ops 以及 suspend_ops->enter 函数
     |   |   ├─ platform_suspend_begin(state); // 调用 suspend_ops->begin(), acpi 对应的是 acpi_suspend_begin
     |   |   |   ├─ pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_SUSPEND;
     |   |   |   └─ acpi_pm_start(); //
     |   |   |       ├─ acpi_target_sleep_state = acpi_state; // 静态变量, 初始化为 S0, 这里设置为 S3
     |   |   |       ├─ acpi_sleep_tts_switch(acpi_target_sleep_state);
     |   |   |       |   └─ acpi_execute_simple_method(NULL, "\\_TTS", acpi_state); // 执行 _TTS 方法, 遵循 spec 第二步
     |   |   |       └─ acpi_scan_lock_acquire(); // 获取锁
     |   |   ├─ suspend_console(); // 挂起控制台, 打印 printk: Suspending console(s) (use no_console_suspend to debug)
     |   |   ├─ dpm_suspend_start(PMSG_SUSPEND); // 设备 suspend
     |   |   |   ├─ starttime = ktime_get(); // 获取时间
     |   |   |   ├─ dpm_prepare(state); // 执行所有设备的 prepare 回调函数.
     |   |   |   |   ├─ trace_suspend_resume(TPS("dpm_prepare"), state.event, true); // trace point
     |   |   |   |   ├─ while (!list_empty(&dpm_list) && !error) // 遍历所有设备
     |   |   |   |   |   ├─ trace_device_pm_callback_start(dev, "", state.event); // trace point
     |   |   |   |   |   ├─ device_prepare(dev, state); // prepare 函数
     |   |   |   |   |   |   ├─ pm_runtime_get_noresume(dev); // 关闭 Runtime suspend 功能, complete 时被重新打开
     |   |   |   |   |   |   |   ├─ sd_suspend_runtime(); // drivers/scsi/sd.c, 打印 sd 0:0:0:0: [sda] Stopping disk
     |   |   |   |   |   |   ├─ if (dev->power.syscore) // 是 syscore 设备就返回, 会专门处理
     |   |   |   |   |   |   ├─ ->prepare(dev); // 根据优先顺序进行调用
     |   |   |   |   |   |   └─ 
     |   |   |   |   |   ├─ trace_device_pm_callback_end(dev, error); // trace point
     |   |   |   |   |   ├─ dev->power.is_prepared = true; // 设置已经 prepared
     |   |   |   |   |   └─ list_move_tail(&dev->power.entry, &dpm_prepared_list); // 添加到 dpm_prepared_list 链表
     |   |   |   |   └─ trace_suspend_resume(TPS("dpm_prepare"), state.event, false); // trace point
     |   |   |   ├─ dpm_suspend(); // 执行所有设备的 suspend 回调函数
     |   |   |   |   ├─ trace_suspend_resume(TPS("dpm_suspend"), state.event, true); // trace point
     |   |   |   |   ├─ while (!list_empty(&dpm_list) && !error) // 遍历所有设备
     |   |   |   |   |   ├─ device_suspend(dev); // 调用 __device_suspend, 同样按照优先顺序进行调用

     |   |   |   |   |   └─ list_move(&dev->power.entry, &dpm_suspended_list); // 添加到 dpm_suspended_list 链表
     |   |   |   |   ├─ dpm_show_time(starttime, state, error, NULL); // 会打印 PM: suspend of devices complete after XXX msecs
     |   |   |   |   └─ trace_suspend_resume(TPS("dpm_suspend"), state.event, false); // trace point
     |   |   |   └─ dpm_show_time(starttime, state, error, "start"); // 会打印 PM: start suspend of devices complete after XXX msecs
     |   |   ├─ suspend_test_finish("suspend devices");
     |   |   ├─ suspend_enter(state, &wakeup); // 系统进入 suspend
     |   |   |   ├─ platform_suspend_prepare(); // 调用平台相关 prepare 回调函数, suspend_ops->prepare(), acpi 没有对应函数
     |   |   |   ├─ dpm_suspend_late(); // 调用所有设备的 suspend_late 回调, 并加入一个链表, 打印 PM: late suspend of devices complete after
     |   |   |   ├─ platform_suspend_prepare_late(); // freeze(S2) 则调用 freeze_ops 中的 prepare 回调
     |   |   |   ├─ dpm_suspend_noirq(PMSG_SUSPEND); // disable 所有设备的 irq, 
     |   |   |   ├─ platform_suspend_prepare_noirq(state); // 回调 suspend_ops->prepare_late(), acpi 对应是 acpi_pm_prepare()
     |   |   |   |   ├─ __acpi_pm_prepare(); // 平台准备进入 S3 并且 disable GPEs
     |   |   |   |   |   └─ acpi_sleep_prepare(acpi_target_sleep_state); //
     |   |   |   |   |       ├─ acpi_wakeup_address = acpi_get_wakeup_address(); // 0x991f0
     |   |   |   |   |       |   └─ return ((unsigned long)(real_mode_header->wakeup_start)); // 定义在 arch/x86/realmode/rm/wakeup_asm.S 中
     |   |   |   |   |       ├─ acpi_set_waking_vector(acpi_wakeup_address); // 写 waking vector 到 FACS 表, spec 第七步
     |   |   |   |   |       ├─ pr_info("Preparing to enter system sleep state S%d\n", acpi_state); // 打印 ACPI: PM: Preparing to enter system sleep state S3
     |   |   |   |   |       ├─ acpi_enable_wakeup_devices(acpi_state); // 使能可唤醒设备的 GPEs 寄存器
     |   |   |   |   |       |   └─ list_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list, wakeup_list) // 遍历 acpi_wakeup_device_list 链表(所有可唤醒设备, 初始化时候构建, 涉及 _PRW, drivers/acpi/scan.c, 遵循 spec 第三步)
     |   |   |   |   |       |       ├─ if (device_may_wakeup(&dev->dev)) // 判断当前设备是否具有唤醒系统的功能(是否有 wakeup source 以及是否允许 wakeup), 遵循 spec 第三步. 如果是, 就调用下面函数
     |   |   |   |   |       |       |   └─ acpi_enable_wakeup_device_power(dev, sleep_state); // 准备一个可唤醒的设备, 按照 spec 规定, 涉及两步
     |   |   |   |   |       |       |       ├─ dev_dbg(&dev->dev, "Enabling wakeup power (count %d)\n", dev->wakeup.prepare_count); // debug log
     |   |   |   |   |       |       |       ├─ acpi_power_on_list(&dev->wakeup.resources); // 打开 wakeup power resource
     |   |   |   |   |       |       |       ├─ acpi_device_sleep_wake(dev, 1, sleep_state, 3); // 为设备执行 _DSW(Device Sleep Wake) 或者 _PSW(Power State Wake, ACPI 3.0 弃用)
     |   |   |   |   |       |       |       ├─ 
     |   |   |   |   |       |       |       └─ dev_dbg(&dev->dev, "Wakeup power enabled\n"); // debug log
     |   |   |   |   |       |       └─ acpi_set_gpe_wake_mask(); // 设置 GPE wakeup bit
     |   |   |   |   |       └─ acpi_enter_sleep_state_prep(acpi_state); // 准备进入
     |   |   |   |   |           ├─ ACPI_FUNCTION_TRACE(acpi_enter_sleep_state_prep); // trace point
     |   |   |   |   |           ├─ 
     |   |   |   |   |           ├─ acpi_evaluate_object(NULL, METHOD_PATHNAME__PTS, &arg_list, NULL); // 执行 _PTS 方法, 遵循 spec 第五步
     |   |   |   |   |           └─ acpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, sst_value); // 执行 _SST 方法
     |   |   |   |   └─ acpi_pm_pre_suspend(); // 使能 wakeup 设备
     |   |   |   |       ├─ acpi_pm_freeze(); // disable 所有 GPEs 和 suspend EC transactions
     |   |   |   |       |   ├─ acpi_disable_all_gpes(); // disable 所有的 gpe
     |   |   |   |       |   ├─ acpi_os_wait_events_complete();
     |   |   |   |       |   └─ acpi_ec_block_transactions();
     |   |   |   |       └─ suspend_nvs_save(); // 保存 NVS memory region
     |   |   |   |           ├─ pr_info("Saving platform NVS memory\n"); // 打印 ACPI: PM: Saving platform NVS memory
     |   |   |   |           └─ list_for_each_entry(entry, &nvs_list, node) // 遍历 nvs
     |   |   |   ├─ pm_sleep_disable_secondary_cpus(); // disable 所有 nonboot 的 CPU
     |   |   |   ├─ arch_suspend_disable_irqs(); // 关闭全局中断
     |   |   |   ├─ system_state = SYSTEM_SUSPEND; // 设置 suspend 状态
     |   |   |   ├─ syscore_suspend(); // system core 的 suspend 回调函数
     |   |   |   ├─ suspend_ops->enter(); // 对应的是 acpi_suspend_enter
     |   |   |   |   ├─ trace_suspend_resume(TPS("acpi_suspend"), acpi_state, true); // trace point
     |   |   |   |   ├─ acpi_suspend_lowlevel(); // x86 对应的是 x86_acpi_suspend_lowlevel, 保存 kernel 状态, 会创建页表并拷贝 wakeup 例程到 low memory
     |   |   |   |   |   ├─ struct wakeup_header *header = (struct wakeup_header *) __va(real_mode_header->wakeup_header); // 实模式的 wakup_header
     |   |   |   |   |   ├─ header->pmode_cr4 = __read_cr4();
     |   |   |   |   |   ├─ ...
     |   |   |   |   |   ├─ header->realmode_flags = acpi_realmode_flags;
     |   |   |   |   |   ├─ header->real_magic = 0x12345678;
     |   |   |   |   |   ├─ current->thread.sp = (unsigned long)temp_stack + sizeof(temp_stack); // cpu 自己的 stack pointer
     |   |   |   |   |   ├─ initial_code = (unsigned long)wakeup_long64;
     |   |   |   |   |   ├─ saved_magic = 0x123456789abcdef0L;
     |   |   |   |   |   ├─ pause_graph_tracing();
     |   |   |   |   |   ├─ do_suspend_lowlevel(); // 对应汇编代码, 保存 CPU 上下文, 对应 spec 第九步
     |   |   |   |   |   |   ├─ subq $8, %rsp // 栈顶减去 8 字节, 在栈上分配了 8 字节空间
     |   |   |   |   |   |   ├─ call save_processor_state // 会保存当前 cpu 上下文到 saved_context
     |   |   |   |   |   |   ├─ movq $saved_context, %rax // 保存 saved_context 值到 rax 寄存器值
     |   |   |   |   |   |   ├─ movq %rsp, pt_regs_sp(%rax) // 保存 rsp 寄存器值到 saved_context 中
     |   |   |   |   |   |   ├─ ...
     |   |   |   |   |   |   ├─ movq %r15, pt_regs_r15(%rax) // 保存 r15 寄存器到 saved_context 中
     |   |   |   |   |   |   ├─ pushfq // 将 RFLAGS 压栈
     |   |   |   |   |   |   ├─ popq pt_regs_flags(%rax) // 将 RFLAGS 出栈并保存到 saved_context 中
     |   |   |   |   |   |   ├─ movq $.Lresume_point, saved_rip(%rip) // 将 .Lresume_point 保存到 rip, 恢复会从 Lresume_point 开始
     |   |   |   |   |   |   ├─ movq %rsp, saved_rsp // 保存 rsp 寄存器为 saved_rsp
     |   |   |   |   |   |   ├─ addq $8, %rsp // 恢复栈顶
     |   |   |   |   |   |   ├─ call x86_acpi_enter_sleep_state // 调用 acpi_enter_sleep_state(state);
     |   |   |   |   |   |   |   └─ acpi_hw_legacy_sleep(); // 对于非 HW-reduced
     |   |   |   |   |   |   |       ├─ ACPI_FUNCTION_TRACE(hw_legacy_sleep);
     |   |   |   |   |   |   |       ├─ acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);; // 清理 WAK_STS, 遵循 spec 第八步
     |   |   |   |   |   |   |       ├─ acpi_hw_disable_all_gpes(); // disable 所有 GPEs
     |   |   |   |   |   |   |       ├─ acpi_hw_clear_acpi_status(); // 
     |   |   |   |   |   |   |       ├─ acpi_hw_enable_all_wakeup_gpes(); // 启用所有的 wakeup GPEs, 遵循 spec 第十一步
     |   |   |   |   |   |   |       ├─ acpi_hw_register_read(ACPI_REGISTER_PM1_CONTROL, &pm1a_control); // 获取当前 PM1A control 的值
     |   |   |   |   |   |   |       ├─ ACPI_DEBUG_PRINT((ACPI_DB_INIT, "Entering sleep state [S%u]\n", sleep_state)); // debug log, 打印
     |   |   |   |   |   |   |       ├─ pm1a_control &= ~(sleep_type_reg_info->access_bit_mask | sleep_enable_reg_info->access_bit_mask); // 清理 SLP_EN 和 SLP_TYP 字段
     |   |   |   |   |   |   |       ├─ pm1b_control = pm1a_control;
     |   |   |   |   |   |   |       ├─ pm1a_control |= (acpi_gbl_sleep_type_a << sleep_type_reg_info->bit_position); // 插入 SLP_TYP bits
     |   |   |   |   |   |   |       ├─ pm1b_control |= (acpi_gbl_sleep_type_b << sleep_type_reg_info->bit_position); // 插入 SLP_TYP bits
     |   |   |   |   |   |   |       ├─ acpi_hw_write_pm1_control(pm1a_control, pm1b_control); // 写 SLP_TYP 字段到 PM1 Control 寄存器,  遵循 spec 第十三和十四步
     |   |   |   |   |   |   |       ├─ pm1a_control |= sleep_enable_reg_info->access_bit_mask;
     |   |   |   |   |   |   |       ├─ pm1b_control |= sleep_enable_reg_info->access_bit_mask;
     |   |   |   |   |   |   |       ├─ ACPI_FLUSH_CPU_CACHE(); // 刷新 cache, 遵循 spec 第十步
     |   |   |   |   |   |   |       ├─ acpi_os_enter_sleep(sleep_state, pm1a_control, pm1b_control); // 
     |   |   |   |   |   |   |       |   ├─ acpi_os_prepare_sleep() 对于非 HW-reduced

     |   |   |   |   |   |   |       |   └─ acpi_os_prepare_extended_sleep() 对于 HW-reduced
     |   |   |   |   |   |   |       ├─ acpi_hw_write_pm1_control(pm1a_control, pm1b_control); // 写 SLP_TYP 和 SLP_EN, 遵循 spec 第十三和十四步
     |   |   |   |   |   |   |       └─ do{ }while(!in_value) // 一直循环直到 WAK_STS 是 1; 当系统处于睡眠状态并发生启用唤醒事件时，将设置此位。设置此位后，系统将过渡到工作状态。此位由硬件设置，只能通过软件在此位位置写入“1”来清除。对应 spec 第十六步
     |   |   |   |   |   |   |           └─ acpi_read_bit_register(ACPI_BITREG_WAKE_STATUS, &in_value); // 读取 Sleep Status Register
     |   |   |   |   |   |   |   └─ acpi_hw_extended_sleep(); // 对于 HW-reduced, ARM 平台
     |   |   |   |   |   |   |       ├─ ACPI_FUNCTION_TRACE(hw_extended_sleep); // trace point
     |   |   |   |   |   |   |       ├─ acpi_write((u64)ACPI_X_WAKE_STATUS, &acpi_gbl_FADT.sleep_status); // 清理 WAK_STS, 遵循 spec 第八步
     |   |   |   |   |   |   |       ├─ ACPI_DEBUG_PRINT((ACPI_DB_INIT, "Entering sleep state [S%u]\n", sleep_state)); // debug log, 打印
     |   |   |   |   |   |   |       ├─ sleep_control = ((acpi_gbl_sleep_type_a << ACPI_X_SLEEP_TYPE_POSITION) & ACPI_X_SLEEP_TYPE_MASK) | ACPI_X_SLEEP_ENABLE; // 设置 SLP_TYP 和 SLP_EN
     |   |   |   |   |   |   |       ├─ ACPI_FLUSH_CPU_CACHE(); // 刷新 cache, 遵循 spec 第十步
     |   |   |   |   |   |   |       ├─ acpi_os_enter_sleep(sleep_state, sleep_control, 0); // 遵循 spec 第十五步?
     |   |   |   |   |   |   |       ├─ acpi_write((u64)sleep_control, &acpi_gbl_FADT.sleep_control); // 设置 SLP_TYP 和 SLP_EN, 遵循 spec 第十三和十四步
     |   |   |   |   |   |   |       └─ do{ }while(!(((u8)sleep_status) & ACPI_X_WAKE_STATUS)) // 一直循环直到 WAK_STS 是 1; 当系统处于睡眠状态并发生启用唤醒事件时，将设置此位。设置此位后，系统将过渡到工作状态。此位由硬件设置，只能通过软件在此位位置写入“1”来清除。对应 spec 第十六步
     |   |   |   |   |   |   |           └─ acpi_read(&sleep_status, &acpi_gbl_FADT.sleep_status); // 读取 Sleep Status Register
     |   |   |   |   |   |   └─ jmp	.Lresume_point // 后面全都是 resume 流程了
     |   |   |   |   |   |       ├─ movq $saved_context, %rax // 保存 saved_context 值到 rax 寄存器值
     |   |   |   |   |   |       ├─ movq saved_context_cr3(%rax), %rbx
     |   |   |   |   |   |       ├─ movq %rbx, %cr3 // 恢复 cr3 寄存器
     |   |   |   |   |   |       ├─ pushq pt_regs_flags(%rax) // 
     |   |   |   |   |   |       ├─ 
     |   |   |   |   |   |       └─ jmp restore_processor_state // 恢复 cpu 上下文
     |   |   |   |   |   └─ unpause_graph_tracing(); // 
     |   |   |   |   ├─ pr_info("Low-level resume complete\n"); // 打印 ACPI: PM: Low-level resume complete
     |   |   |   |   ├─ pm_set_resume_via_firmware(); // 
     |   |   |   |   |   └─ pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_RESUME;
     |   |   |   |   ├─ trace_suspend_resume(TPS("acpi_suspend"), acpi_state, false); // trace point
     |   |   |   |   ├─ acpi_leave_sleep_state_prep(acpi_state); // 
     |   |   |   |   |   ├─ ACPI_FUNCTION_TRACE(hw_extended_wake_prep);
     |   |   |   |   |   ├─ 
     |   |   |   |   |   ├─ 
     |   |   |   |   ├─ acpi_clear_event(ACPI_EVENT_POWER_BUTTON); // OSPM 清理 POWER_BUTTON
     |   |   |   |   ├─ acpi_disable_all_gpes(); // disable 所有的 gpe
     |   |   |   |   ├─ acpi_ec_unblock_transactions(); // 
     |   |   |   |   └─ suspend_nvs_restore(); // 打印 ACPI: PM: Restoring platform NVS memory
     |   |   |   ├─ syscore_resume(); // system core 的 resume
     |   |   |   ├─ system_state = SYSTEM_RUNNING; // 设置 running 状态
     |   |   |   ├─ arch_suspend_enable_irqs(); // 打开 irq
     |   |   |   ├─ pm_sleep_enable_secondary_cpus(); // up non-boot CPU
     |   |   |   ├─ platform_resume_noirq(); // 平台 resume, 调用 suspend_ops->wake(), acpi 对应是 acpi_pm_finish
     |   |   |   |   ├─ pr_info("Waking up from system sleep state S%d\n", acpi_state); // 打印 ACPI: PM: Waking up from system sleep state S3
     |   |   |   |   ├─ acpi_disable_wakeup_devices(acpi_state); // 
     |   |   |   |   ├─ acpi_leave_sleep_state(acpi_state);
     |   |   |   |   |   ├─ ACPI_FUNCTION_TRACE(acpi_leave_sleep_state); // trace point
     |   |   |   |   |   ├─ acpi_hw_legacy_wake(sleep_state); // 非 HW-reduced
     |   |   |   |   |   |   ├─ ACPI_FUNCTION_TRACE(hw_legacy_wake);
     |   |   |   |   |   |   ├─ acpi_hw_disable_all_gpes(); // disable 所有 GPEs
     |   |   |   |   |   |   ├─ acpi_hw_enable_all_runtime_gpes(); // enable 所有 runtime GPEs
     |   |   |   |   |   |   ├─ acpi_hw_execute_sleep_method(METHOD_PATHNAME__WAK, sleep_state); // 执行 _WAK 方法
     |   |   |   |   |   |   ├─ 
     |   |   |   |   |   |   ├─ 
     |   |   |   |   |   |   ├─ 
     |   |   |   |   |   |   └─ acpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, ACPI_SST_WORKING); // 执行 _SST 方法
     |   |   |   |   |   └─ acpi_hw_extended_wake(sleep_state); // HW-reduced
     |   |   |   |   ├─ acpi_set_waking_vector(0); // reset waking vector
     |   |   |   |   ├─ acpi_target_sleep_state = ACPI_STATE_S0; // acpi sleep 状态设成 S0
     |   |   |   |   ├─ acpi_resume_power_resources(); //
     |   |   |   |   ├─ 
     |   |   |   ├─ dpm_resume_noirq(); // 设备 resume
     |   |   |   ├─ platform_resume_early();
     |   |   |   ├─ dpm_resume_early();
     |   |   |   └─ platform_resume_finish(); // 调用 suspend_ops->finish(), acpi 没有对应方法 
     |   |   |       ├─ 
     |   |   |       ├─ 
     |   |   |       ├─ 
     |   |   ├─ dpm_resume_end(PMSG_RESUME); // 设备 resume
     |   |   ├─ suspend_test_finish("resume devices"); // 
     |   |   ├─ trace_suspend_resume(TPS("resume_console"), state, true); // resume 的 trace point
     |   |   ├─ resume_console(); // console resume
     |   |   ├─ trace_suspend_resume(TPS("resume_console"), state, false); // resume 的 trace point
     |   |   ├─ platform_resume_end(state); // 平台 resume, suspend_ops->end(), 对应的是 acpi_pm_end()
     |   |   |   ├─ acpi_turn_off_unused_power_resources(); // 
     |   |   |   ├─ acpi_scan_lock_release();
     |   |   |   ├─ acpi_target_sleep_state = ACPI_STATE_S0; // S0 状态
     |   |   |   └─  acpi_sleep_tts_switch(acpi_target_sleep_state); // 调用 _TTS(0)
     |   |   └─ pm_suspend_target_state = PM_SUSPEND_ON; // 设置状态
     |   ├─ pm_pr_dbg("Finishing wakeup.\n"); // debug log, 已经 wakeup, PM: Finishing wakeup.
     |   └─ suspend_finish();
     └─ pr_info("suspend exit\n"); // PM: suspend exit
```

# 1. suspend 代码入口

执行如下命令:

```
echo mem > /sys/power/state
```

根据 sys 节点的属性命令规则, 可以得到此节点的实现代码为:  `state_store`

## 1.1. state_store 函数分析

```cpp
// kernel/power/power.h
#define power_attr(_name) \
static struct kobj_attribute _name##_attr = {   \
    .attr   = {                             \
        .name = __stringify(_name),         \
        .mode = 0644,                       \
    },                                      \
    .show   = _name##_show,                 \
    .store  = _name##_store,                \
}

// kernel/power/main.c
static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
                           const char *buf, size_t n)
{
    suspend_state_t state;
    int error;
    // 第一
    error = pm_autosleep_lock();
    if (error)
        return error;
    // 第二
    if (pm_autosleep_state() > PM_SUSPEND_ON) {
        error = -EBUSY;
        goto out;
    }
    // 第三
    state = decode_state(buf, n);
    if (state < PM_SUSPEND_MAX) {
        if (state == PM_SUSPEND_MEM)
                state = mem_sleep_current;

        error = pm_suspend(state);
    } else if (state == PM_SUSPEND_MAX) {
        error = hibernate();
    } else {
        error = -EINVAL;
    }
    ...
}

power_attr(state);
```

第一. `pm_autosleep_lock`

```cpp
// kernel/power/autosleep.c
int pm_autosleep_lock(void)
{
    return mutex_lock_interruptible(&autosleep_lock);
}
```

获得 autosleep 锁, **锁住 autosleep 功能**, 此功能在后面分析

第二. 判断**当前 autosleep 的状态**, 如果当前状态大于 `PM_SUSPEND_ON`, 则返回退出. 关于 suspend 的状态如下: 

```cpp
// include/linux/suspend.h
#define PM_SUSPEND_ON           ((__force suspend_state_t) 0)
#define PM_SUSPEND_TO_IDLE      ((__force suspend_state_t) 1)
#define PM_SUSPEND_STANDBY      ((__force suspend_state_t) 2)
#define PM_SUSPEND_MEM          ((__force suspend_state_t) 3)
#define PM_SUSPEND_MIN          PM_SUSPEND_TO_IDLE
#define PM_SUSPEND_MAX          ((__force suspend_state_t) 4)
```

第三. 解析当前传入的 state. 如果 state 小于 `PM_SUSPEND_MAX` 就走 suspend 流程, 等于 `PM_SUSPEND_MAX` 就走 hibernate 流程. 我们传入的是 mem, 则就会走 **suspend** 流程.

## 1.2. pm_suspend 函数分析

```cpp
// kernel/power/suspend.c
int pm_suspend(suspend_state_t state)
{
    int error;
    // 第一
    if (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)
        return -EINVAL;
    // 打印
    pr_info("suspend entry (%s)\n", mem_sleep_labels[state]);
    // 第三
    error = enter_state(state);
    if (error) {
        suspend_stats.fail++;
        dpm_save_failed_errno(error);
    } else {
        suspend_stats.success++;
    }
    // 打印
    pr_info("suspend exit\n");
    return error;
}
EXPORT_SYMBOL(pm_suspend);
```

第一. 依然会再次判断**当前的 state** 是否在 `PM_SUSPEND_ON` 和 `PM_SUSPEND_MAX` 之间

第二. pm_suspend_marker("entry")

```cpp

```

在 suspend 之间记录时间, 用于统计或者调试 suspend 花费的时间.

第三. 调用 `enter_state` 进入 suspend 的下一步, 如果**执行 suspend 成功**, 增加 `suspend_stats.success` 的**引用计数**, 否则增加 `suspend_stats.fail` 的引用计数.

## 1.3. enter_state 函数分析

```cpp
static int enter_state(suspend_state_t state)
{
    int error;
    // trace point
    trace_suspend_resume(TPS("suspend_enter"), state, true);
    if (state == PM_SUSPEND_TO_IDLE) {
#ifdef CONFIG_PM_DEBUG
        if (pm_test_level != TEST_NONE && pm_test_level <= TEST_CPUS) {
            pr_warn("Unsupported test mode for suspend to idle, please choose none/freezer/devices/platform.\n");
            return -EAGAIN;
        }
#endif
    // 第一
    } else if (!valid_state(state)) {
        return -EINVAL;
    }
    // 第二
    if (!mutex_trylock(&system_transition_mutex))
        return -EBUSY;
    // 第三
    if (state == PM_SUSPEND_TO_IDLE)
        s2idle_begin();
    // 第四
    if (sync_on_suspend_enabled) {
        // trace point
        trace_suspend_resume(TPS("sync_filesystems"), 0, true);
        ksys_sync_helper();
        // trace point
        trace_suspend_resume(TPS("sync_filesystems"), 0, false);
    }
    // debug log
    pm_pr_dbg("Preparing system for sleep (%s)\n", mem_sleep_labels[state]);
    pm_suspend_clear_flags();
    // 第五
    error = suspend_prepare(state);
    if (error)
        goto Unlock;
    // 如果是 freezer, 则完成, 不需要做设备和系统的 suspend
    if (suspend_test(TEST_FREEZER))
        goto Finish;
    // trace point
    trace_suspend_resume(TPS("suspend_enter"), state, false);
    // debug log
    pm_pr_dbg("Suspending system (%s)\n", mem_sleep_labels[state]);
    pm_restrict_gfp_mask();
    // 第六
    error = suspend_devices_and_enter(state);
    pm_restore_gfp_mask();

Finish:
    events_check_enabled = false;
    // debug log, 已经 resume 了
    pm_pr_dbg("Finishing wakeup.\n");
    // 第七, 恢复 resume
    suspend_finish();
Unlock:
    mutex_unlock(&system_transition_mutex);
    return error;
}
```

第一. 通过 `valid_state` 函数用来判断**该平台是否支持该状态睡眠**.

```cpp
static bool valid_state(suspend_state_t state)
{
    return suspend_ops && suspend_ops->valid && suspend_ops->valid(state) &&
        suspend_ops->enter;
}
```

第二. 调用 `mutex_trylock` 获得一个 system_transition_mutex mutex 锁, 防止在 suspend 的时候系统状态发生转换.

第三. 如果当前 state 是 `PM_SUSPEND_TO_IDLE`, 则调用 `s2idle_begin` 做开始准备工作(S2).

第四. **同步文件系统**.

第五. 调用 `suspend_prepare` 做进一步 suspend 前期准备工作, **准备控制台**, **冻结内核线程**等.

第六. 调用 `suspend_devices_and_enter` 做**设备**以及**系统**相关的 `susupend` 操作.

第七. 调用 `suspend_finish` 做最后的**恢复工作**.

# 2. suspend_prepare 函数分析

```cpp
static int suspend_prepare(suspend_state_t state)
{
    int error;
    // 第一
    if (!sleep_state_supported(state))
            return -EPERM;
    // 第二, 切换控制台
    pm_prepare_console();
    // 第三
    error = pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND);
    if (error)
            goto Restore;
    // trace point
    trace_suspend_resume(TPS("freeze_processes"), 0, true);
    // 第四
    error = suspend_freeze_processes();
    // trace point
    trace_suspend_resume(TPS("freeze_processes"), 0, false);
    if (!error)
            return 0;
    // 下面的开始失败
    // 冻结失败?
    suspend_stats.failed_freeze++;
    dpm_save_failed_step(SUSPEND_FREEZE);
    // 第五
    pm_notifier_call_chain(PM_POST_SUSPEND);
Restore:
    pm_restore_console();
    return error;
}
```

第一. 检测该平台 suspend_ops 是否实现了 enter 函数.

```cpp
static bool sleep_state_supported(suspend_state_t state)
{
    // S2?
    return state == PM_SUSPEND_TO_IDLE ||
    (valid_state(state) && !cxl_mem_active());
}
```

第二. 调用 `pm_prepare_console` 函数**切换控制台**, 重新分配一个 **suspend 模式下控制台**(虚拟 console), 然后**重定向内核的 kmsg**. 该功能称作 VT switch.

第三. 通过调用 **pm 通知链**, 发送 `PM_SUSPEND_PREPARE` 消息.

```cpp
int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)
{
    int ret;

    ret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);

    return notifier_to_errno(ret);
}
```

那谁会收到这类消息呢?  只有通过 `register_pm_notifier` 的**设备**, 子系统会在这个时候**处理自己的事情**.

```cpp
int register_pm_notifier(struct notifier_block *nb)
{
    return blocking_notifier_chain_register(&pm_chain_head, nb);
}
EXPORT_SYMBOL_GPL(register_pm_notifier);
```

第四. 调用 `suspend_freeze_processes` **冻结** 用户空间进程, 以及**内核线程**. 该功能称为 `freezing-of-tasks`. 如果冻结出现失败, **记录失败的引用计数**.

第五. 如果失败, 通过**通知链**恢复 suspend, 以及**恢复控制台**.

# 3. suspend_devices_and_enter 函数分析

```cpp
int suspend_devices_and_enter(suspend_state_t state)
{
    int error;
    bool wakeup = false;
    // 第一
    if (!sleep_state_supported(state))
        return -ENOSYS;

    pm_suspend_target_state = state;

    if (state == PM_SUSPEND_TO_IDLE)
        pm_set_suspend_no_platform();
    // 第二
    error = platform_suspend_begin(state);
    if (error)
        goto Close;
    // 第三
    suspend_console();
    // 第四
    suspend_test_start();
    // 第五
    error = dpm_suspend_start(PMSG_SUSPEND);
    if (error) {
        // 设备 suspend 失败, 打印 log
        pr_err("Some devices failed to suspend, or early wake event detected\n");
        // 平台 recover
        goto Recover_platform;
    }
    suspend_test_finish("suspend devices");
    if (suspend_test(TEST_DEVICES))
        goto Recover_platform;

    // 第六
    do {
        error = suspend_enter(state, &wakeup);
    } while (!error && !wakeup && platform_suspend_again(state));
    // 后面是 resume 了
Resume_devices:
    // 时间
    suspend_test_start();
    dpm_resume_end(PMSG_RESUME);
    suspend_test_finish("resume devices");
    // trace point
    trace_suspend_resume(TPS("resume_console"), state, true);
    // resume console
    resume_console();
    // trace point
    trace_suspend_resume(TPS("resume_console"), state, false);

Close:
    // 平台 resume
    platform_resume_end(state);
    // 设置状态
    pm_suspend_target_state = PM_SUSPEND_ON;
    return error;

Recover_platform:
    platform_recover(state);
    goto Resume_devices;
}
```

第一. 调用 `sleep_state_supported` 函数再次**判断**当前平台是否实现了 `suspend_ops`, 以及 `suspend_ops->enter` 函数.

第二. 如果当前状态是 `freeze`, 就调用 `freeze_ops` 的 begin 函数. **否则**就调用**平台相关**的 begin 函数. 这里的 begin 主要是各个平台 pm 的一些设置, 每个平台的操作都不一样, 这里不详细说明.

```cpp
static int platform_suspend_begin(suspend_state_t state)
{
    // S2 即 freeze?
    if (state == PM_SUSPEND_TO_IDLE && s2idle_ops && s2idle_ops->begin)
        return s2idle_ops->begin();
    else if (suspend_ops && suspend_ops->begin)
        return suspend_ops->begin(state);
    else
        return 0;
}
```

第三. 调用 `suspend_console` **挂起控制台**, 主要是 hold 住一个 lock, 该 lock 会阻止其它代码访问 console.

第四. 调用 `suspend_test_start` 记录当前 suspend 刚开始的**时候的时间**, 使用 `jiffies` 表示.

第五. 调用 `dpm_suspend_start` 函数, 该函数主要是调用**所有设备**的 `prepare` 和 `suspend` 回调函数. 如果出现 suspend **失败**, 则会打印 "`fail suspend`" 的 log, 以及调用 `platform_recover` 函数执行**平台相关**的 **recover 回调**.

第六. 调用 `suspend_enter` 使整个系统进入 suspend 状态.

## 3.1. dpm_suspend_start 函数分析

```cpp
// drivers/base/power/main.c
int dpm_suspend_start(pm_message_t state)
{
    ktime_t starttime = ktime_get();
    int error;
    // 第一
    error = dpm_prepare(state);
    if (error) {
            suspend_stats.failed_prepare++;
            dpm_save_failed_step(SUSPEND_PREPARE);
    } else
            error = dpm_suspend(state);
    dpm_show_time(starttime, state, error, "start");
    return error;
}
EXPORT_SYMBOL_GPL(dpm_suspend_start);
```

dpm: device power management

第一. 调用 `dpm_prepare` 函数, 执行**所有设备**(`dpm_list` 链表中) 的 `prepare` 回调函数. 由于设备模型有 bus、driver、device 等多个层级，而 prepare 接口可能由任意一个层级实现. 所以优先执行顺序是 `dev->pm_domain->ops, dev->type->pm, dev->class->pm, dev->bus->pm, dev->driver->pm`. 如果执行成功, 将该设备添加到 `dpm_prepared_list` 中; 如果**失败**设置 `failed_prepare` 的**引用计数值**.

> 设备模型在添加设备（`device_add`）时，会调用 `device_pm_add` 接口，将该设备添加到全局链表 `dpm_list` 中，以方便后续的遍历操作

第二. 调用 `dpm_suspend` 函数, 执行**所有设备**的 `suspend` 回调函数. 将设备从 `dpm_prepared_list` 链表，转移到 `dpm_suspended_list` 链表中.

## 3.2. suspend_enter 函数分析

上面对 dpm_suspend_start 函数进行了分析, 该函数中主要是调用**所有设备**的 prepare 和 suspend 回调函数. 而在 `suspend_enter` 主要是使**系统**进入到 suspend 中.

```cpp
static int suspend_enter(suspend_state_t state, bool *wakeup)
{
    int error;
    // 第一
    error = platform_suspend_prepare(state);
    if (error)
        goto Platform_finish;
    // 第二
    error = dpm_suspend_late(PMSG_SUSPEND);
    if (error) {
        pr_err("late suspend of devices failed\n");
        goto Platform_finish;
    }
    // 第三
    error = platform_suspend_prepare_late(state);
    if (error)
        goto Devices_early_resume;
    // 第四
    error = dpm_suspend_noirq(PMSG_SUSPEND);
    if (error) {
        pr_err("noirq suspend of devices failed\n");
        goto Platform_early_resume;
    }
    // 第五
    error = platform_suspend_prepare_noirq(state);
    if (error)
        goto Platform_wake;

    if (suspend_test(TEST_PLATFORM))
        goto Platform_wake;
    // 第六, 针对 freeze(S2) 的 sleep
    if (state == PM_SUSPEND_TO_IDLE) {
        s2idle_loop();
        goto Platform_wake;
    }
    // 第七
    error = pm_sleep_disable_secondary_cpus();
    if (error || suspend_test(TEST_CPUS))
        // 失败后启动 cpu
        goto Enable_cpus;
    // 第八
    arch_suspend_disable_irqs();
    BUG_ON(!irqs_disabled());
    // 设置系统状态
    system_state = SYSTEM_SUSPEND;
    // 第九, system core 的 suspend
    error = syscore_suspend();
    if (!error) {
        // 第十
        *wakeup = pm_wakeup_pending();
        if (!(suspend_test(TEST_CORE) || *wakeup)) {
            // trace point
            trace_suspend_resume(TPS("machine_suspend"),
                    state, true);
            // 第十一, 系统 suspend
            error = suspend_ops->enter(state);
            // trace point
            trace_suspend_resume(TPS("machine_suspend"),
                    state, false);
        } else if (*wakeup) {
            error = -EBUSY;
        }
        // 开始 resume
        syscore_resume();
    }

    system_state = SYSTEM_RUNNING;

    arch_suspend_enable_irqs();
    BUG_ON(irqs_disabled());

Enable_cpus:
    pm_sleep_enable_secondary_cpus();

Platform_wake:
    platform_resume_noirq(state);
    dpm_resume_noirq(PMSG_RESUME);

Platform_early_resume:
    platform_resume_early(state);

Devices_early_resume:
    dpm_resume_early(PMSG_RESUME);

Platform_finish:
    platform_resume_finish(state);
    return error;
}
```

第一. 调用平台相关 prepare 回调函数, 如果平台 prepare 设置失败, 在调用平台相关的 finish 回调函数.

第二. 调用 `dpm_suspend_late` 函数. 此函数主要调用 `dpm_suspend_list` 中的设备的 suspend_late 回调函数, 然后又将这些设备加入到 `dpm_late_early_list` 链表中. 如果出现失败, 则跳到 platform_finish 做恢复工作.

第三. 如果当前休眠状态是 `PM_SUSPEND_FREEZE` 的话, 调用 freeze_ops 中的 prepare 回调.

第四. 调用 `dpm_suspend_noirq` 函数, 会 **disable** 各个**设备的 irq**, 然后从 `dpm_late_early_list` 链表中取一个设备, 然后调用该设备的 `suspend_noirq` 回调, 同时将该设备加入到 `dpm_noirq_list` 链表中.

```cpp
// drivers/base/power/main.c
int dpm_suspend_noirq(pm_message_t state)
{
    int ret;

    device_wakeup_arm_wake_irqs();
    // disable 所有设备的 irq
    suspend_device_irqs();
    // 针对系统中的每一个 device, 
    // 依次调用 device_suspend_noirq 来执行该设备 noirq 情况下的 suspend callback 函数
    ret = dpm_noirq_suspend_devices(state);
    if (ret)
        dpm_resume_noirq(resume_event(state));

    return ret;
}
```

> 系统休眠(System Suspend)和设备中断处理: http://www.wowotech.net/pm_subsystem/suspend-irq.html

第五. 回调平台相关的 `preplate_late` 函数, 做 suspend 最后关头的事情.

第六. 如果休眠状态是 PM_SUSPEND_FREEZE, 则 frozen processes + suspended devices + idle processors

第七. disable 所有 nonboot 的 CPU, 失败之后启动 CPU.

第八. 关掉全局 cpu 中断, 如果关掉中断, 则报 BUG

第九. 执行所有 system core 的 suspend 回调函数.

第十. 如果执行成功的话, 这时候系统还会调用 pm_wakeup_pending 检查下, 是否有唤醒事件发生, 如果发生, 停止 suspend, 恢复系统.

第十一. 调用 `suspend_ops->enter` 函数, 此函数会回调系统 suspend 函数, 一般在 ATF 里实现.

第十二. 这时候系统已经睡眠, 如果这时候有唤醒事件发生, 比如按下手机的 power 按键, 系统又会接着 suspend 的地方, 再次往下执行. 也就是 suspend 的一些列反操作.

# resume 流程

OVMF 中, 当触发 system_wakeup, 

`InitializePlatform`(`OvmfPkg/PlatformPei/Platform.c`)

```cpp
InitializePlatform()
```

```cpp
PeiCore()
 └─ DxeLoadCore()
     ├─ BootMode = GetBootModeHob ()
     |   ├─ if (PlatformCmosRead8 (0xF) == 0xFE) // 从 CMOS 中读取 shutdown status
     |   |   ├─ IoWrite8 (0x70, (UINT8)Index);
     |   |   └─ return IoRead8 (0x71);
     |   └─ PlatformInfoHob->BootMode = BOOT_ON_S3_RESUME;
     └─ S3Resume->S3RestoreConfig2 (S3Resume);
         └─ S3ResumeExecuteBootScript()
             └─ S3BootScriptExecutorEntryFunction()
                 └─ S3ResumeBootOs()
                     └─ AsmTransferControl (Facs->FirmwareWakingVector, 0x0); // 跳转到 OS
```

`PeiCore()`, `MdeModulePkg/Core/Pei/PeiMain/PeiMain.c`

```cpp
DEBUG ((DEBUG_INFO, "DXE IPL Entry\n"));
TempPtr.DxeIpl->Entry (
                TempPtr.DxeIpl,
                &PrivateData.Ps,
                PrivateData.HobList
                );
```


```cpp
struct _EFI_DXE_IPL_PPI {
  EFI_DXE_IPL_ENTRY    Entry;
};
typedef struct _EFI_DXE_IPL_PPI EFI_DXE_IPL_PPI;
CONST EFI_DXE_IPL_PPI  mDxeIplPpi = {
  DxeLoadCore
};
```

`DxeLoadCore()`, `MdeModulePkg/Core/DxeIplPeim/DxeLoad.c`

```cpp
BootMode = GetBootModeHob ();
if (BootMode == BOOT_ON_S3_RESUME) {
    Status = S3Resume->S3RestoreConfig2 (S3Resume);
}
```

其中

```cpp
// MdePkg/Library/PeiHobLib/HobLib.c
EFI_BOOT_MODE
EFIAPI
GetBootModeHob (
  VOID
  )
{

  PeiServicesGetBootMode (&BootMode);

  return BootMode;
}

EFI_STATUS
EFIAPI
PeiServicesGetBootMode (
  OUT EFI_BOOT_MODE  *BootMode
  )
{
  CONST EFI_PEI_SERVICES  **PeiServices;

  PeiServices = GetPeiServicesTablePointer ();
  return (*PeiServices)->GetBootMode (PeiServices, BootMode);
}

// MdeModulePkg/Core/Pei/BootMode/BootMode.c
EFI_STATUS
EFIAPI
PeiGetBootMode (
  IN  CONST EFI_PEI_SERVICES  **PeiServices,
  IN  OUT   EFI_BOOT_MODE     *BootMode
  )
{
  PEI_CORE_INSTANCE           *PrivateData;
  EFI_HOB_HANDOFF_INFO_TABLE  *HandOffHob;

  DEBUG ((DEBUG_INFO, "PeiGetBootMode\n"));
  if (BootMode == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  PrivateData = PEI_CORE_INSTANCE_FROM_PS_THIS (PeiServices);

  HandOffHob = (PrivateData->HobList.HandoffInformationTable);

  *BootMode = HandOffHob->BootMode;

  return EFI_SUCCESS;
}
```

set 的来源: `OvmfPkg/PlatformPei/Platform.c`

InitializePlatform() -> BootModeInitialization()

```cpp
EFI_STATUS
EFIAPI
InitializePlatform (
  IN       EFI_PEI_FILE_HANDLE  FileHandle,
  IN CONST EFI_PEI_SERVICES     **PeiServices
  )
{
  DEBUG ((DEBUG_INFO, "Platform PEIM Loaded\n"));
  PlatformInfoHob = BuildPlatformInfoHob ();

  PlatformInfoHob->SmmSmramRequire     = FeaturePcdGet (PcdSmmSmramRequire);
  PlatformInfoHob->SevEsIsEnabled      = MemEncryptSevEsIsEnabled ();
  PlatformInfoHob->PcdPciMmio64Size    = PcdGet64 (PcdPciMmio64Size);
  PlatformInfoHob->DefaultMaxCpuNumber = PcdGet32 (PcdCpuMaxLogicalProcessorNumber);
  // dump 出来了所有 cmos 数据
  PlatformDebugDumpCmos ();

  // qemu 支持 S3
  if (QemuFwCfgS3Enabled ()) {
    DEBUG ((DEBUG_INFO, "S3 support was detected on QEMU\n"));
    PlatformInfoHob->S3Supported = TRUE;
    Status                       = PcdSetBoolS (PcdAcpiS3Enable, TRUE);
    ASSERT_EFI_ERROR (Status);
  }

  BootModeInitialization (PlatformInfoHob);
}

VOID
BootModeInitialization (
  IN OUT EFI_HOB_PLATFORM_INFO  *PlatformInfoHob
  )
{
  EFI_STATUS  Status;

  // 从 cmos 读
  if (PlatformCmosRead8 (0xF) == 0xFE) {
    // 在这里设置的
    PlatformInfoHob->BootMode = BOOT_ON_S3_RESUME;
  }
  // 清 0
  PlatformCmosWrite8 (0xF, 0x00);

  Status = PeiServicesSetBootMode (PlatformInfoHob->BootMode);
  ASSERT_EFI_ERROR (Status);

  Status = PeiServicesInstallPpi (mPpiBootMode);
  ASSERT_EFI_ERROR (Status);
}

// OvmfPkg/Library/PlatformInitLib/Cmos.c
UINT8
EFIAPI
PlatformCmosRead8 (
  IN      UINTN  Index
  )
{
  IoWrite8 (0x70, (UINT8)Index);
  return IoRead8 (0x71);
}

// MdePkg/Library/BaseIoLibIntrinsic/IoLibGcc.c
__asm__ __volatile__ ("inb %w1,%b0" : "=a" (Data) : "d" ((UINT16)Port));
```

IO 端口 0x70 是"CMOS/RTC 索引寄存器"，IO 端口 0x71 是"CMOS/RTC 数据寄存器"。要访问 CMOS 中的某些内容，应该设置索引，然后读取/写入数据寄存器。

0xF 是 shutdown status

```cpp
UINT8
EFIAPI
PlatformCmosWrite8 (
  IN      UINTN  Index,
  IN      UINT8  Value
  )
{
  DEBUG ((DEBUG_INFO, "CMOSWrite8: index %d, value %d\n", Index, Value));
  IoWrite8 (0x70, (UINT8)Index);
  IoWrite8 (0x71, Value);
  return Value;
}
```

同时添加 write 的 log:

```diff
@@ -83,11 +93,17 @@ IoWrite8 (
 {
   BOOLEAN  Flag;

+  if (Port == 0x71) {
+         DEBUG ((DEBUG_INFO, "IoWrite8 BaseIoLibIntrinsic\n"));
+  }
   Flag = FilterBeforeIoWrite (FilterWidth8, Port, &Value);
   if (Flag) {
     if (IsTdxGuest ()) {
       TdIoWrite8 (Port, Value);
     } else {
+         if (Port == 0x71) {
+                 DEBUG ((DEBUG_INFO, "3 IoWrite8 BaseIoLibIntrinsic\n"));
+         }
       __asm__ __volatile__ ("outb %b0,%w1" : : "a" (Value), "d" ((UINT16)Port));
     }
   }
```

并没有打印, 也就是说并不是 OVMF 侧设置的






`S3RestoreConfig2()`, `UefiCpuPkg/Universal/Acpi/S3Resume2Pei/S3Resume.c`

```cpp
DEBUG ((DEBUG_INFO, "Enter S3 PEIM\r\n"));
...
S3ResumeExecuteBootScript (AcpiS3Context, EfiBootScriptExecutorVariable);
```


`S3ResumeExecuteBootScript()`,

```cpp
    DEBUG ((DEBUG_INFO, "transfer control to Standalone Boot Script Executor\r\n"));
    SwitchStack (
      (SWITCH_STACK_ENTRY_POINT)(UINTN)EfiBootScriptExecutorVariable->BootScriptExecutorEntrypoint,
      (VOID *)AcpiS3Context,
      (VOID *)PeiS3ResumeState,
      (VOID *)(UINTN)(AcpiS3Context->BootScriptStackBase + AcpiS3Context->BootScriptStackSize)
      );
```

`S3BootScriptExecutorEntryFunction()`, S3 boot path, `MdeModulePkg/Universal/Acpi/BootScriptExecutorDxe/ScriptExecute.c`, OVMF 通过 SwitchStack 执行 OS 的 S3 代码

```cpp
DEBUG ((DEBUG_INFO, "Call SwitchStack() to return to S3 Resume in PEI Phase\n"));
PeiS3ResumeState->AsmTransferControl = (EFI_PHYSICAL_ADDRESS)(UINTN)AsmTransferControl;
    SwitchStack (
    // 等于 S3ResumeBootOs
    (SWITCH_STACK_ENTRY_POINT)(UINTN)PeiS3ResumeState->ReturnEntryPoint,
    (VOID *)(UINTN)AcpiS3Context,
    (VOID *)(UINTN)PeiS3ResumeState,
    (VOID *)(UINTN)PeiS3ResumeState->ReturnStackPointer
    );
```

`S3ResumeBootOs()`(`UefiCpuPkg/Universal/Acpi/S3Resume2Pei/S3Resume.c`)

```cpp
DEBUG ((DEBUG_INFO, "Transfer to 16bit OS waking vector - %x\r\n", (UINTN)Facs->FirmwareWakingVector));
AsmTransferControl (Facs->FirmwareWakingVector, 0x0);
```

然后会从 OS waking vector 开始执行, 在 `arch/x86/realmode/rm/wakeup_asm.S` 中



# 4. 小结

用一张图来总结 Suspend 的流程:

![2023-06-21-10-07-13.png](./images/2023-06-21-10-07-13.png)


None: http://www.wowotech.net/pm_subsystem/suspend_and_resume.html