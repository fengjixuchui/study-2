
Linux 电源管理存在的几种方式, 如何查看这几种方式, 以及最后的如何睡眠唤醒等. 通过 `echo mem > /sys/power/state` 就可以达到睡眠, 所以可以根据此节点的 sys 代码分析 suspend 的流程.

# 1. suspend 代码入口

执行如下命令:

```
echo mem > /sys/power/state
```

根据 sys 节点的属性命令规则, 可以得到此节点的实现代码为:  `state_store`

## 1.1. state_store 函数分析

```cpp
// kernel/power/power.h
#define power_attr(_name) \
static struct kobj_attribute _name##_attr = {   \
        .attr   = {                             \
                .name = __stringify(_name),     \
                .mode = 0644,                   \
        },                                      \
        .show   = _name##_show,                 \
        .store  = _name##_store,                \
}

// kernel/power/main.c
static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
                           const char *buf, size_t n)
{
    suspend_state_t state;
    int error;
    // 第一
    error = pm_autosleep_lock();
    if (error)
            return error;
    // 第二
    if (pm_autosleep_state() > PM_SUSPEND_ON) {
            error = -EBUSY;
            goto out;
    }

    state = decode_state(buf, n);
    if (state < PM_SUSPEND_MAX) {
            if (state == PM_SUSPEND_MEM)
                    state = mem_sleep_current;

            error = pm_suspend(state);
    } else if (state == PM_SUSPEND_MAX) {
            error = hibernate();
    } else {
            error = -EINVAL;
    }

out:
    pm_autosleep_unlock();
    return error ? error : n;
}

power_attr(state);
```

第一. `pm_autosleep_lock`

```cpp
// kernel/power/autosleep.c
int pm_autosleep_lock(void)
{
    return mutex_lock_interruptible(&autosleep_lock);
}
```

获得 autosleep 锁, 锁住 autosleep 功能, 此功能在后面分析

第二. 判断当前 autosleep 的状态, 如果当前状态大于 `PM_SUSPEND_ON`, 则返回退出. 关于 suspend 的状态如下：

```cpp

```

第三. 解析当前传入的 state. 如果 state 小于 PM_SUSPEND_MAX 就走 suspend 流程, 等于 PM_SUSPEND_MAX 就走 hibernate 流程. 假如我们传入的是 mem, 则就会走 suspend 流程.

## 1.2. pm_suspend 函数分析

```cpp

```

第一. 依然会再次判断当前的 state 是否在 PM_SUSPEND_ON 和 PM_SUSPEND_MAX 之间

第二. pm_suspend_marker("entry")

```cpp

```

在 suspend 之间记录时间, 用于统计或者调试 suspend 花费的时间.

第三. 调用 enter_state 进入 suspend 的下一步, 如果执行 suspend 成功, 增加 suspend.success 的引用计数, 否则增加 suspend.fail 的引用计数.

## 1.3. enter_state 函数分析

```cpp

```

第一. 通过 vaild_state 函数用来判断该平台是否支持该状态睡眠.

```cpp

```

第二. 调用 mutex_trylock 获得一个 mutex 锁, 防止在 suspend 的时候再次 suspend.

第三. 如果当前 state 是 PM_SUSPEND_FREEZE, 则调用 freeze_begin 做开始准备工作.

第四. 同步文件系统.

第五. 调用 suspend_prepare 做进一步 suspend 前期准备工作, 准备控制台, 冻结内核线程等.

第六. 调用 suspend_devices_and_enter 做设备以及系统相关的 susupend 操作.

第七. 调用 suspend_finish 做最后的恢复工作.

# 2. suspend_prepare 函数分析

```cpp

```

第一. 检测该平台 suspend_ops 是否实现了 enter 函数.

```cpp

```

第二. 调用 pm_prepare_console 函数切换控制台, 重新分配一个 suspend 模式下控制台, 然后重定向 kmsg.

第三. 通过调用 pm 通知链, 发送 PM_SUSPEND_PREPARE 消息.

```cpp

```

那谁会收到这类消息呢？ 只有通过 register_pm_notifier 的设备, 子系统会在这个时候处理自己的事情.

```cpp

```

第四. 调用 suspend_freeze_processes 冻结 userhelper 进程, 已经内核线程. 如果冻结出现失败, 记录失败的引用计数.

第五. 接着会通过通知链恢复 suspend, 已经恢复控制台.

# 3. suspend_devices_and_enter 函数分析

```cpp

```

第一. 调用 sleep_state_supported 函数判断当前平台是否实现了 suspend_ops, 已经 suspend_ops->enter 函数.

第二. 如果当前状态是 freeze, 就调用 freeze_ops 的 begin 函数. 否则就调用平台相关的 begin 函数. 这里的 begin 主要是各个平台 pm 的一些设置, 每个平台的操作都不一样, 这里不详细说明.

第三. 调用 suspend_console 挂起控制台, 防止其它代码访问该控制台.

第四. 调用 suspend_test_start 记录当前 suspend 刚开始的时候的时间, 使用 jiffies 表示.

第五. 调用 dpm_suspend_start 函数, 该函数主要是调用所有设备的 prepare 和 suspend 回调函数. 如果出现 suspend 失败, 则会打印"fail suspend"的 log, 以及调用 platform_recover 函数执行平台相关的 recover 回调.

第六. 调用 suspend_enter 使整个系统进入 suspend 状态.

## 3.1. dpm_suspend_start 函数分析

```cpp

```

第一. 调用 dpm_prepare 函数, 执行所有设备的 prepare 回调函数. 执行顺序是 pm_domain-type-class-bus-driver, 如果失败设置 failed_prepare 的引用计数值.

第二. 调用 dpm_suspend 函数, 执行所有设备的 suspend 回调函数.

## 3.2. suspend_enter 函数分析

上面对 dpm_suspend_start 函数进行了分析, 该函数中主要是调用所有设备的 prepare 和 suspend 回调函数. 而在 suspend_enter 主要是使系统进入到 suspend 中.

```cpp

```

第一. 调用平台相关 prepare 回调函数, 如果平台 prepare 设置失败, 在调用平台相关的 finish 回调函数.

第二. 调用 dpm_suspend_late 函数. 此函数主要调用 dpm_suspend_list 中的设备的 suspend_late 回调函数, 然后又将这些设备加入到 dpm_late_early_list 链表中. 如果出现失败, 则跳到 platform_finish 做恢复工作.

第三. 如果当前休眠状态是 PM_SUSPEND_FREEZE 的话, 调用 freeze_ops 中的 prepare 回调.

第四. 调用 dpm_suspend_noirq 函数, 此函数主要是从 dpm_late_early_list 链表中取一个设备, 然后调用该设备的 suspend_noirq 回调, 同时将该设备加入到 dpm_noirq_list 链表中.

第五. 回调平台相关的 preplate_late 函数, 做 suspend 最后关头的事情.

第六. 如果休眠状态是 PM_SUSPEND_FREEZE, 则 frozen processes + suspended devices + idle processors

第七. disable 所有非 nonboot 的 CPU, 失败之后启动 CPU.

第八. 关掉全局 cpu 中断, 如果关掉中断, 则报 BUG

第九. 执行所有 system core 的 suspend 回调函数.

第十. 如果执行成功的话, 这时候系统还会调用 pm_wakeup_pending 检查下, 是否有唤醒事件发生, 如果发生, 停止 suspend, 恢复系统.

第十一. 调用 suspend_ops->enter 函数, 此函数会回调系统 suspend 函数, 一般在 ATF 里实现.

第十二. 这时候系统已经睡眠, 如果这时候有唤醒事件发生, 比如按下手机的 power 按键, 系统又会接着 suspend 的地方, 再次往下执行. 也就是 suspend 的一些列反操作.

# 4. 小结

用一张图来总结 Suspend 的流程:

![2023-06-21-10-07-13.png](./images/2023-06-21-10-07-13.png)
