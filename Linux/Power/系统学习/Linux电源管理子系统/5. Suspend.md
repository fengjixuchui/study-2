
# 1. 几种 suspend

Linux 内核提供了几种 suspend 方式: Freeze、Standby, mem 和 disk. 在用户空间通过 `cat /sys/power/state` 查看支持的, 同时向 ”`/sys/power/state`” 文件分别写入”freeze”、”standby”和”mem”, 即可触发它们.

```
# cat /sys/power/state
freeze mem
```

* freeze: 冻结 I/O 设备, 将它们置于低功耗状态, 使处理器进入空闲状态, 唤醒最快, 耗电比其它 standby, mem, disk 方式高

* standby: 除了冻结 I/O 设备外, 还会暂停系统, 唤醒较快, 耗电比其它 mem, disk 方式高, 对应 S1

* mem: 将运行状态数据存到内存, 并关闭外设, 进入等待模式, 唤醒较慢, 耗电比 disk 方式高, 对应 S3

* disk: 将运行状态数据存到硬盘, 然后关机, 唤醒最慢, 对应 S4

内核中, Suspend 及 Resume 过程涉及到 PM Core、Device PM、各个设备的驱动、Platform dependent PM、CPU control 等多个模块, 涉及了 console switch、process freeze、CPU hotplug、wakeup 处理等过个知识点.

# 2. 有关的代码分布

内核中 Suspend 功能有关的代码包括 PM core、Device PM、Platform PM 等几大块, 具体如下:

## 2.1. PM core

```
kernel/power/main.c         ----    提供用户空间接口(/sys/power/state)

kernel/power/suspend.c      ----    Suspend 功能的主逻辑

kernel/power/suspend_test.c ----    Suspend 功能的测试逻辑

kernel/power/console.c      ----    Suspend 过程中对控制台的处理逻辑

kernel/power/process.c      ----    Suspend 过程中对进程的处理逻辑
```

## 2.2. Device PM

```
drivers/base/power/*        ----    具体可参考 “4. 接口” 的描述.

设备驱动                     ----    具体设备驱动的位置, 不再涉及.
```

## 2.3. Platform dependent PM

```
include/linux/suspend.h     ----    定义 platform dependent PM 有关的操作函数集

arch/xxx/ma ch- xxx/xxx.c 或者

arch/xxx/plat-xxx/xxx.c     ----    平台相关的电源管理操作
```

# 3. 分析方法

利用 qemu-kvm 虚拟化进行分析.

## 3.1. kernel build

```
mkdir build

cp kernel_config build/.config

make olddefconfig O=build

make -j 12 O=build

make modules_install INSTALL_MOD_PATH=rootfs O=build

tar zcvf /home/ubuntu/haiwei/modules.tar.gz ./build/rootfs/lib/modules

cp ./build/arch/x86_64/boot/bzImage /home/ubuntu/haiwei/
```

需要将 modules 拷贝到 guest image 中

## 3.2. OVMF

```
git clone https://github.com/tianocore/edk2.git
cd edks
git submodule update --init

cp BaseTool/Conf/target.template Conf/target.txt
```

编辑 Conf/target.txt

```
ACTIVE_PLATFORM       = OvmfPkg/OvmfPkgX64.dsc
TARGET                = DEBUG
TARGET_ARCH           = X64
TOOL_CHAIN_TAG        = GCC5
```

```
OvmfPkg/build.sh -a X64 -D DEBUG_ON_SERIAL_PORT

ll Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd
```

## 3.3. 命令行

debug ovmf:

>qemu-system-x86_64 -name ubuntu -accel kvm -drive file=/home/ubuntu/haiwei/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd,format=raw,if=pflash -cpu host -m 2G -smp 2 -drive file=/home/ubuntu/haiwei/ubuntu22.04.qcow2,format=qcow2,if=none,id=drive-virtio-disk0,cache=none -object iothread,id=iothread0 -device virtio-blk-pci,iothread=iothread0,scsi=off,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1 -netdev user,id=hostnet0 -device rtl8139,netdev=hostnet0,id=net0,mac=52:54:00:36:32:aa,bus=pci.0,addr=0x5 -chardev socket,id=montest,server=on,wait=off,path=/tmp/mon_test -mon chardev=montest,mode=readline -serial mon:stdio -nographic

```shell
/root/workspace/codes/s3/qemu/build/qemu-system-x86_64 \
    -name ubuntu -accel kvm \
    -drive file=/root/workspace/codes/s3/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd,format=raw,if=pflash \
    -cpu host,host-cache-info=true \
    -m 2G -smp 2 \
    -drive file=/root/workspace/tools/ubuntu22.04.qcow2,format=qcow2,if=none,id=drive-virtio-disk0,cache=none \
    -object iothread,id=iothread0 \
    -device virtio-blk-pci,iothread=iothread0,scsi=off,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1 \
    -netdev user,id=hostnet0 -device rtl8139,netdev=hostnet0,id=net0,mac=52:54:00:36:32:aa,bus=pci.0,addr=0x5 \
    -chardev socket,id=montest,server=on,wait=off,path=/tmp/mon_test -mon chardev=montest,mode=readline \
    -serial mon:stdio -nographic
```

debug kernel:

> qemu-system-x86_64 -name ubuntu -accel kvm -cpu host,host-cache-info=true -m 2G -smp 2 -hda /home/ubuntu/haiwei/ubuntu22.04.qcow2 -netdev user,id=hostnet0 -device rtl8139,netdev=hostnet0,id=net0,mac=52:54:00:36:32:aa,bus=pci.0,addr=0x5 -kernel /home/ubuntu/haiwei/linux/build/arch/x86_64/boot/bzImage -append "root=/dev/sda1 ro console=tty1 console=ttyS0 intel_iommu=sm_on,on loglevel=8 pm_debug_messages dyndbg='file pciehp* +p'" -chardev socket,id=montest,server=on,wait=off,path=/tmp/mon_test -mon chardev=montest,mode=readline -serial mon:stdio -nographic -full-screen

```shell
/root/workspace/codes/s3/qemu/build/qemu-system-x86_64 \
    -name ubuntu -accel kvm \
    -cpu host,host-cache-info=true \
    -m 2G -smp 2 \
    -drive file=/root/workspace/tools/ubuntu22.04.qcow2,format=qcow2,if=none,id=drive-virtio-disk0,cache=none \
    -object iothread,id=iothread0 \
    -device virtio-blk-pci,iothread=iothread0,scsi=off,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1 \
    -netdev user,id=hostnet0 -device rtl8139,netdev=hostnet0,id=net0,mac=52:54:00:36:32:aa,bus=pci.0,addr=0x5 \
    -kernel /root/workspace/codes/s3/linux/build/arch/x86/boot/bzImage \
    -append "root=/dev/vda1 ro console=tty1 console=ttyS0 intel_iommu=sm_on,on loglevel=8 pm_debug_messages dyndbg='file pciehp* +p'" \
    -chardev socket,id=montest,server=on,wait=off,path=/tmp/mon_test -mon chardev=montest,mode=readline \
    -serial mon:stdio -nographic
```

## 3.4. 相关操作

在 guest 中触发 kernel suspend

```
echo 8 4 1 7 > /proc/sys/kernel/printk

echo 1 > /sys/power/pm_debug_messages

loglevel=8 i915.nuclear_pageflip=1 swiotlb=131072 dyndbg='file pciehp* +p'

systemctl restart rsyslog

echo mem > /sys/power/state
```

在 qemu monitor 中触发 kernel resume

```
# nc -U /tmp/mon_test
QEMU 6.2.0 monitor - type 'help' for more information
(qemu) system_wakeup
system_wakeup
```

当然也可以通过 rtcwake 功能:

```
# 让系统进入 S3, 睡 10 秒再自动唤醒

rtcwake -v -s 10 -m mem
```

### pm_test

查看支持的

```
# cat /sys/power/pm_test
[none] core processors platform devices freezer
```


## debug 选项

### pm_pr_dbg

kernel 中的 debug 函数 `pm_pr_dbg()`: 确保 guest kernel 有 `CONFIG_PM_SLEEP_DEBUG` 这个选项, 并且 `echo 1 > /sys/power/pm_debug_messages` 或者添加 kernel parameter `pm_debug_messages`

```cpp
// include/linux/suspend.h
#ifdef CONFIG_PM_SLEEP_DEBUG
extern bool pm_print_times_enabled;
extern bool pm_debug_messages_on;
// 有 CONFIG_PM_SLEEP_DEBUG 就会是这里
extern __printf(2, 3) void __pm_pr_dbg(bool defer, const char *fmt, ...);
#else
#define pm_print_times_enabled  (false)
#define pm_debug_messages_on    (false)

#include <linux/printk.h>

// 必须定义 CONFIG_PM_SLEEP_DEBUG
#define __pm_pr_dbg(defer, fmt, ...) \
        no_printk(KERN_DEBUG fmt, ##__VA_ARGS__)
#endif
// pm_pr_dbg 的定义
#define pm_pr_dbg(fmt, ...) \
	__pm_pr_dbg(fmt, ##__VA_ARGS__)


// kernel/power/main.c
// CONFIG_PM_SLEEP_DEBUG 是前提
#ifdef CONFIG_PM_SLEEP_DEBUG
...
// 对于 pm_debug_messages 的定义
bool pm_debug_messages_on __read_mostly;
static ssize_t pm_debug_messages_store(struct kobject *kobj,
                                       struct kobj_attribute *attr,
                                       const char *buf, size_t n)
{
        unsigned long val;

        if (kstrtoul(buf, 10, &val))
                return -EINVAL;

        if (val > 1)
                return -EINVAL;

        pm_debug_messages_on = !!val;
        return n;
}
static int __init pm_debug_messages_setup(char *str)
{
        pm_debug_messages_on = true;
        return 1;
}
// 内核启动参数
__setup("pm_debug_messages", pm_debug_messages_setup);

void __pm_pr_dbg(bool defer, const char *fmt, ...)
{
        struct va_format vaf;
        va_list args;
        // pm_debug_messages_on 必须是 1
        if (!pm_debug_messages_on)
                return;

        va_start(args, fmt);

        vaf.fmt = fmt;
        vaf.va = &args;

        if (defer)
                printk_deferred(KERN_DEBUG "PM: %pV", &vaf);
        else
                printk(KERN_DEBUG "PM: %pV", &vaf);

        va_end(args);
}

#else /* !CONFIG_PM_SLEEP_DEBUG */
static inline void pm_print_times_init(void) {}
#endif /* CONFIG_PM_SLEEP_DEBUG */
```

### acpi log

```
echo 0x20000000 > /sys/module/acpi/parameters/debug_layer

echo 0x04 > /sys/module/acpi/parameters/debug_level
```

### pm_async

`/sys/power/pm_async`, 使用 async(默认)/sync 的方式执行 suspend/resume 流程

`echo 0 > /sys/power/pm_async`, 使用 **同步** 方式, 跟 async 异步方式相比, 同步是需要等到上一个 device 的 suspend/resume 流程结束返回后, 才能去执行下一个 device 的 suspend/resume 操作

```cpp
// kernel/power/main.c
/* If set, devices may be suspended and resumed asynchronously. */
int pm_async_enabled = 1;
// /sys/power/pm_async 节点
static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,
			      const char *buf, size_t n)
{
	unsigned long val;

	if (kstrtoul(buf, 10, &val))
		return -EINVAL;

	if (val > 1)
		return -EINVAL;

	pm_async_enabled = val;
	return n;
}
power_attr(pm_async);
```

```cpp
// drivers/base/power/power.h
// 基本要求
#ifdef CONFIG_PM_SLEEP
extern int pm_async_enabled;

// drivers/base/power/main.c
static bool is_async(struct device *dev)
{
    // 三个要求
    // 1. 设备支持 async
    // 2. 系统 async 属性必须设置
    // 3. pm_trace 没有 enable, 见下面
	return dev->power.async_suspend && pm_async_enabled
		&& !pm_trace_is_enabled();
}
```

```
# lspci -s 0000:01:00.0
0000:01:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8821CE 802.11ac PCIe Wireless Network Adapter
# cat /sys/bus/pci/devices/0000\:01\:00.0/power/async
enabled
```

### pm_print_times

```
echo 1 > /sys/power/pm_print_times //在每个设备发起 休眠 和 唤醒 流程的时候就能打印出来
```

### pm_trace

必须打开 `CONFIG_PM_TRACE`

```
echo 1 > /sys/power/pm_trace
```

这样 `TRACE_DEVICE();`, `TRACE_SUSPEND()` 和 `TRACE_RESUME();` 便会有


```cpp
// kernel/power/main.c
#ifdef CONFIG_PM_TRACE
// 默认为 0
int pm_trace_enabled;
static ssize_t
pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,
	       const char *buf, size_t n)
{
	int val;

	if (sscanf(buf, "%d", &val) == 1) {
		pm_trace_enabled = !!val;
		if (pm_trace_enabled) {
			pr_warn("PM: Enabling pm_trace changes system date and time during resume.\n"
				"PM: Correct system time has to be restored manually after resume.\n");
		}
		return n;
	}
	return -EINVAL;
}

power_attr(pm_trace);
#endif /* CONFIG_PM_TRACE */

// include/linux/pm-trace.h
extern int pm_trace_enabled;
// async 使用
static inline int pm_trace_is_enabled(void)
{
       return pm_trace_enabled;
}
```

### console_suspend

内核启动参数: `no_console_suspend`, 会打印更多 log

```
echo N > /sys/module/printk/parameters/console_suspend //休眠的时候保持终端打开
```

## 3.5. 结果

guest 本身日志

```
[   38.671957] PM: suspend entry (deep)
[   38.671977] ACPI: PM: acpi_suspend_state_valid 662
[   39.044905] Filesystems sync: 0.372 seconds
[   39.044918] PM: Preparing system for sleep (deep)
[   39.044923] ACPI: PM: acpi_suspend_state_valid 662
[   39.045527] Freezing user space processes
[   39.047035] Freezing user space processes completed (elapsed 0.001 seconds)
[   39.047049] OOM killer disabled.
[   39.047053] Freezing remaining freezable tasks
[   39.048322] Freezing remaining freezable tasks completed (elapsed 0.001 seconds)
[   39.048351] PM: Suspending system (deep)
[   39.048356] ACPI: PM: acpi_suspend_state_valid 662
[   39.048362] ACPI: PM: acpi_suspend_begin 566 1
[   39.048367] ACPI: PM: acpi_suspend_begin 576
[   39.048371] ACPI: PM: acpi_pm_start 522
[   39.048375] ACPI: PM: acpi_sleep_tts_switch 40 3
[   39.048407] printk: Suspending console(s) (use no_console_suspend to debug)
[   39.052935] ------------[ cut here ]------------
[   39.052947] WARNING: CPU: 0 PID: 667 at kernel/workqueue.c:3167 __flush_work.isr0
[   39.052965] Modules linked in: binfmt_misc nls_iso8859_1 intel_rapl_msr intel_ra4
[   39.053118] CPU: 0 PID: 667 Comm: kworker/u4:8 Not tainted 6.3.0-dirty #4
[   39.053125] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-14
[   39.053129] Workqueue: events_unbound async_run_entry_fn
[   39.053140] RIP: 0010:__flush_work.isra.0+0x7c/0x90
[   39.053150] Code: 48 2b 14 25 28 00 00 00 75 26 4c 8b 65 f8 c9 c3 cc cc cc cc 480
[   39.053156] RSP: 0000:ffffaadb40ddbc38 EFLAGS: 00010246
[   39.053162] RAX: 0000000000000001 RBX: 0000000000000000 RCX: ffffffffa7dc7b60
[   39.053167] RDX: 0000000000000001 RSI: 0000000000000001 RDI: ffff907ac3556b30
[   39.053171] RBP: ffffaadb40ddbc98 R08: 0000000000000000 R09: ffff907ac9b88f74
[   39.053174] R10: 000000000000000f R11: 000000000000000f R12: ffff907ac3556b30
[   39.053177] R13: 0000000000000001 R14: ffff907ac2f70000 R15: 0000000000000002
[   39.053181] FS:  0000000000000000(0000) GS:ffff907b3dc00000(0000) knlGS:000000000
[   39.053186] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   39.053191] CR2: 00007fb063930768 CR3: 000000000dc1a001 CR4: 0000000000370ef0
[   39.053202] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   39.053206] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[   39.053210] Call Trace:
[   39.053223]  <TASK>
[   39.053226]  ? native_send_call_func_single_ipi+0x1b/0x30
[   39.053248]  ? try_to_grab_pending+0xe8/0x190
[   39.053257]  __cancel_work_timer+0x11d/0x1a0
[   39.053267]  ? _raw_spin_unlock_irq+0xe/0x30
[   39.053274]  ? __wait_for_common+0x15b/0x190
[   39.053280]  ? _raw_spin_unlock_irqrestore+0xe/0x40
[   39.053291]  cancel_delayed_work_sync+0x13/0x20
[   39.053301]  drm_kms_helper_poll_disable+0x33/0x50 [drm_kms_helper]
[   39.053518]  drm_mode_config_helper_suspend+0x21/0x80 [drm_kms_helper]
[   39.053573]  ? __pm_runtime_resume+0x60/0x90
[   39.053582]  bochs_pm_suspend+0x12/0x20 [bochs]
[   39.053605]  pci_pm_suspend+0x87/0x1b0
[   39.053613]  ? __pfx_pci_pm_suspend+0x10/0x10
[   39.053620]  dpm_run_callback+0x51/0x190
[   39.053631]  __device_suspend+0x14c/0x550
[   39.053641]  async_suspend+0x1f/0x80
[   39.053650]  async_run_entry_fn+0x30/0x120
[   39.053658]  process_one_work+0x21c/0x430
[   39.053669]  worker_thread+0x50/0x3e0
[   39.053678]  ? __pfx_worker_thread+0x10/0x10
[   39.053687]  kthread+0xee/0x120
[   39.053692]  ? __pfx_kthread+0x10/0x10
[   39.053699]  ret_from_fork+0x29/0x50
[   39.053715]  </TASK>
[   39.053718] ---[ end trace 0000000000000000 ]---
[   39.069215] sd 0:0:0:0: [sda] Synchronizing SCSI cache
[   39.088687] sd 0:0:0:0: [sda] Stopping disk
[   39.091265] PM: suspend of devices complete after 42.674 msecs
[   39.091277] PM: start suspend of devices complete after 42.863 msecs
[   39.091803] PM: late suspend of devices complete after 0.497 msecs
[   39.095185] PM: noirq suspend of devices complete after 3.036 msecs
[   39.095228] ACPI: PM: acpi_sleep_prepare 78 0x991f0
[   39.095236] ACPI: PM: Preparing to enter system sleep state S3
[   39.095393] ACPI: PM: Saving platform NVS memory
[   39.095425] Disabling non-boot CPUs ...
[   39.098174] smpboot: CPU 1 is now offline
[   39.099593] Checking wakeup interrupts
[   39.099596] Calling kvm_suspend+0x0/0x40 [kvm]
[   39.100325] Calling mce_syscore_suspend+0x0/0x30
[   39.100336] Calling ledtrig_cpu_syscore_suspend+0x0/0x20
[   39.100347] Calling timekeeping_suspend+0x0/0x2e0
[   39.100399] Calling irq_gc_suspend+0x0/0x80
[   39.100414] Calling save_ioapic_entries+0x0/0x160
[   39.101278] Calling i8259A_suspend+0x0/0x30
[   39.101296] Calling fw_suspend+0x0/0x20
[   39.101304] Calling acpi_save_bm_rld+0x0/0x30
[   39.101343] Calling lapic_suspend+0x0/0x220
[   39.101873] Calling kvm_suspend+0x0/0x60
[   39.102037] ACPI Error: !acpi_gbl_reduced_hardware (20221020/hwxfsleep-301)
[   43.626252] ACPI: PM: Low-level resume complete
[   43.626299] ACPI Error: 2    !acpi_gbl_reduced_hardware (20221020/hwxfsleep-333)
[   43.626340] ACPI: PM: Restoring platform NVS memory
[   43.626344] Calling kvm_resume+0x0/0x50
[   43.626360] Calling lapic_resume+0x0/0x2e0
[   43.626470] Calling acpi_restore_bm_rld+0x0/0x60
[   43.626476] Calling irqrouter_resume+0x0/0x50
[   43.626715] Calling i8259A_resume+0x0/0x40
[   43.626845] Calling i8237A_resume+0x0/0xb0
[   43.626960] Calling ioapic_resume+0x0/0x140
[   43.627173] Calling irq_gc_resume+0x0/0x80
[   43.627177] Calling irq_pm_syscore_resume+0x0/0x20
[   43.627193] Calling timekeeping_resume+0x0/0x160
[   43.627236] Timekeeping suspended for 5.214 seconds
[   43.627314] Calling ledtrig_cpu_syscore_resume+0x0/0x20
[   43.627321] Calling mce_syscore_resume+0x0/0x30
[   43.627361] Calling kvm_resume+0x0/0x60 [kvm]
[   43.627494] Enabling non-boot CPUs ...
[   43.627619] x86: Booting SMP configuration:
[   43.627620] smpboot: Booting Node 0 Processor 1 APIC 0x1
[   43.628438] CPU1 is up
[   43.628564] ACPI: PM: Waking up from system sleep state S3
[   43.630229] PM: noirq resume of devices complete after 1.595 msecs
[   43.630323] PM: early resume of devices complete after 0.077 msecs
[   43.630355] pci 0000:00:01.0: PIIX3: Enabling Passive Release
[   43.630443] sd 0:0:0:0: [sda] Starting disk
[   43.788863] ata1: found unknown device (class 0)
[   43.792837] ata2: found unknown device (class 0)
[   43.793043] PM: resume of devices complete after 162.718 msecs
[   43.815034] ACPI: PM: acpi_sleep_tts_switch 40 0
[   43.815071] PM: Finishing wakeup.
[   43.815462] OOM killer enabled.
[   43.815465] Restarting tasks ... done.
[   43.822100] random: crng reseeded on system resumption
[   43.822109] PM: suspend exit
```

`PM: suspend entry (deep)`, `pm_suspend()`,

`Filesystems sync: 0.001 seconds`, `pm_suspend()` -> `enter_state()` -> `ksys_sync_helper()`, `kernel/power/main.c`

`PM: Preparing system for sleep (deep)`, `pm_suspend()` -> `enter_state()`, `kernel/power/suspend.c`

`Freezing user space processes ... (elapsed 0.001 seconds) done.`, `pm_suspend()` -> `enter_state()` -> `suspend_prepare()` -> `suspend_freeze_processes()` -> `freeze_processes()`, `kernel/power/process.c`

`OOM killer disabled.`,  -> `oom_killer_disable()`, `mm/oom_kill.c`

`Freezing remaining freezable tasks ... (elapsed 0.000 seconds) done.`,  -> `freeze_kernel_threads()`, `kernel/power/process.c`

`PM: Suspending system (deep)`, `pm_suspend()` -> `enter_state()`, `kernel/power/suspend.c`

`printk: Suspending console(s) (use no_console_suspend to debug)`, `suspend_devices_and_enter()` -> `suspend_console()`, `kernel/printk/printk.c`

`e1000e: EEE TX LPI TIMER: 00000011`, `e1000_pm_ops->suspend`, `e1000e_pm_suspend()` -> `e1000e_flush_lpic()`, `drivers/net/ethernet/intel/e1000e/netdev.c`

`ACPI: EC: interrupt blocked`, `SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(acpi_ec_suspend_noirq, acpi_ec_resume_noirq)`, `acpi_ec_suspend_noirq()` -> `acpi_ec_enter_noirq()`, `drivers/acpi/ec.c`

`ACPI: PM: Preparing to enter system sleep state S3`, `acpi_sleep_prepare()`, 其中会调用 `acpi_set_waking_vector(acpi_wakeup_address);`, 设置 waking vector

qemu monitor 触发 system_wakeup, guest 那边 OVMF 日志:

```
SecCoreStartupWithStack(0xFFFCC000, 0x820000)
SecCoreStartupWithStack(0xFFFCC000, 0x820000)
Register PPI Notify: DCD0BE23-9586-40F4-B643-06522CED4EDE
Install PPI: 8C8CE578-8A3D-4F1C-9935-896185C32DD3
Install PPI: 5473C07A-3DCB-4DCA-BD6F-1E9689E7349A
The 0th FV start address is 0x00000820000, size is 0x000E0000, handle is 0x820000
Register PPI Notify: 49EDB1C1-BF21-4761-BB12-EB0031AABB39
Register PPI Notify: EA7CA24B-DED5-4DAD-A389-BF827E8F9B38
Install PPI: B9E0ABFE-5979-4914-977F-6DEE78C278A6
Install PPI: DBE23AA9-A345-4B97-85B6-B226F1617389
Install PPI: 138F9CF4-F0E7-4721-8F49-F5FFECF42D40
DiscoverPeimsAndOrderWithApriori(): Found 0x8 PEI FFS files in the 0th FV
Loading PEIM 9B3ADA4F-AE56-4C24-8DEA-F03B7558AE50
Loading PEIM at 0x0000082BF40 EntryPoint=0x0000082F2CE PcdPeim.efi
Install PPI: 06E81C58-4AD7-44BC-8390-F10265F72480
Install PPI: 01F34D25-4DE2-23AD-3FF3-36353FF323F1
Install PPI: 4D8B155B-C059-4C8F-8926-06FD4331DB8A
Install PPI: A60C6B59-E459-425D-9C69-0BCC9CB27D81
Register PPI Notify: 605EA650-C65C-42E1-BA80-91A52AB618C6
Loading PEIM A3610442-E69F-4DF3-82CA-2360C4031A23
Loading PEIM at 0x00000830EC0 EntryPoint=0x00000832377 ReportStatusCodeRouterPei.efi
Install PPI: 0065D394-9951-4144-82A3-0AFC8579C251
Install PPI: 229832D3-7A30-4B36-B827-F40CB7D45436
Loading PEIM 9D225237-FA01-464C-A949-BAABC02D31D0
Loading PEIM at 0x00000833040 EntryPoint=0x000008343E6 StatusCodeHandlerPei.efi
Loading PEIM 222C386D-5ABC-4FB4-B124-FBB82488ACF4
Loading PEIM at 0x000008351C0 EntryPoint=0x0000083CE9E PlatformPei.efi
Platform PEIM Loaded
CMOS:
00: 00 00 03 00 09 00 05 29 06 23 26 02 00 80 00 FE
10: 50 00 00 00 07 80 02 FF FF 00 00 00 00 00 00 00
20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
30: FF FF 20 00 00 7F 00 20 30 00 00 00 00 12 00 00
40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01
60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
QemuFwCfgProbe: Supported 1, DMA 1
Select Item: 0x19
Select Item: 0x29
S3 support was detected on QEMU
BootModeInitialization
2 BootModeInitialization
Install PPI: 7408D748-FC8C-4EE6-9288-C4BEC092A410
Select Item: 0x19
Select Item: 0x19
Select Item: 0x25
Select Item: 0x19
Select Item: 0x19
PlatformAddressWidthFromCpuid: Signature: 'GenuineIntel', PhysBits: 39, QemuQuirk: On, Valid: Yes
PlatformDynamicMmioWindow: using dynamic mmio window
PlatformDynamicMmioWindow:   Addr Space 0x8000000000 (512 GB)
PlatformDynamicMmioWindow:   MMIO Space 0x1000000000 (64 GB)
Select Item: 0x19
Select Item: 0x25
PlatformDynamicMmioWindow:   Pci64 Base 0x7000000000
PlatformDynamicMmioWindow:   Pci64 Size 0x1000000000
Select Item: 0x5
PlatformMaxCpuCountInitialization: BootCpuCount=2 MaxCpuCount=2
Select Item: 0x19
Select Item: 0x25
PlatformGetLowMemoryCB: LowMemory=0x80000000
PeiInstallPeiMemory MemoryBegin 0x7FF70000, MemoryLength 0x90000
Select Item: 0x19
Select Item: 0x25
PlatformQemuInitializeRam called
Select Item: 0x19
Select Item: 0x25
Register PPI Notify: EE16160A-E8BE-47A6-820A-C6900DB0250A
Select Item: 0x19
Select Item: 0x26
Register PPI Notify: EE16160A-E8BE-47A6-820A-C6900DB0250A
Temp Stack : BaseAddress=0x818000 Length=0x8000
Temp Heap  : BaseAddress=0x810000 Length=0x8000
Total temporary memory:    65536 bytes.
  temporary memory stack ever used:       29960 bytes.
  temporary memory heap used for HobList: 6128 bytes.
  temporary memory heap occupied by memory pages: 0 bytes.
Old Stack size 32768, New stack size 131072
Stack Hob: BaseAddress=0x7FF70000 Length=0x20000
Heap Offset = 0x7F780000 Stack Offset = 0x7F770000
TemporaryRamMigration(0x810000, 0x7FF88000, 0x10000)
Reinstall PPI: 8C8CE578-8A3D-4F1C-9935-896185C32DD3
Reinstall PPI: 5473C07A-3DCB-4DCA-BD6F-1E9689E7349A
Reinstall PPI: B9E0ABFE-5979-4914-977F-6DEE78C278A6
Install PPI: F894643D-C449-42D1-8EA8-85BDD8C65BDE
Loading PEIM 86D70125-BAA3-4296-A62F-602BEBBB9081
Loading PEIM at 0x00000842640 EntryPoint=0x00000845B05 DxeIpl.efi
Register PPI Notify: F894643D-C449-42D1-8EA8-85BDD8C65BDE
Install PPI: 0AE8CE5D-E448-4437-A8D7-EBF5F194F731
Notify: PPI Guid: F894643D-C449-42D1-8EA8-85BDD8C65BDE, Peim notify entry point: 843FD6
Install PPI: 1A36E4E7-FAB6-476A-8E75-695A0576FDD7
Loading PEIM 89E549B0-7CFE-449D-9BA3-10D8B2312D71
Loading PEIM at 0x000008472C0 EntryPoint=0x00000849E18 S3Resume2Pei.efi
Install PPI: 6D582DBC-DB85-4514-8FCC-5ADF6227B147
Loading PEIM EDADEB9D-DDBA-48BD-9D22-C1C169C8C5C6
Loading PEIM at 0x0000084BC40 EntryPoint=0x00000851787 CpuMpPei.efi
Register PPI Notify: F894643D-C449-42D1-8EA8-85BDD8C65BDE
Notify: PPI Guid: F894643D-C449-42D1-8EA8-85BDD8C65BDE, Peim notify entry point: 85499C
AP Loop Mode is 1
AP Vector: non-16-bit = 7FFE6000/447
WakeupBufferStart = 9F000, WakeupBufferSize = 1000
AP Vector: 16-bit = 9F000/39, ExchangeInfo = 9F039/A4
CpuMpPei: 5-Level Paging = 0
APIC MODE is 1
MpInitLib: Find 2 processors in system.
GetMicrocodePatchInfoFromHob: Microcode patch cache HOB is not found.
CpuMpPei: 5-Level Paging = 0
CPU[0000]: Microcode revision = 00000000, expected = 00000000
CPU[0001]: Microcode revision = 00000000, expected = 00000000
Register PPI Notify: 8F9D4825-797D-48FC-8471-845025792EF6
Does not find any stored CPU BIST information from PPI!
  APICID - 0x00000000, BIST - 0x00000000
  APICID - 0x00000001, BIST - 0x00000000
Install PPI: 9E9F374B-8F16-4230-9824-5846EE766A97
Install PPI: 5CB9CB3D-31A4-480C-9498-29D269BACFBA
Install PPI: EE16160A-E8BE-47A6-820A-C6900DB0250A
Notify: PPI Guid: EE16160A-E8BE-47A6-820A-C6900DB0250A, Peim notify entry point: 8372F1
PlatformPei: ClearCacheOnMpServicesAvailable
CpuMpPei: 5-Level Paging = 0
Notify: PPI Guid: EE16160A-E8BE-47A6-820A-C6900DB0250A, Peim notify entry point: 838B44
CpuMpPei: 5-Level Paging = 0

DXE IPL Entry

Enter S3 PEIM
AcpiS3Context = 7FB65000
Waking Vector = 9A1F0
AcpiS3Context->AcpiFacsTable = 7FBDD000
AcpiS3Context->IdtrProfile = 7FB64000
AcpiS3Context->S3NvsPageTableAddress = 7FB59000
AcpiS3Context->S3DebugBufferAddress = 7FB50000
AcpiS3Context->BootScriptStackBase = 7FB51000
AcpiS3Context->BootScriptStackSize = 8000
EfiBootScriptExecutorVariable->BootScriptExecutorEntrypoint = 7FB3B49F
S3NvsPageTableAddress - 7FB59000 (1)

S3ResumeExecuteBootScript()
PeiS3ResumeState - 7FF92908
transfer control to Standalone Boot Script Executor

S3BootScriptExecutorEntryFunction
S3BootScriptExecute:
TableHeader - 0x7FB4C000
TableHeader.Version - 0x0001
TableHeader.TableLength - 0x0000001B
ExecuteBootScript - 7FB4C00D
EFI_BOOT_SCRIPT_INFORMATION_OPCODE
BootScriptExecuteInformation - 0x7FB4C014
BootScriptInformation: DE AD BE EF
ExecuteBootScript - 7FB4C018
S3_BOOT_SCRIPT_LIB_TERMINATE_OPCODE
S3BootScriptDone - Success
Call SwitchStack() to return to S3 Resume in PEI Phase

S3ResumeBootOs
Install PPI: 88C9D306-0900-4EB5-8260-3E2DBEDA1F89
Install PPI: 605EA650-C65C-42E1-BA80-91A52AB618C6
Notify: PPI Guid: 605EA650-C65C-42E1-BA80-91A52AB618C6, Peim notify entry point: 82DE4F
Signal EndOfS3Resume
Signal 96F5296D-05F7-4F3C-8467-E456890E0CB5 to SMM - Enter
Locate Smm Communicate Ppi failed (Not Found)!
Transfer to 16bit OS waking vector - 9A1F0
```

# 4. 流程总结

添加 log, 分析 guest 的 code flow

```cpp
state_store() // 入口
 ├─ pm_autosleep_lock() // autosleep 锁
 ├─ decode_state() // 解析状态
 └─ pm_suspend() // 进入流程
     ├─ pr_info("suspend entry (%s)\n", mem_sleep_labels[state]); // PM: suspend entry (deep)
     ├─ enter_state(); //
     |   ├─ trace_suspend_resume(TPS("suspend_enter"), state, true); // trace point
     |   ├─ if valid_state() // 检查平台是否支持, 会调用平台相关的 valid 函数, 对应的是 acpi_suspend_state_valid
     |   |   └─ return sleep_states[acpi_suspend_states[pm_state]];
     |   ├─ mutex_trylock(); // 拿锁
     |   ├─ trace_suspend_resume(TPS("sync_filesystems"), 0, true); // 文件系统 trace point
     |   ├─ ksys_sync_helper(); // 文件系统 sync, 其中会打印 Filesystems sync: 0.444 seconds
     |   ├─ trace_suspend_resume(TPS("sync_filesystems"), 0, false); // 文件系统 trace point
     |   ├─ pm_pr_dbg("Preparing system for sleep (%s)\n", mem_sleep_labels[state]); // debug log, PM: Preparing system for sleep (deep)
     |   ├─ pm_suspend_clear_flags(); //
     |   ├─ suspend_prepare(state); //
     |   |   ├─ pm_prepare_console(); // 切换控制台
     |   |   ├─ pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND); // 发送 PM_SUSPEND_PREPARE 消息
     |   |   ├─ trace_suspend_resume(TPS("freeze_processes"), 0, true); // trace point
     |   |   ├─ suspend_freeze_processes(); // 冻结用户进程以及内核线程
     |   |   |   ├─ freeze_processes();
     |   |   |       ├─
     |   |   ├─ trace_suspend_resume(TPS("freeze_processes"), 0, false); // trace point
     |   |   ├─ // 下面两个调用是失败了调用
     |   |   ├─ pm_notifier_call_chain(PM_POST_SUSPEND); // 通知
     |   |   └─ pm_restore_console(); // 恢复控制台
     |   ├─ if (suspend_test(TEST_FREEZER)) // 如果是 freezer, 则到下面的 Finishing log, 不需要做设备和系统的 suspend
     |   ├─ trace_suspend_resume(TPS("suspend_enter"), state, false); // trace point
     |   ├─ pm_pr_dbg("Suspending system (%s)\n", mem_sleep_labels[state]); // debug log, PM: Suspending system (deep)
     |   ├─ suspend_devices_and_enter(); // 设备和系统的 suspend
     |   |   ├─ if (!sleep_state_supported(state)) // 判断平台是否实现了 suspend_ops 以及 suspend_ops->enter 函数
     |   |   ├─ platform_suspend_begin(state); // 调用 suspend_ops->begin(), acpi 对应的是 acpi_suspend_begin
     |   |   |   ├─ pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_SUSPEND;
     |   |   |   └─ acpi_pm_start(); //
     |   |   |       ├─ acpi_target_sleep_state = acpi_state; // 静态变量, 初始化为 S0, 这里设置为 S3
     |   |   |       ├─ acpi_sleep_tts_switch(acpi_target_sleep_state);
     |   |   |       |   └─ acpi_execute_simple_method(NULL, "\\_TTS", acpi_state); // 执行 _TTS 方法, 遵循 spec 第二步
     |   |   |       └─ acpi_scan_lock_acquire(); // 获取锁
     |   |   ├─ suspend_console(); // 挂起控制台, 打印 printk: Suspending console(s) (use no_console_suspend to debug)
     |   |   ├─ dpm_suspend_start(PMSG_SUSPEND); // 设备 suspend
     |   |   |   ├─ starttime = ktime_get(); // 获取时间
     |   |   |   ├─ dpm_prepare(state); // 执行所有设备的 prepare 回调函数.
     |   |   |   |   ├─ trace_suspend_resume(TPS("dpm_prepare"), state.event, true); // trace point
     |   |   |   |   ├─ while (!list_empty(&dpm_list) && !error) // 遍历所有设备
     |   |   |   |   |   ├─ trace_device_pm_callback_start(dev, "", state.event); // trace point
     |   |   |   |   |   ├─ device_prepare(dev, state); // prepare 函数
     |   |   |   |   |   |   ├─ pm_runtime_get_noresume(dev); // 关闭 Runtime suspend 功能, complete 时被重新打开
     |   |   |   |   |   |   |   ├─ sd_suspend_runtime(); // drivers/scsi/sd.c, 打印 sd 0:0:0:0: [sda] Stopping disk
     |   |   |   |   |   |   ├─ if (dev->power.syscore) // 是 syscore 设备就返回, 会专门处理
     |   |   |   |   |   |   ├─ ->prepare(dev); // 根据优先顺序进行调用
     |   |   |   |   |   |   └─
     |   |   |   |   |   ├─ trace_device_pm_callback_end(dev, error); // trace point
     |   |   |   |   |   ├─ dev->power.is_prepared = true; // 设置已经 prepared
     |   |   |   |   |   └─ list_move_tail(&dev->power.entry, &dpm_prepared_list); // 添加到 dpm_prepared_list 链表
     |   |   |   |   └─ trace_suspend_resume(TPS("dpm_prepare"), state.event, false); // trace point
     |   |   |   ├─ dpm_suspend(); // 执行所有设备的 suspend 回调函数
     |   |   |   |   ├─ trace_suspend_resume(TPS("dpm_suspend"), state.event, true); // trace point
     |   |   |   |   ├─ while (!list_empty(&dpm_list) && !error) // 遍历所有设备
     |   |   |   |   |   ├─ device_suspend(dev); // 调用 __device_suspend, 同样按照优先顺序进行调用

     |   |   |   |   |   └─ list_move(&dev->power.entry, &dpm_suspended_list); // 添加到 dpm_suspended_list 链表
     |   |   |   |   ├─ dpm_show_time(starttime, state, error, NULL); // 会打印 PM: suspend of devices complete after XXX msecs
     |   |   |   |   └─ trace_suspend_resume(TPS("dpm_suspend"), state.event, false); // trace point
     |   |   |   └─ dpm_show_time(starttime, state, error, "start"); // 会打印 PM: start suspend of devices complete after XXX msecs
     |   |   ├─ suspend_test_finish("suspend devices");
     |   |   ├─ suspend_enter(state, &wakeup); // 系统进入 suspend
     |   |   |   ├─ platform_suspend_prepare(); // 调用平台相关 prepare 回调函数, suspend_ops->prepare(), acpi 没有对应函数
     |   |   |   ├─ dpm_suspend_late(); // 调用所有设备的 suspend_late 回调, 并加入一个链表, 打印 PM: late suspend of devices complete after
     |   |   |   ├─ platform_suspend_prepare_late(); // freeze(S2) 则调用 freeze_ops 中的 prepare 回调
     |   |   |   ├─ dpm_suspend_noirq(PMSG_SUSPEND); // disable 所有设备的 irq,
     |   |   |   ├─ platform_suspend_prepare_noirq(state); // 回调 suspend_ops->prepare_late(), acpi 对应是 acpi_pm_prepare()
     |   |   |   |   ├─ __acpi_pm_prepare(); // 平台准备进入 S3 并且 disable GPEs
     |   |   |   |   |   └─ acpi_sleep_prepare(acpi_target_sleep_state); //
     |   |   |   |   |       ├─ acpi_wakeup_address = acpi_get_wakeup_address(); // 0x991f0
     |   |   |   |   |       |   └─ return ((unsigned long)(real_mode_header->wakeup_start)); // 定义在 arch/x86/realmode/rm/wakeup_asm.S 中
     |   |   |   |   |       ├─ acpi_set_waking_vector(acpi_wakeup_address); // 写 waking vector 到 FACS 表, spec 第七步, 这里只是写了 memory, 并不会直接到物理
     |   |   |   |   |       ├─ pr_info("Preparing to enter system sleep state S%d\n", acpi_state); // 打印 ACPI: PM: Preparing to enter system sleep state S3
     |   |   |   |   |       ├─ acpi_enable_wakeup_devices(acpi_state); // 使能可唤醒设备的 GPEs 寄存器
     |   |   |   |   |       |   └─ list_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list, wakeup_list) // 遍历 acpi_wakeup_device_list 链表(所有可唤醒设备, 初始化时候构建, 涉及 _PRW, drivers/acpi/scan.c, 遵循 spec 第三步)
     |   |   |   |   |       |       ├─ if (device_may_wakeup(&dev->dev)) // 判断当前设备是否具有唤醒系统的功能(是否有 wakeup source 以及是否允许 wakeup), 遵循 spec 第三步. 如果是, 就调用下面函数
     |   |   |   |   |       |       |   └─ acpi_enable_wakeup_device_power(dev, sleep_state); // 准备一个可唤醒的设备, 按照 spec 规定, 涉及两步
     |   |   |   |   |       |       |       ├─ dev_dbg(&dev->dev, "Enabling wakeup power (count %d)\n", dev->wakeup.prepare_count); // debug log
     |   |   |   |   |       |       |       ├─ acpi_power_on_list(&dev->wakeup.resources); // 打开 wakeup power resource
     |   |   |   |   |       |       |       ├─ acpi_device_sleep_wake(dev, 1, sleep_state, 3); // 为设备执行 _DSW(Device Sleep Wake) 或者 _PSW(Power State Wake, ACPI 3.0 弃用)
     |   |   |   |   |       |       |       ├─
     |   |   |   |   |       |       |       └─ dev_dbg(&dev->dev, "Wakeup power enabled\n"); // debug log
     |   |   |   |   |       |       └─ acpi_set_gpe_wake_mask(); // 设置 GPE wakeup bit
     |   |   |   |   |       └─ acpi_enter_sleep_state_prep(acpi_state); // 准备进入
     |   |   |   |   |           ├─ ACPI_FUNCTION_TRACE(acpi_enter_sleep_state_prep); // trace point
     |   |   |   |   |           ├─
     |   |   |   |   |           ├─ acpi_evaluate_object(NULL, METHOD_PATHNAME__PTS, &arg_list, NULL); // 执行 _PTS 方法, 遵循 spec 第五步
     |   |   |   |   |           └─ acpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, sst_value); // 执行 _SST 方法
     |   |   |   |   └─ acpi_pm_pre_suspend(); // 使能 wakeup 设备
     |   |   |   |       ├─ acpi_pm_freeze(); // disable 所有 GPEs 和 suspend EC transactions
     |   |   |   |       |   ├─ acpi_disable_all_gpes(); // disable 所有的 gpe
     |   |   |   |       |   ├─ acpi_os_wait_events_complete();
     |   |   |   |       |   └─ acpi_ec_block_transactions();
     |   |   |   |       └─ suspend_nvs_save(); // 保存 NVS memory region
     |   |   |   |           ├─ pr_info("Saving platform NVS memory\n"); // 打印 ACPI: PM: Saving platform NVS memory
     |   |   |   |           └─ list_for_each_entry(entry, &nvs_list, node) // 遍历 nvs
     |   |   |   ├─ pm_sleep_disable_secondary_cpus(); // disable 所有 nonboot 的 CPU
     |   |   |   ├─ arch_suspend_disable_irqs(); // 关闭全局中断
     |   |   |   ├─ system_state = SYSTEM_SUSPEND; // 设置 suspend 状态
     |   |   |   ├─ syscore_suspend(); // system core 的 suspend 回调函数
     |   |   |   ├─ suspend_ops->enter(); // 对应的是 acpi_suspend_enter
     |   |   |   |   ├─ trace_suspend_resume(TPS("acpi_suspend"), acpi_state, true); // trace point
     |   |   |   |   ├─ acpi_suspend_lowlevel(); // x86 对应的是 x86_acpi_suspend_lowlevel, 保存 kernel 状态, 会创建页表并拷贝 wakeup 例程到 low memory
     |   |   |   |   |   ├─ struct wakeup_header *header = (struct wakeup_header *) __va(real_mode_header->wakeup_header); // 实模式的 wakup_header
     |   |   |   |   |   ├─ header->pmode_cr4 = __read_cr4();
     |   |   |   |   |   ├─ ...
     |   |   |   |   |   ├─ header->realmode_flags = acpi_realmode_flags;
     |   |   |   |   |   ├─ header->real_magic = 0x12345678;
     |   |   |   |   |   ├─ current->thread.sp = (unsigned long)temp_stack + sizeof(temp_stack); // cpu 自己的 stack pointer
     |   |   |   |   |   ├─ initial_code = (unsigned long)wakeup_long64;
     |   |   |   |   |   ├─ saved_magic = 0x123456789abcdef0L;
     |   |   |   |   |   ├─ pause_graph_tracing();
     |   |   |   |   |   ├─ do_suspend_lowlevel(); // 对应汇编代码, 保存 CPU 上下文, 对应 spec 第九步
     |   |   |   |   |   |   ├─ subq $8, %rsp // 栈顶减去 8 字节, 在栈上分配了 8 字节空间
     |   |   |   |   |   |   ├─ call save_processor_state // 会保存当前 cpu 上下文到 saved_context
     |   |   |   |   |   |   ├─ movq $saved_context, %rax // 保存 saved_context 值到 rax 寄存器值
     |   |   |   |   |   |   ├─ movq %rsp, pt_regs_sp(%rax) // 保存 rsp 寄存器值到 saved_context 中
     |   |   |   |   |   |   ├─ ...
     |   |   |   |   |   |   ├─ movq %r15, pt_regs_r15(%rax) // 保存 r15 寄存器到 saved_context 中
     |   |   |   |   |   |   ├─ pushfq // 将 RFLAGS 压栈
     |   |   |   |   |   |   ├─ popq pt_regs_flags(%rax) // 将 RFLAGS 出栈并保存到 saved_context 中
     |   |   |   |   |   |   ├─ movq $.Lresume_point, saved_rip(%rip) // 将 .Lresume_point 保存到 rip, 恢复会从 Lresume_point 开始
     |   |   |   |   |   |   ├─ movq %rsp, saved_rsp // 保存 rsp 寄存器为 saved_rsp
     |   |   |   |   |   |   ├─ addq $8, %rsp // 恢复栈顶
     |   |   |   |   |   |   ├─ call x86_acpi_enter_sleep_state // 调用 acpi_enter_sleep_state(state);
     |   |   |   |   |   |   |   └─ acpi_hw_legacy_sleep(); // 对于非 HW-reduced, x86
     |   |   |   |   |   |   |       ├─ ACPI_FUNCTION_TRACE(hw_legacy_sleep);
     |   |   |   |   |   |   |       ├─ acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);; // 清理 WAK_STS, 遵循 spec 第八步
     |   |   |   |   |   |   |       ├─ acpi_hw_disable_all_gpes(); // disable 所有 GPEs
     |   |   |   |   |   |   |       ├─ acpi_hw_clear_acpi_status(); //
     |   |   |   |   |   |   |       ├─ acpi_hw_enable_all_wakeup_gpes(); // 启用所有的 wakeup GPEs, 遵循 spec 第十一步
     |   |   |   |   |   |   |       ├─ acpi_hw_register_read(ACPI_REGISTER_PM1_CONTROL, &pm1a_control); // 获取当前 PM1A control 的值
     |   |   |   |   |   |   |       ├─ ACPI_DEBUG_PRINT((ACPI_DB_INIT, "Entering sleep state [S%u]\n", sleep_state)); // debug log, 打印
     |   |   |   |   |   |   |       ├─ pm1a_control &= ~(sleep_type_reg_info->access_bit_mask | sleep_enable_reg_info->access_bit_mask); // 清理 SLP_EN 和 SLP_TYP 字段
     |   |   |   |   |   |   |       ├─ pm1b_control = pm1a_control;
     |   |   |   |   |   |   |       ├─ pm1a_control |= (acpi_gbl_sleep_type_a << sleep_type_reg_info->bit_position); // 插入 SLP_TYP bits
     |   |   |   |   |   |   |       ├─ pm1b_control |= (acpi_gbl_sleep_type_b << sleep_type_reg_info->bit_position); // 插入 SLP_TYP bits
     |   |   |   |   |   |   |       ├─ acpi_hw_write_pm1_control(pm1a_control, pm1b_control); // 写 SLP_TYP 字段到 PM1 Control 寄存器,  遵循 spec 第十三和十四步
     |   |   |   |   |   |   |       ├─ pm1a_control |= sleep_enable_reg_info->access_bit_mask;
     |   |   |   |   |   |   |       ├─ pm1b_control |= sleep_enable_reg_info->access_bit_mask;
     |   |   |   |   |   |   |       ├─ ACPI_FLUSH_CPU_CACHE(); // 刷新 cache, 遵循 spec 第十步
     |   |   |   |   |   |   |       ├─ acpi_os_enter_sleep(sleep_state, pm1a_control, pm1b_control); //
     |   |   |   |   |   |   |       |   ├─ acpi_os_prepare_sleep() 对于非 HW-reduced

     |   |   |   |   |   |   |       |   └─ acpi_os_prepare_extended_sleep() 对于 HW-reduced
     |   |   |   |   |   |   |       ├─ acpi_hw_write_pm1_control(pm1a_control, pm1b_control); // 写 SLP_TYP 和 SLP_EN, 遵循 spec 第十三和十四步
     |   |   |   |   |   |   |       └─ do{ }while(!in_value) // 一直循环直到 WAK_STS 是 1; 当系统处于睡眠状态并发生启用唤醒事件时, 将设置此位. 设置此位后, 系统将过渡到工作状态. 此位由硬件设置, 只能通过软件在此位位置写入“1”来清除. 对应 spec 第十六步
     |   |   |   |   |   |   |           └─ acpi_read_bit_register(ACPI_BITREG_WAKE_STATUS, &in_value); // 读取 Sleep Status Register
     |   |   |   |   |   |   |   └─ acpi_hw_extended_sleep(); // 对于 HW-reduced, ARM 平台
     |   |   |   |   |   |   |       ├─ ACPI_FUNCTION_TRACE(hw_extended_sleep); // trace point
     |   |   |   |   |   |   |       ├─ acpi_write((u64)ACPI_X_WAKE_STATUS, &acpi_gbl_FADT.sleep_status); // 清理 WAK_STS, 遵循 spec 第八步
     |   |   |   |   |   |   |       ├─ ACPI_DEBUG_PRINT((ACPI_DB_INIT, "Entering sleep state [S%u]\n", sleep_state)); // debug log, 打印
     |   |   |   |   |   |   |       ├─ sleep_control = ((acpi_gbl_sleep_type_a << ACPI_X_SLEEP_TYPE_POSITION) & ACPI_X_SLEEP_TYPE_MASK) | ACPI_X_SLEEP_ENABLE; // 设置 SLP_TYP 和 SLP_EN
     |   |   |   |   |   |   |       ├─ ACPI_FLUSH_CPU_CACHE(); // 刷新 cache, 遵循 spec 第十步
     |   |   |   |   |   |   |       ├─ acpi_os_enter_sleep(sleep_state, sleep_control, 0); // 遵循 spec 第十五步?
     |   |   |   |   |   |   |       ├─ acpi_write((u64)sleep_control, &acpi_gbl_FADT.sleep_control); // 设置 SLP_TYP 和 SLP_EN, 遵循 spec 第十三和十四步
     |   |   |   |   |   |   |       └─ do{ }while(!(((u8)sleep_status) & ACPI_X_WAKE_STATUS)) // 一直循环直到 WAK_STS 是 1; 当系统处于睡眠状态并发生启用唤醒事件时, 将设置此位. 设置此位后, 系统将过渡到工作状态. 此位由硬件设置, 只能通过软件在此位位置写入“1”来清除. 对应 spec 第十六步
     |   |   |   |   |   |   |           └─ acpi_read(&sleep_status, &acpi_gbl_FADT.sleep_status); // 读取 Sleep Status Register
     |   |   |   |   |   |   └─ jmp	.Lresume_point // 后面全都是 resume 流程了
     |   |   |   |   |   |       ├─ movq $saved_context, %rax // 保存 saved_context 值到 rax 寄存器值
     |   |   |   |   |   |       ├─ movq saved_context_cr3(%rax), %rbx
     |   |   |   |   |   |       ├─ movq %rbx, %cr3 // 恢复 cr3 寄存器
     |   |   |   |   |   |       ├─ pushq pt_regs_flags(%rax) //
     |   |   |   |   |   |       ├─
     |   |   |   |   |   |       └─ jmp restore_processor_state // 恢复 cpu 上下文
     |   |   |   |   |   └─ unpause_graph_tracing(); //
     |   |   |   |   ├─ pr_info("Low-level resume complete\n"); // 打印 ACPI: PM: Low-level resume complete
     |   |   |   |   ├─ pm_set_resume_via_firmware(); //
     |   |   |   |   |   └─ pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_RESUME;
     |   |   |   |   ├─ trace_suspend_resume(TPS("acpi_suspend"), acpi_state, false); // trace point
     |   |   |   |   ├─ acpi_leave_sleep_state_prep(acpi_state); //
     |   |   |   |   |   ├─ ACPI_FUNCTION_TRACE(hw_extended_wake_prep);
     |   |   |   |   |   ├─
     |   |   |   |   |   ├─
     |   |   |   |   ├─ acpi_clear_event(ACPI_EVENT_POWER_BUTTON); // OSPM 清理 POWER_BUTTON
     |   |   |   |   ├─ acpi_disable_all_gpes(); // disable 所有的 gpe
     |   |   |   |   ├─ acpi_ec_unblock_transactions(); //
     |   |   |   |   └─ suspend_nvs_restore(); // 打印 ACPI: PM: Restoring platform NVS memory
     |   |   |   ├─ syscore_resume(); // system core 的 resume
     |   |   |   ├─ system_state = SYSTEM_RUNNING; // 设置 running 状态
     |   |   |   ├─ arch_suspend_enable_irqs(); // 打开 irq
     |   |   |   ├─ pm_sleep_enable_secondary_cpus(); // up non-boot CPU
     |   |   |   ├─ platform_resume_noirq(); // 平台 resume, 调用 suspend_ops->wake(), acpi 对应是 acpi_pm_finish
     |   |   |   |   ├─ pr_info("Waking up from system sleep state S%d\n", acpi_state); // 打印 ACPI: PM: Waking up from system sleep state S3
     |   |   |   |   ├─ acpi_disable_wakeup_devices(acpi_state); //
     |   |   |   |   ├─ acpi_leave_sleep_state(acpi_state);
     |   |   |   |   |   ├─ ACPI_FUNCTION_TRACE(acpi_leave_sleep_state); // trace point
     |   |   |   |   |   ├─ acpi_hw_legacy_wake(sleep_state); // 非 HW-reduced
     |   |   |   |   |   |   ├─ ACPI_FUNCTION_TRACE(hw_legacy_wake);
     |   |   |   |   |   |   ├─ acpi_hw_disable_all_gpes(); // disable 所有 GPEs
     |   |   |   |   |   |   ├─ acpi_hw_enable_all_runtime_gpes(); // enable 所有 runtime GPEs
     |   |   |   |   |   |   ├─ acpi_hw_execute_sleep_method(METHOD_PATHNAME__WAK, sleep_state); // 执行 _WAK 方法
     |   |   |   |   |   |   ├─
     |   |   |   |   |   |   ├─
     |   |   |   |   |   |   ├─
     |   |   |   |   |   |   └─ acpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, ACPI_SST_WORKING); // 执行 _SST 方法
     |   |   |   |   |   └─ acpi_hw_extended_wake(sleep_state); // HW-reduced
     |   |   |   |   ├─ acpi_set_waking_vector(0); // reset waking vector
     |   |   |   |   ├─ acpi_target_sleep_state = ACPI_STATE_S0; // acpi sleep 状态设成 S0
     |   |   |   |   ├─ acpi_resume_power_resources(); //
     |   |   |   |   ├─
     |   |   |   ├─ dpm_resume_noirq(); // 设备 resume
     |   |   |   ├─ platform_resume_early();
     |   |   |   ├─ dpm_resume_early();
     |   |   |   └─ platform_resume_finish(); // 调用 suspend_ops->finish(), acpi 没有对应方法
     |   |   |       ├─
     |   |   |       ├─
     |   |   |       ├─
     |   |   ├─ dpm_resume_end(PMSG_RESUME); // 设备 resume
     |   |   ├─ suspend_test_finish("resume devices"); //
     |   |   ├─ trace_suspend_resume(TPS("resume_console"), state, true); // resume 的 trace point
     |   |   ├─ resume_console(); // console resume
     |   |   ├─ trace_suspend_resume(TPS("resume_console"), state, false); // resume 的 trace point
     |   |   ├─ platform_resume_end(state); // 平台 resume, suspend_ops->end(), 对应的是 acpi_pm_end()
     |   |   |   ├─ acpi_turn_off_unused_power_resources(); //
     |   |   |   ├─ acpi_scan_lock_release();
     |   |   |   ├─ acpi_target_sleep_state = ACPI_STATE_S0; // S0 状态
     |   |   |   └─  acpi_sleep_tts_switch(acpi_target_sleep_state); // 调用 _TTS(0)
     |   |   └─ pm_suspend_target_state = PM_SUSPEND_ON; // 设置状态
     |   ├─ pm_pr_dbg("Finishing wakeup.\n"); // debug log, 已经 wakeup, PM: Finishing wakeup.
     |   └─ suspend_finish();
     └─ pr_info("suspend exit\n"); // PM: suspend exit
```

用一张图来总结 Suspend 的流程:

![2023-06-21-10-07-13.png](./images/2023-06-21-10-07-13.png)

![2023-07-12-22-53-25.png](./images/2023-07-12-22-53-25.png)

HW-reduced platform 是 ARM 上的, x86 不适用. 通过查看系统 FACP table 也能得到

```
cat /sys/firmware/acpi/tables/FACP > /home/acrn/acrn-work/FACP.aml

iasl -d FACP.aml

cat FACP.dsl
    ......
    Hardware Reduced (V5) : 0
```

# 5. 系统初始化

在 OS 初始化时候 `acpi_sleep_init()`:

* `acpi_sleep_suspend_setup()`, 设置了 ops

* `pr_info("(supports%s)\n", supported);`, 打印的日志是 `ACPI: PM: (supports S0 S3 S4 S5)`

```cpp
// drivers/acpi/sleep.c
static void acpi_sleep_suspend_setup(void)
{
    bool suspend_ops_needed = false;
    int i;

    for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++)
        if (acpi_sleep_state_supported(i)) {
            sleep_states[i] = 1;
            suspend_ops_needed = true;
        }

    if (suspend_ops_needed)
        suspend_set_ops(old_suspend_ordering ?
                &acpi_suspend_ops_old : &acpi_suspend_ops);

    acpi_s2idle_setup();
}

static const struct platform_suspend_ops acpi_suspend_ops = {
    .valid = acpi_suspend_state_valid,
    .begin = acpi_suspend_begin,
    .prepare_late = acpi_pm_prepare,
    .enter = acpi_suspend_enter,
    .wake = acpi_pm_finish,
    .end = acpi_pm_end,
};

// drivers/acpi/sleep.c
static void acpi_pm_finish(void)
{
    pr_info("Waking up from system sleep state S%d\n", acpi_state);

    /* reset firmware waking vector */
    acpi_set_waking_vector(0);
}
```

# 6. suspend 入口

执行如下命令:

```
echo freeze > /sys/power/state

echo standby > /sys/power/state

echo mem > /sys/power/state
```

根据 sys 节点的属性命令规则, 可以得到此节点的实现代码为:  `state_store`

## 6.1. state_store 函数分析

```cpp
// kernel/power/power.h
#define power_attr(_name) \
static struct kobj_attribute _name##_attr = {   \
    .attr   = {                             \
        .name = __stringify(_name),         \
        .mode = 0644,                       \
    },                                      \
    .show   = _name##_show,                 \
    .store  = _name##_store,                \
}

power_attr(state);
```

power_attr 定义了一个名称为 state 的 attribute 文件, 该文件的 store 接口为 state_store, 该接口在 lock 住 autosleep 功能后, 解析用户传入的 buffer（freeze、standby or mem）, 转换成 state 参数.

```cpp
// kernel/power/main.c
static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
                           const char *buf, size_t n)
{
    suspend_state_t state;
    int error;
    // 第一
    error = pm_autosleep_lock();
    if (error)
        return error;
    // 第二
    if (pm_autosleep_state() > PM_SUSPEND_ON) {
        error = -EBUSY;
        goto out;
    }
    // 第三
    state = decode_state(buf, n);
    if (state < PM_SUSPEND_MAX) {
        if (state == PM_SUSPEND_MEM)
                state = mem_sleep_current;

        error = pm_suspend(state);
    } else if (state == PM_SUSPEND_MAX) {
        error = hibernate();
    } else {
        error = -EINVAL;
    }
    ...
}
```

第一. `pm_autosleep_lock`

```cpp
// kernel/power/autosleep.c
int pm_autosleep_lock(void)
{
    return mutex_lock_interruptible(&autosleep_lock);
}
```

获得 autosleep 锁, **锁住 autosleep 功能**, 此功能在后面分析

第二. 判断**当前 autosleep 的状态**, 如果当前状态大于 `PM_SUSPEND_ON`, 则返回退出. 关于 suspend 的状态如下:

```cpp
// include/linux/suspend.h
#define PM_SUSPEND_ON           ((__force suspend_state_t) 0)
#define PM_SUSPEND_TO_IDLE      ((__force suspend_state_t) 1)
#define PM_SUSPEND_STANDBY      ((__force suspend_state_t) 2)
#define PM_SUSPEND_MEM          ((__force suspend_state_t) 3)
#define PM_SUSPEND_MIN          PM_SUSPEND_TO_IDLE
#define PM_SUSPEND_MAX          ((__force suspend_state_t) 4)
```

第三. 解析当前传入的 state. 如果 state 小于 `PM_SUSPEND_MAX` 就走 suspend 流程, 等于 `PM_SUSPEND_MAX` 就走 hibernate 流程. 我们传入的是 mem, 则就会走 **suspend** 流程.

## 6.2. pm_suspend 函数分析

```cpp
// kernel/power/suspend.c
int pm_suspend(suspend_state_t state)
{
    int error;
    // 第一
    if (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)
        return -EINVAL;
    // 打印
    pr_info("suspend entry (%s)\n", mem_sleep_labels[state]);
    // 第三
    error = enter_state(state);
    if (error) {
        suspend_stats.fail++;
        dpm_save_failed_errno(error);
    } else {
        suspend_stats.success++;
    }
    // 打印
    pr_info("suspend exit\n");
    return error;
}
EXPORT_SYMBOL(pm_suspend);
```

第一. 依然会再次判断**当前的 state** 是否在 `PM_SUSPEND_ON` 和 `PM_SUSPEND_MAX` 之间

第二. pm_suspend_marker("entry")

```cpp

```

在 suspend 之间记录时间, 用于统计或者调试 suspend 花费的时间.

第三. 调用 `enter_state` 进入 suspend 的下一步, 如果**执行 suspend 成功**, 增加 `suspend_stats.success` 的**引用计数**, 否则增加 `suspend_stats.fail` 的引用计数.

## 6.3. enter_state 函数分析

```cpp
static int enter_state(suspend_state_t state)
{
    int error;
    // trace point
    trace_suspend_resume(TPS("suspend_enter"), state, true);
    if (state == PM_SUSPEND_TO_IDLE) {
#ifdef CONFIG_PM_DEBUG
        if (pm_test_level != TEST_NONE && pm_test_level <= TEST_CPUS) {
            pr_warn("Unsupported test mode for suspend to idle, please choose none/freezer/devices/platform.\n");
            return -EAGAIN;
        }
#endif
    // 第一
    } else if (!valid_state(state)) {
        return -EINVAL;
    }
    // 第二
    if (!mutex_trylock(&system_transition_mutex))
        return -EBUSY;
    // 第三
    if (state == PM_SUSPEND_TO_IDLE)
        s2idle_begin();
    // 第四
    if (sync_on_suspend_enabled) {
        // trace point
        trace_suspend_resume(TPS("sync_filesystems"), 0, true);
        ksys_sync_helper();
        // trace point
        trace_suspend_resume(TPS("sync_filesystems"), 0, false);
    }
    // debug log
    pm_pr_dbg("Preparing system for sleep (%s)\n", mem_sleep_labels[state]);
    pm_suspend_clear_flags();
    // 第五
    error = suspend_prepare(state);
    if (error)
        goto Unlock;
    // 如果是 freezer, 则完成, 不需要做设备和系统的 suspend
    if (suspend_test(TEST_FREEZER))
        goto Finish;
    // trace point
    trace_suspend_resume(TPS("suspend_enter"), state, false);
    // debug log
    pm_pr_dbg("Suspending system (%s)\n", mem_sleep_labels[state]);
    pm_restrict_gfp_mask();
    // 第六
    error = suspend_devices_and_enter(state);
    pm_restore_gfp_mask();

Finish:
    events_check_enabled = false;
    // debug log, 已经 resume 了
    pm_pr_dbg("Finishing wakeup.\n");
    // 第七, 恢复 resume
    suspend_finish();
Unlock:
    mutex_unlock(&system_transition_mutex);
    return error;
}
```

第一. 通过 `valid_state` 函数用来判断**该平台是否支持该状态睡眠**.

```cpp
static bool valid_state(suspend_state_t state)
{
    return suspend_ops && suspend_ops->valid && suspend_ops->valid(state) &&
        suspend_ops->enter;
}
```

第二. 调用 `mutex_trylock` 获得一个 system_transition_mutex mutex 锁, 防止在 suspend 的时候系统状态发生转换.

第三. 如果当前 state 是 `PM_SUSPEND_TO_IDLE`, 则调用 `s2idle_begin` 做开始准备工作(S2).

第四. **同步文件系统**.

第五. 调用 `suspend_prepare` 做进一步 suspend 前期准备工作, **准备控制台**, **冻结内核线程**等.

第六. 调用 `suspend_devices_and_enter` 做**设备**以及**系统**相关的 `susupend` 操作.

第七. 调用 `suspend_finish` 做最后的**恢复工作**.

# 7. suspend_prepare 函数分析

```cpp
static int suspend_prepare(suspend_state_t state)
{
    int error;
    // 第一
    if (!sleep_state_supported(state))
            return -EPERM;
    // 第二, 切换控制台
    pm_prepare_console();
    // 第三
    error = pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND);
    if (error)
            goto Restore;
    // trace point
    trace_suspend_resume(TPS("freeze_processes"), 0, true);
    // 第四
    error = suspend_freeze_processes();
    // trace point
    trace_suspend_resume(TPS("freeze_processes"), 0, false);
    if (!error)
            return 0;
    // 下面的开始失败
    // 冻结失败?
    suspend_stats.failed_freeze++;
    dpm_save_failed_step(SUSPEND_FREEZE);
    // 第五
    pm_notifier_call_chain(PM_POST_SUSPEND);
Restore:
    pm_restore_console();
    return error;
}
```

第一. 检测该平台 suspend_ops 是否实现了 enter 函数.

```cpp
static bool sleep_state_supported(suspend_state_t state)
{
    // S2?
    return state == PM_SUSPEND_TO_IDLE ||
    (valid_state(state) && !cxl_mem_active());
}
```

第二. 调用 `pm_prepare_console` 函数**切换控制台**, 重新分配一个 **suspend 模式下控制台**(虚拟 console), 然后**重定向内核的 kmsg**. 该功能称作 VT switch.

第三. 通过调用 **pm 通知链**, 发送 `PM_SUSPEND_PREPARE` 消息.

```cpp
int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)
{
    int ret;

    ret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);

    return notifier_to_errno(ret);
}
```

那谁会收到这类消息呢?  只有通过 `register_pm_notifier` 的**设备**, 子系统会在这个时候**处理自己的事情**.

```cpp
int register_pm_notifier(struct notifier_block *nb)
{
    return blocking_notifier_chain_register(&pm_chain_head, nb);
}
EXPORT_SYMBOL_GPL(register_pm_notifier);
```

第四. 调用 `suspend_freeze_processes` **冻结** 用户空间进程, 以及**内核线程**. 该功能称为 `freezing-of-tasks`. 如果冻结出现失败, **记录失败的引用计数**.

第五. 如果失败, 通过**通知链**恢复 suspend, 以及**恢复控制台**.

# 8. suspend_devices_and_enter 函数分析

```cpp
int suspend_devices_and_enter(suspend_state_t state)
{
    int error;
    bool wakeup = false;
    // 第一
    if (!sleep_state_supported(state))
        return -ENOSYS;

    pm_suspend_target_state = state;

    if (state == PM_SUSPEND_TO_IDLE)
        pm_set_suspend_no_platform();
    // 第二
    error = platform_suspend_begin(state);
    if (error)
        goto Close;
    // 第三
    suspend_console();
    // 第四
    suspend_test_start();
    // 第五
    error = dpm_suspend_start(PMSG_SUSPEND);
    if (error) {
        // 设备 suspend 失败, 打印 log
        pr_err("Some devices failed to suspend, or early wake event detected\n");
        // 平台 recover
        goto Recover_platform;
    }
    suspend_test_finish("suspend devices");
    if (suspend_test(TEST_DEVICES))
        goto Recover_platform;

    // 第六
    do {
        error = suspend_enter(state, &wakeup);
    } while (!error && !wakeup && platform_suspend_again(state));
    // 后面是 resume 了
Resume_devices:
    // 时间
    suspend_test_start();
    dpm_resume_end(PMSG_RESUME);
    suspend_test_finish("resume devices");
    // trace point
    trace_suspend_resume(TPS("resume_console"), state, true);
    // resume console
    resume_console();
    // trace point
    trace_suspend_resume(TPS("resume_console"), state, false);

Close:
    // 平台 resume
    platform_resume_end(state);
    // 设置状态
    pm_suspend_target_state = PM_SUSPEND_ON;
    return error;

Recover_platform:
    platform_recover(state);
    goto Resume_devices;
}
```

第一. 调用 `sleep_state_supported` 函数再次**判断**当前平台是否实现了 `suspend_ops`, 以及 `suspend_ops->enter` 函数.

第二. 如果当前状态是 `freeze`, 就调用 `freeze_ops` 的 begin 函数. **否则**就调用**平台相关**的 begin 函数. 这里的 begin 主要是各个平台 pm 的一些设置, 每个平台的操作都不一样, 这里不详细说明.

```cpp
static int platform_suspend_begin(suspend_state_t state)
{
    // S2 即 freeze?
    if (state == PM_SUSPEND_TO_IDLE && s2idle_ops && s2idle_ops->begin)
        return s2idle_ops->begin();
    else if (suspend_ops && suspend_ops->begin)
        return suspend_ops->begin(state);
    else
        return 0;
}
```

第三. 调用 `suspend_console` **挂起控制台**, 主要是 hold 住一个 lock, 该 lock 会阻止其它代码访问 console.

第四. 调用 `suspend_test_start` 记录当前 suspend 刚开始的**时候的时间**, 使用 `jiffies` 表示.

第五. 调用 `dpm_suspend_start` 函数, 该函数主要是调用**所有设备**的 `prepare` 和 `suspend` 回调函数. 如果出现 suspend **失败**, 则会打印 "`fail suspend`" 的 log, 以及调用 `platform_recover` 函数执行**平台相关**的 **recover 回调**.

第六. 调用 `suspend_enter` 使整个系统进入 suspend 状态.

## 8.1. dpm_suspend_start 函数分析

```cpp
// drivers/base/power/main.c
int dpm_suspend_start(pm_message_t state)
{
    ktime_t starttime = ktime_get();
    int error;
    // 第一
    error = dpm_prepare(state);
    if (error) {
            suspend_stats.failed_prepare++;
            dpm_save_failed_step(SUSPEND_PREPARE);
    } else
            error = dpm_suspend(state);
    dpm_show_time(starttime, state, error, "start");
    return error;
}
EXPORT_SYMBOL_GPL(dpm_suspend_start);
```

dpm: device power management

第一. 调用 `dpm_prepare` 函数, 执行**所有设备**(`dpm_list` 链表中) 的 `prepare` 回调函数. 由于设备模型有 bus、driver、device 等多个层级, 而 prepare 接口可能由任意一个层级实现. 所以优先执行顺序是 `dev->pm_domain->ops, dev->type->pm, dev->class->pm, dev->bus->pm, dev->driver->pm`. 如果执行成功, 将该设备添加到 `dpm_prepared_list` 中; 如果**失败**设置 `failed_prepare` 的**引用计数值**.

> 设备模型在添加设备（`device_add`）时, 会调用 `device_pm_add` 接口, 将该设备添加到全局链表 `dpm_list` 中, 以方便后续的遍历操作

第二. 调用 `dpm_suspend` 函数, 执行**所有设备**的 `suspend` 回调函数. 将设备从 `dpm_prepared_list` 链表, 转移到 `dpm_suspended_list` 链表中.

## 8.2. suspend_enter 函数分析

上面对 dpm_suspend_start 函数进行了分析, 该函数中主要是调用**所有设备**的 prepare 和 suspend 回调函数. 而在 `suspend_enter` 主要是使**系统**进入到 suspend 中.

```cpp
static int suspend_enter(suspend_state_t state, bool *wakeup)
{
    int error;
    // 第一
    error = platform_suspend_prepare(state);
    if (error)
        goto Platform_finish;
    // 第二
    error = dpm_suspend_late(PMSG_SUSPEND);
    if (error) {
        pr_err("late suspend of devices failed\n");
        goto Platform_finish;
    }
    // 第三
    error = platform_suspend_prepare_late(state);
    if (error)
        goto Devices_early_resume;
    // 第四
    error = dpm_suspend_noirq(PMSG_SUSPEND);
    if (error) {
        pr_err("noirq suspend of devices failed\n");
        goto Platform_early_resume;
    }
    // 第五
    error = platform_suspend_prepare_noirq(state);
    if (error)
        goto Platform_wake;

    if (suspend_test(TEST_PLATFORM))
        goto Platform_wake;
    // 第六, 针对 freeze(S2) 的 sleep
    if (state == PM_SUSPEND_TO_IDLE) {
        s2idle_loop();
        goto Platform_wake;
    }
    // 第七
    error = pm_sleep_disable_secondary_cpus();
    if (error || suspend_test(TEST_CPUS))
        // 失败后启动 cpu
        goto Enable_cpus;
    // 第八
    arch_suspend_disable_irqs();
    BUG_ON(!irqs_disabled());
    // 设置系统状态
    system_state = SYSTEM_SUSPEND;
    // 第九, system core 的 suspend
    error = syscore_suspend();
    if (!error) {
        // 第十
        *wakeup = pm_wakeup_pending();
        if (!(suspend_test(TEST_CORE) || *wakeup)) {
            // trace point
            trace_suspend_resume(TPS("machine_suspend"),
                    state, true);
            // 第十一, 系统 suspend
            error = suspend_ops->enter(state);
            // trace point
            trace_suspend_resume(TPS("machine_suspend"),
                    state, false);
        } else if (*wakeup) {
            error = -EBUSY;
        }
        // 开始 resume
        syscore_resume();
    }
    // 设置为 running
    system_state = SYSTEM_RUNNING;

    arch_suspend_enable_irqs();
    BUG_ON(irqs_disabled());

Enable_cpus:
    pm_sleep_enable_secondary_cpus();

Platform_wake:
    platform_resume_noirq(state);
    dpm_resume_noirq(PMSG_RESUME);

Platform_early_resume:
    platform_resume_early(state);

Devices_early_resume:
    dpm_resume_early(PMSG_RESUME);

Platform_finish:
    platform_resume_finish(state);
    return error;
}
```

第一. 调用平台相关 prepare 回调函数, 如果平台 prepare 设置失败, 在调用平台相关的 finish 回调函数.

第二. 调用 `dpm_suspend_late` 函数. 此函数主要调用 `dpm_suspend_list` 中的设备的 suspend_late 回调函数, 然后又将这些设备加入到 `dpm_late_early_list` 链表中. 如果出现失败, 则跳到 platform_finish 做恢复工作.

第三. 如果当前休眠状态是 `PM_SUSPEND_FREEZE` 的话, 调用 freeze_ops 中的 prepare 回调.

第四. 调用 `dpm_suspend_noirq` 函数, 会 **disable** 各个**设备的 irq**, 然后从 `dpm_late_early_list` 链表中取一个设备, 然后调用该设备的 `suspend_noirq` 回调, 同时将该设备加入到 `dpm_noirq_list` 链表中.

```cpp
// drivers/base/power/main.c
int dpm_suspend_noirq(pm_message_t state)
{
    int ret;

    device_wakeup_arm_wake_irqs();
    // disable 所有设备的 irq
    suspend_device_irqs();
    // 针对系统中的每一个 device,
    // 依次调用 device_suspend_noirq 来执行该设备 noirq 情况下的 suspend callback 函数
    ret = dpm_noirq_suspend_devices(state);
    if (ret)
        dpm_resume_noirq(resume_event(state));

    return ret;
}
```

> 系统休眠(System Suspend)和设备中断处理: http://www.wowotech.net/pm_subsystem/suspend-irq.html

第五. 回调平台相关的 `preplate_late` 函数, 做 suspend 最后关头的事情.

第六. 如果休眠状态是 PM_SUSPEND_FREEZE, 则 frozen processes + suspended devices + idle processors

第七. disable 所有 nonboot 的 CPU, 失败之后启动 CPU.

第八. 关掉全局 cpu 中断, 如果关掉中断, 则报 BUG

第九. 执行所有 system core 的 suspend 回调函数.

第十. 如果执行成功的话, 这时候系统还会调用 pm_wakeup_pending 检查下, 是否有唤醒事件发生, 如果发生, 停止 suspend, 恢复系统.

第十一. 调用 `suspend_ops->enter` 函数, 此函数会回调系统 suspend 函数, 一般在 ATF 里实现.

第十二. 这时候系统已经睡眠, 如果这时候有唤醒事件发生, 比如按下手机的 power 按键, 系统又会接着 suspend 的地方, 再次往下执行. 也就是 suspend 的一些列反操作.

# 9. resume 入口

OVMF 中, 当触发 system_wakeup,

`InitializePlatform`(`OvmfPkg/PlatformPei/Platform.c`)

```cpp
InitializePlatform()
```

```cpp
PeiCore()
 └─ DxeLoadCore()
     ├─ BootMode = GetBootModeHob () // 获取 BootMode
     |   ├─ if (PlatformCmosRead8 (0xF) == 0xFE) // 从 CMOS 中读取 shutdown status
     |   |   ├─ IoWrite8 (0x70, (UINT8)Index);
     |   |   └─ return IoRead8 (0x71);
     |   └─ PlatformInfoHob->BootMode = BOOT_ON_S3_RESUME;
     └─ S3Resume->S3RestoreConfig2 (S3Resume);
         └─ S3ResumeExecuteBootScript()
             └─ S3BootScriptExecutorEntryFunction()
                 └─ S3ResumeBootOs()
                     └─ AsmTransferControl (Facs->FirmwareWakingVector, 0x0); // 跳转到 OS 的 WakingVector
```

`PeiCore()`, `MdeModulePkg/Core/Pei/PeiMain/PeiMain.c`

```cpp
DEBUG ((DEBUG_INFO, "DXE IPL Entry\n"));
TempPtr.DxeIpl->Entry (
                TempPtr.DxeIpl,
                &PrivateData.Ps,
                PrivateData.HobList
                );
```

```cpp
struct _EFI_DXE_IPL_PPI {
  EFI_DXE_IPL_ENTRY    Entry;
};
typedef struct _EFI_DXE_IPL_PPI EFI_DXE_IPL_PPI;
CONST EFI_DXE_IPL_PPI  mDxeIplPpi = {
  DxeLoadCore
};
```

`DxeLoadCore()`, `MdeModulePkg/Core/DxeIplPeim/DxeLoad.c`

```cpp
BootMode = GetBootModeHob ();
if (BootMode == BOOT_ON_S3_RESUME) {
    Status = S3Resume->S3RestoreConfig2 (S3Resume);
}
```

其中

```cpp
// MdePkg/Library/PeiHobLib/HobLib.c
EFI_BOOT_MODE
EFIAPI
GetBootModeHob (
  VOID
  )
{

  PeiServicesGetBootMode (&BootMode);

  return BootMode;
}

EFI_STATUS
EFIAPI
PeiServicesGetBootMode (
  OUT EFI_BOOT_MODE  *BootMode
  )
{
  CONST EFI_PEI_SERVICES  **PeiServices;

  PeiServices = GetPeiServicesTablePointer ();
  return (*PeiServices)->GetBootMode (PeiServices, BootMode);
}

// MdeModulePkg/Core/Pei/BootMode/BootMode.c
EFI_STATUS
EFIAPI
PeiGetBootMode (
  IN  CONST EFI_PEI_SERVICES  **PeiServices,
  IN  OUT   EFI_BOOT_MODE     *BootMode
  )
{
  PEI_CORE_INSTANCE           *PrivateData;
  EFI_HOB_HANDOFF_INFO_TABLE  *HandOffHob;

  DEBUG ((DEBUG_INFO, "PeiGetBootMode\n"));
  if (BootMode == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  PrivateData = PEI_CORE_INSTANCE_FROM_PS_THIS (PeiServices);

  HandOffHob = (PrivateData->HobList.HandoffInformationTable);

  *BootMode = HandOffHob->BootMode;

  return EFI_SUCCESS;
}
```

set 的来源: `OvmfPkg/PlatformPei/Platform.c`

InitializePlatform() -> BootModeInitialization()

```cpp
EFI_STATUS
EFIAPI
InitializePlatform (
  IN       EFI_PEI_FILE_HANDLE  FileHandle,
  IN CONST EFI_PEI_SERVICES     **PeiServices
  )
{
  DEBUG ((DEBUG_INFO, "Platform PEIM Loaded\n"));
  PlatformInfoHob = BuildPlatformInfoHob ();

  PlatformInfoHob->SmmSmramRequire     = FeaturePcdGet (PcdSmmSmramRequire);
  PlatformInfoHob->SevEsIsEnabled      = MemEncryptSevEsIsEnabled ();
  PlatformInfoHob->PcdPciMmio64Size    = PcdGet64 (PcdPciMmio64Size);
  PlatformInfoHob->DefaultMaxCpuNumber = PcdGet32 (PcdCpuMaxLogicalProcessorNumber);
  // dump 出来了所有 cmos 数据
  PlatformDebugDumpCmos ();

  // qemu 支持 S3
  if (QemuFwCfgS3Enabled ()) {
    DEBUG ((DEBUG_INFO, "S3 support was detected on QEMU\n"));
    PlatformInfoHob->S3Supported = TRUE;
    Status                       = PcdSetBoolS (PcdAcpiS3Enable, TRUE);
    ASSERT_EFI_ERROR (Status);
  }

  BootModeInitialization (PlatformInfoHob);
}

VOID
BootModeInitialization (
  IN OUT EFI_HOB_PLATFORM_INFO  *PlatformInfoHob
  )
{
  EFI_STATUS  Status;

  // 从 cmos 读
  if (PlatformCmosRead8 (0xF) == 0xFE) {
    // 在这里设置的
    PlatformInfoHob->BootMode = BOOT_ON_S3_RESUME;
  }
  // 清 0
  PlatformCmosWrite8 (0xF, 0x00);

  Status = PeiServicesSetBootMode (PlatformInfoHob->BootMode);
  ASSERT_EFI_ERROR (Status);

  Status = PeiServicesInstallPpi (mPpiBootMode);
  ASSERT_EFI_ERROR (Status);
}

// OvmfPkg/Library/PlatformInitLib/Cmos.c
UINT8
EFIAPI
PlatformCmosRead8 (
  IN      UINTN  Index
  )
{
  IoWrite8 (0x70, (UINT8)Index);
  return IoRead8 (0x71);
}

// MdePkg/Library/BaseIoLibIntrinsic/IoLibGcc.c
__asm__ __volatile__ ("inb %w1,%b0" : "=a" (Data) : "d" ((UINT16)Port));
```

IO 端口 0x70 是"CMOS/RTC 索引寄存器", IO 端口 0x71 是"CMOS/RTC 数据寄存器". 要访问 CMOS 中的某些内容, 应该设置索引, 然后读取/写入数据寄存器.

0xF 是 shutdown status

```cpp
UINT8
EFIAPI
PlatformCmosWrite8 (
  IN      UINTN  Index,
  IN      UINT8  Value
  )
{
  DEBUG ((DEBUG_INFO, "CMOSWrite8: index %d, value %d\n", Index, Value));
  IoWrite8 (0x70, (UINT8)Index);
  IoWrite8 (0x71, Value);
  return Value;
}
```

同时添加 write 的 log:

```diff
@@ -83,11 +93,17 @@ IoWrite8 (
 {
   BOOLEAN  Flag;

+  if (Port == 0x71) {
+         DEBUG ((DEBUG_INFO, "IoWrite8 BaseIoLibIntrinsic\n"));
+  }
   Flag = FilterBeforeIoWrite (FilterWidth8, Port, &Value);
   if (Flag) {
     if (IsTdxGuest ()) {
       TdIoWrite8 (Port, Value);
     } else {
+         if (Port == 0x71) {
+                 DEBUG ((DEBUG_INFO, "3 IoWrite8 BaseIoLibIntrinsic\n"));
+         }
       __asm__ __volatile__ ("outb %b0,%w1" : : "a" (Value), "d" ((UINT16)Port));
     }
   }
```

并没有打印, 也就是说并不是 OVMF 侧设置的

`S3RestoreConfig2()`, `UefiCpuPkg/Universal/Acpi/S3Resume2Pei/S3Resume.c`

```cpp
DEBUG ((DEBUG_INFO, "Enter S3 PEIM\r\n"));
...
S3ResumeExecuteBootScript (AcpiS3Context, EfiBootScriptExecutorVariable);
```

`S3ResumeExecuteBootScript()`,

```cpp
    DEBUG ((DEBUG_INFO, "transfer control to Standalone Boot Script Executor\r\n"));
    SwitchStack (
      (SWITCH_STACK_ENTRY_POINT)(UINTN)EfiBootScriptExecutorVariable->BootScriptExecutorEntrypoint,
      (VOID *)AcpiS3Context,
      (VOID *)PeiS3ResumeState,
      (VOID *)(UINTN)(AcpiS3Context->BootScriptStackBase + AcpiS3Context->BootScriptStackSize)
      );
```

`S3BootScriptExecutorEntryFunction()`, S3 boot path, `MdeModulePkg/Universal/Acpi/BootScriptExecutorDxe/ScriptExecute.c`, OVMF 通过 SwitchStack 执行 OS 的 S3 代码

```cpp
DEBUG ((DEBUG_INFO, "Call SwitchStack() to return to S3 Resume in PEI Phase\n"));
PeiS3ResumeState->AsmTransferControl = (EFI_PHYSICAL_ADDRESS)(UINTN)AsmTransferControl;
    SwitchStack (
    // 等于 S3ResumeBootOs
    (SWITCH_STACK_ENTRY_POINT)(UINTN)PeiS3ResumeState->ReturnEntryPoint,
    (VOID *)(UINTN)AcpiS3Context,
    (VOID *)(UINTN)PeiS3ResumeState,
    (VOID *)(UINTN)PeiS3ResumeState->ReturnStackPointer
    );
```

`S3ResumeBootOs()`(`UefiCpuPkg/Universal/Acpi/S3Resume2Pei/S3Resume.c`)

```cpp
DEBUG ((DEBUG_INFO, "Transfer to 16bit OS waking vector - %x\r\n", (UINTN)Facs->FirmwareWakingVector));
AsmTransferControl (Facs->FirmwareWakingVector, 0x0);
```

根据 ACPI Spec, `Facs->XFirmwareWakingVector` 或者 Facs->FirmwareWakingVector 是 OS 执行 S3 唤醒的函数

<table style="width:100%">
<caption>Firmware ACPI Control Structure (FACS)</caption>
  <tr>
    <th>
    Field
    </th>
    <th>
    Byte Length
    </th>
    <th>
    Byte Offset
    </th>
    <th>
    Description
    </th>
  </tr>
  <tr>
    <td>
    Firmware Waking Vector
    </td>
    <td>
    4
    </td>
    <td>
    12
    </td>
    <td>
    该字段被 X_Firmware_Waking_Vector 字段取代. OSPM 放置其唤醒矢量的 32 位地址字段. 在将系统转换为全局睡眠状态之前, OSPM 使用操作系统特定唤醒功能的<b>物理内存地址</b>填充此字段. 在 POST 期间, 平台固件首先检查 X_Firmware_Waking_Vector 字段的值是否非零, 如果是, 则将控制权转移到 OSPM, 如下面的 X_Firmware_Waking_vector 字段描述中所述. 如果 X_Firmware_Waking_Vector 字段为零, 则平台固件检查当前字段的值, 如果不为零, 则将控制转移到指定地址. 在 PC 上, waking function 地址位于低于 1 MB 的内存中, 并且控制权在<b>实模式</b>下传输. OSPM 的 waking function 会恢复处理器的上下文. 对于 IA-PC 平台, 以下示例显示了 Firmware Waking Vector 中的物理地址与 BIOS 跳转到的实模式地址之间的关系. 例如, 如果<b>物理地址</b>是 0x12345, 则 BIOS 必须跳转到实模式地址 0x1234:0x0005. 一般来说, 这种关系是实模式地址 = 物理地址>>4: 物理地址 与 0x000F 请注意, 在 IA-PC 平台上, 当 BIOS 跳转到源自固件中存储的物理地址的实模式地址时, 必须启用 A20 醒来的矢量.
    </td>
  </tr>
  <tr>
    <td>
    Flags
    </td>
    <td>
    4
    </td>
    <td>
    20
    </td>
    <td>
    下面的表
    </td>
  </tr>
  <tr>
    <td>
    X Firmware Waking Vector
    </td>
    <td>
    8
    </td>
    <td>
    24
    </td>
    <td>
    OSPM 的 waking vector 的 64 位<b>物理地址</b>. 在将系统转换为全局休眠状态之前, OSPM 会填写此字段和 <b>OSPM Flags</b> 字段来描述唤醒矢量. OSPM 使用<b>操作系统特定唤醒功能</b>的<b>物理内存地址</b>填充此字段. <p><p>在 POST 期间, <b>平台固件(BIOS)检查该字段</b>的值<b>是否非零</b>, 如果<b>非零</b>, 则在<b>创建适当的执行环境后</b>跳转到该地址, 将控制权转移给 OSPM. 必须按如下方式配置该执行环境:
    <li>对于 64 位 Itanium™ 处理器系列 (IPF) 的平台: 必须禁用中断. 处理器必须将 <code>psr.i</code> 设置为 0. 有关详细信息, 请参阅英特尔® 安腾™ 架构软件开发人员手册. 必须禁用内存地址转换 处理器必须将 `psr.it`、psr.dt 和 psr.rt 设置为 0. 有关详细信息, 请参阅英特尔® 安腾™ 架构软件开发人员手册. </li>
    <li>对于 IA 32 和 x64 平台, 需要<b>平台固件</b>来支持 32 位执行环境. <b>平台固件</b>还可以支持 64 位执行环境. 如果平台固件支持 64 位执行环境, 则固件会在 <b>POST</b> 期间检查 <b>OSPM Flags</b>. 如果设置了 <code>64BIT_WAKE_F</code> 标志, <b>平台固件</b>将创建 64 位执行环境. 否则, 平台固件将创建 32 位执行环境. 对于 64 位执行环境:  必须禁用中断 <code>EFLAGS.IF</code> 设置为 0; 启用长模式; 启用<b>分页</b>模式, 并且唤醒矢量(waking vector)的物理内存是<b>恒等映射(identity mapped)</b>的（<b>虚拟地址等于物理地址</b>）; 唤醒矢量必须包含在一个物理页内 Selectors 被设置为 flat, 否则不使用. 对于 32 位执行环境: 必须禁用中断 EFLAGS.IF 设置为 0 必须禁用内存地址转换/分页 所有段寄存器的 4 GB 平面地址空间
    </td>
  </tr>
  <tr>
    <td>
    OSPM Flags
    </td>
    <td>
    4
    </td>
    <td>
    36
    </td>
    <td>
    已启用 OSPM 的固件控制结构标志. 平台固件必须将此字段初始化为零. 见下面表
    </td>
  </tr>
</table>

<table style="width:100%">
<caption>Firmware Control Structure Feature Flags</caption>
  <tr>
    <th>
    FACS - Flag
    </th>
    <th>
    Byte Length
    </th>
    <th>
    Byte Offset
    </th>
    <th>
    Description
    </th>
  </tr>
  <tr>
    <td>
    S4BIOS_F
    </td>
    <td>
    1
    </td>
    <td>
    0
    </td>
    <td>
    指示平台是否支持 `S4BIOS_REQ`. 如果不支持 S4BIOS_REQ, OSPM 必须能够保存和还原内存状态才能使用 S4 状态.
    </td>
  </tr>
  <tr>
    <td>
    64BIT_WAKE_SUPPORTED_F
    </td>
    <td>
    1
    </td>
    <td>
    1
    </td>
    <td>
    指示平台固件支持唤醒矢量的 64 位执行环境. 设置和 OSPM 另外设置 64BIT_WAKE_F 时, 平台固件将创建一个 64 位执行环境, 然后再将控制权转移到 X_Firmware_Waking_Vector.
    </td>
  </tr>
  <tr>
    <td>
    Reserved
    </td>
    <td>
    30
    </td>
    <td>
    2
    </td>
    <td>
    值为 0
    </td>
  </tr>
</table>

<table style="width:100%">
<caption>OSPM Enabled Firmware Control Structure Feature Flags</caption>
  <tr>
    <th>
    FACS - Flag
    </th>
    <th>
    Byte Length
    </th>
    <th>
    Byte Offset
    </th>
    <th>
    Description
    </th>
  </tr>
  <tr>
    <td>
    64BIT_WAKE_F
    </td>
    <td>
    1
    </td>
    <td>
    0
    </td>
    <td>
    OSPM 设置此位以向<b>平台固件</b>指示 X_Firmware_Waking_Vector 需要 64 位执行环境. 仅当平台固件在 FACS Flags 字段中设置 64BIT_WAKE_SUPPORTED_F 时, 才能设置此标志. 这个位字段对基于 ItaniumTM 处理器家族（IPF）的平台没有影响, 这些平台需要 64 位执行环境.
    </td>
  </tr>
  <tr>
    <td>
    Reserved
    </td>
    <td>
    31
    </td>
    <td>
    1
    </td>
    <td>
    值为 0
    </td>
  </tr>
</table>

`Table 5.13: Firmware ACPI Control Structure (FACS)`, FACS 表用于 firmware 和 OS 传输数据, 表格中提到的 **OSPM** 是指 OS 的 `ACPI.sys` 模块. 如表格所述, `Facs->XFirmwareWakingVector` 的值由 OS 负责填写. 在 Comet lake platform 上 `Facs->XFirmwareWakingVector` 的物理地址值为: `0x2000`, 所以, 我决定在 windows 上查找具体设置的代码（既然 OS 能设置, 驱动模块也能设置, 这是挂 Hook 的绝佳选择）.

查看 ACPI table 使用 rw 工具(windows) 或者 isal(Linux), `Facs->XFirmwareWakingVector` 以及 `Facs->Firmware Waking Vector` 都是 0（目前, 我猜想: 如 ACPI spec 如说, 该值只有在进入 S3 Sleep 时才会被设置）:

```
# cat /sys/firmware/acpi/tables/FACS > FACS.aml
# iasl -d FACS.aml
# cat FACS.dsl
/*
 * Intel ACPI Component Architecture
 * AML/ASL+ Disassembler version 20210105 (64-bit version)
 * Copyright (c) 2000 - 2021 Intel Corporation
 *
 * Disassembly of FACS.aml, Sun Jun 18 05:46:22 2023
 *
 * ACPI Data Table [FACS]
 *
 * Format: [HexOffset DecimalOffset ByteLength]  FieldName : FieldValue
 */

[000h 0000   4]                    Signature : "FACS"
[004h 0004   4]                       Length : 00000040
[008h 0008   4]           Hardware Signature : 5703F530
[00Ch 0012   4]    32 Firmware Waking Vector : 00000000
[010h 0016   4]                  Global Lock : 00000000
[014h 0020   4]        Flags (decoded below) : 00000000
                      S4BIOS Support Present : 0
                  64-bit Wake Supported (V2) : 0
[018h 0024   8]    64 Firmware Waking Vector : 0000000000000000
[020h 0032   1]                      Version : 02
[021h 0033   3]                     Reserved : 000000
[024h 0036   4]    OspmFlags (decoded below) : 00000000
               64-bit Wake Env Required (V2) : 0

Raw Table Data: Length 64 (0x40)

    0000: 46 41 43 53 40 00 00 00 30 F5 03 57 00 00 00 00  // FACS@...0..W....
    0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  // ................
    0020: 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  // ................
    0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  // ................
```

虽然不清楚 `Facs->XFirmwareWakingVector` 的值, 搜索相关代码:

`drivers/acpi/sleep.c`

`__acpi_pm_prepare` ->

```cpp
static int acpi_sleep_prepare(u32 acpi_state)
{
#ifdef CONFIG_ACPI_SLEEP
    if (acpi_state == ACPI_STATE_S3 && !acpi_skip_set_wakeup_address()) {
        acpi_wakeup_address = acpi_get_wakeup_address();
        acpi_sleep_prepare(acpi_wakeup_address)
    }
#endif
    pr_info("Preparing to enter system sleep state S%d\n", acpi_state);

}
```

`drivers/acpi/sleep.h`

`acpi_set_waking_vector((acpi_physical_address)wakeup_address, 0)`

`drivers/acpi/acpica/hwxfsleep.c`

`acpi_set_firmware_waking_vector` -> `acpi_hw_set_firmware_waking_vector`

```cpp
// drivers/acpi/acpica/hwxfsleep.c
// firmware_waking_vector 有值
// X_Firmware_Waking_Vector 为 0
static acpi_status
acpi_hw_set_firmware_waking_vector(struct acpi_table_facs *facs,
                   acpi_physical_address physical_address,
                   acpi_physical_address physical_address64)
{
    ACPI_FUNCTION_TRACE(acpi_hw_set_firmware_waking_vector);


    /*
     * According to the ACPI specification 2.0c and later, the 64-bit
     * waking vector should be cleared and the 32-bit waking vector should
     * be used, unless we want the wake-up code to be called by the BIOS in
     * Protected Mode.  Some systems (for example HP dv5-1004nr) are known
     * to fail to resume if the 64-bit vector is used.
     */

    /* Set the 32-bit vector */

    facs->firmware_waking_vector = (u32)physical_address;

    if (facs->length > 32) {
        if (facs->version >= 1) {

            /* Set the 64-bit vector */

            facs->xfirmware_waking_vector = physical_address64;
        } else {
            /* Clear the 64-bit vector if it exists */

            facs->xfirmware_waking_vector = 0;
        }
    }

    return_ACPI_STATUS(AE_OK);
}
```


然后会从 OS waking vector 开始执行, 在 `arch/x86/realmode/rm/wakeup_asm.S` 中, 会恢复上下文, 最终根据 RIP 跳回原有位置.

# Kernel 入口

kernel 中的入口是 waking vector 所在位置.

```assembly
// arch/x86/realmode/rm/wakeup_asm.S

// 16 位代码
	.code16

/* This should match the structure in wakeup.h */
	.section ".data", "aw"

	.balign	16
SYM_DATA_START(wakeup_header)
	video_mode:	.short	0	/* Video mode number */
	pmode_entry:	.long	0
	pmode_cs:	.short	__KERNEL_CS
	pmode_cr0:	.long	0	/* Saved %cr0 */
	pmode_cr3:	.long	0	/* Saved %cr3 */
	pmode_cr4:	.long	0	/* Saved %cr4 */
	pmode_efer:	.quad	0	/* Saved EFER */
	pmode_gdt:	.quad	0
	pmode_misc_en:	.quad	0	/* Saved MISC_ENABLE MSR */
	pmode_behavior:	.long	0	/* Wakeup behavior flags */
	realmode_flags:	.long	0
	real_magic:	.long	0
	signature:	.long	WAKEUP_HEADER_SIGNATURE
SYM_DATA_END(wakeup_header)

	.text
	.code16

	.balign	16
SYM_CODE_START(wakeup_start)
	cli
	cld

	LJMPW_RM(3f)
3:
	/* Apparently some dimwit BIOS programmers don't know how to
	   program a PM to RM transition, and we might end up here with
	   junk in the data segment descriptor registers.  The only way
	   to repair that is to go into PM and fix it ourselves... */
	movw	$16, %cx
	lgdtl	%cs:wakeup_gdt
	movl	%cr0, %eax
	orb	$X86_CR0_PE, %al
	movl	%eax, %cr0
	ljmpw	$8, $2f
2:
	movw	%cx, %ds
	movw	%cx, %es
	movw	%cx, %ss
	movw	%cx, %fs
	movw	%cx, %gs

	andb	$~X86_CR0_PE, %al
	movl	%eax, %cr0
	LJMPW_RM(3f)
3:
	/* Set up segments */
	movw	%cs, %ax
	movw	%ax, %ss
	movl	$rm_stack_end, %esp
	movw	%ax, %ds
	movw	%ax, %es
	movw	%ax, %fs
	movw	%ax, %gs

	lidtl	.Lwakeup_idt

	/* Clear the EFLAGS */
	pushl $0
	popfl

	/* Check header signature... */
	movl	signature, %eax
	cmpl	$WAKEUP_HEADER_SIGNATURE, %eax
	jne	bogus_real_magic

	/* Check we really have everything... */
	movl	end_signature, %eax
	cmpl	$REALMODE_END_SIGNATURE, %eax
	jne	bogus_real_magic

	/* Call the C code */
	calll	main

	/* Restore MISC_ENABLE before entering protected mode, in case
	   BIOS decided to clear XD_DISABLE during S3. */
	movl	pmode_behavior, %edi
	btl	$WAKEUP_BEHAVIOR_RESTORE_MISC_ENABLE, %edi
	jnc	1f

	movl	pmode_misc_en, %eax
	movl	pmode_misc_en + 4, %edx
	movl	$MSR_IA32_MISC_ENABLE, %ecx
	wrmsr
1:

	/* Do any other stuff... */

#ifndef CONFIG_64BIT
	/* This could also be done in C code... */
	movl	pmode_cr3, %eax
	movl	%eax, %cr3

	btl	$WAKEUP_BEHAVIOR_RESTORE_CR4, %edi
	jnc	1f
	movl	pmode_cr4, %eax
	movl	%eax, %cr4
1:
	btl	$WAKEUP_BEHAVIOR_RESTORE_EFER, %edi
	jnc	1f
	movl	pmode_efer, %eax
	movl	pmode_efer + 4, %edx
	movl	$MSR_EFER, %ecx
	wrmsr
1:

	lgdtl	pmode_gdt

	/* This really couldn't... */
	movl	pmode_entry, %eax
	movl	pmode_cr0, %ecx
	movl	%ecx, %cr0
	ljmpl	$__KERNEL_CS, $pa_startup_32
	/* -> jmp *%eax in trampoline_32.S */
#else
	jmp	trampoline_start
#endif
SYM_CODE_END(wakeup_start)
```


`dpm_resume_noirq(PMSG_RESUME);`

/sys/power/pm_async, 使用 async 异步的方式执行 suspend/resume 流程

echo 0 > /sys/power/pm_async, 使用 同步 方式, 跟 async 异步方式相比, 同步是需要等到上一个 device 的 suspend/resume 流程结束返回后, 才能去执行下一个 device 的 suspend/resume 操作



# 10. 小结

分析其他几种情况(freeze 以及 standby)

None: http://www.wowotech.net/pm_subsystem/suspend_and_resume.html