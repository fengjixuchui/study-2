
DMA 映射主要为在设备与主存之间建立DMA数据传输通道时，在主存中为该DMA通道分配内存空间的行为，该内存空间
也称为DMA缓冲区。这个任务原本可以很简单，但是由于现代处理器cache的存在，使得事情变得复杂。



PCI设备 支持 DMA，那么在传输数据的时候，我们需要一块 DMA buffer 用于 接收或者发送数据，这块 DMA buffer 存在于 RAM内存区域 中。

但我们之前说了，PCI 设备在 MMIO区域 有规定的 总线地址，那么在 RAM内存区域 也是一样，PCI设备 无法通过方位 RAM内存区域中的虚拟地址 来 获取或存放数据。但与 MMIO 不同的是，MMIO 通过 PCI桥 将 虚拟地址 映射为 总线地址，RAM内存 则是通过 IOMMU 将 虚拟地址 映射为 总线地址。

那么 PCI设备、DMA 和 CPU 是如何在 同一块内存 中进行交互的呢？
回答这个问题，我们需要清楚以下几点：

* PCI设备 使用 DMA 传输 的是数据时需要使用的是 总线地址，即 DMA 是使用 总线地址 作为 源地址 或者 目的地址
* DMA 传输数据时，*IOMMU 可以将 总线地址 转换 物理地址 。
* DMA 传输完成后，CPU 使用 虚拟地址 访问该内存块。

其步骤如下：

1. 内存块 由 CPU 创建，此时 CPU 获取到的是 内存块的虚拟地址X。
2. 调用接口，将该内存块的 虚拟地址X 对应的 物理地址Y 映射为 总线地址Z 并返回给 CPU。
3. CPU 拿到的地址有 内存块 的 虚拟地址 和 总线地址，其 物理地址 对于 CPU 来说没有意义。
4. 将 总线地址 写入 DMA 对应的寄存器，接着就可以执行相关的 DMA操作 了。


数据如何在CPU和IO device之间的传递和处理？

（1）**CPU** 通过**MMU**建立起数据的**物理地址PA**到数据的**虚拟地址**之间的映射，CPU 通过访问 **VA** 从而访问到数据（比如CPU填充数据到内存中)；

（2）**IO 设备驱动**得到数据的**PA**，并通过**DMA MAP**将数据的物理地址**PA**和**IOVA**建立**映射**，然后IO设备驱动将IOVA传递给 IOMMU 设备；

（3）IOMMU 将IOVA转换为PA，从而对PA处的数据的处理；

（4）完成数据处理后，通过DMA UNMAP取消IOVA到PA的映射；

都会将物理区域与连续的IOVA建立起映射:

* dma_alloc_coherent(dev, size, dma_handle, gfp), 一致性DMA, 在分配物理区域的同时，建立物理区域与IOVA的映射，同时返回VA。

* dma_map_sg/page/single(), 流式DMA, 将之前分配好的物理区域与连续的IOVA建立起映射






1. kmalloc() 等申请 DMA 缓冲区, 使用 GFP_DMA 标志.


dma_mem_alloc()



DMA映射包括两个方面的工作：分配一片DMA缓冲区；为这片缓冲区产生设备可访问的地址。

dma_alloc_coherent() 申请一片DMA缓冲区，以进行地址映射并保证该缓冲区的Cache一致性







DMA 的原理就是 CPU 将需要迁移的数据的位置告诉给 DMA，包括源地址，目的地址以及需要迁移的长度，然后启动 DMA 设备，DMA 设备收到命令之后，就去完成相应的操作，最后通过中断反馈给老板 CPU，结束。


在实现 DMA 传输时，是 DMA 控制器掌控着总线，也就是说，这里会有一个控制权转让的问题，我们当然知道，计算机中最大的 BOSS 就是 CPU，这个 DMA 暂时掌管的总线控制权当前也是 CPU 赋予的，在 DMA 完成传输之后，会通过中断通知 CPU 收回总线控制权。

一个完整的 DMA 传输过程必须经过 DMA 请求、DMA 响应、DMA 传输、DMA 结束这四个阶段。

DMA 请求：CPU 对 DMA 控制器初始化，并向 I/O 接口发出操作命令，I/O 接口提出 DMA 请求

DMA 响应：DMA 控制器对 DMA 请求判别优先级以及屏蔽位，向总线裁决逻辑提出总线请求，当 CPU 执行完成当前的总线周期之后即可释放总线控制权。此时，总线裁决逻辑输出总线应答，表示 DMA 已经就绪，通过 DMA 控制器通知 I/O 接口开始 DMA 传输。

DMA 传输：在 DMA 控制器的引导下，在存储器和外设之间进行数据传送，在传送过程中不需要 CPU 的参与。

DMA 结束：当完成既定操作之后，DMA 控制器释放总线控制权，并向 I/O 接口发出结束信号，当 I/O 接口收到结束信号之后，一方面停止 I/O 设备的工作，另一方面向 CPU 提出中断请求，使 CPU 从不介入状态解脱，并执行一段检查本次 DMA 传输操作正确性的代码。最后带着本次操作的结果以及状态继续执行原来的程序。


