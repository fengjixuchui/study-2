
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 相关背景](#1-相关背景)
- [2. 新内核变动](#2-新内核变动)
- [3. 虚拟地址空间](#3-虚拟地址空间)
- [4. 地址空间定义](#4-地址空间定义)
- [5. 虚拟地址宽度](#5-虚拟地址宽度)
- [6. 功能信息](#6-功能信息)
- [7. 寄存器TTBR0和TTBR1](#7-寄存器ttbr0和ttbr1)

<!-- /code_chunk_output -->

# 1. 相关背景

**64位处理器**的**虚拟地址**已经**支持**到了**64bit**, 但是**64位处理器**的**物理地址总线实际位宽**并**没有达到64bit**, 常用的地址线宽有39bit 和 48bit, 最新的ARMv8.2架构也已经可以**支持到52bit**了. 那为什么没有支持到64bit呢？以常用的**48bit地址线宽**举例, 其最大寻址能力是`2^48` bytes(即**256TB内存**), 对于当今的个人电脑或服务器来说都是足够用的. 再加上**增加地址总线的宽度**会给**芯片设计**上带来不小的难度, 所以并没有一步到位搞成64bit.

本文主要介绍ARM64位处理器地址空间的布局. 前文已提到**地址总线宽度(物理地址**)有39bit、48bit以及52bit, 且64位处理器又支持**3级**或**4级页表**, **页大小**也可以配置成**4KB**或**64KB**, 组合起来的话情况太多, 本文为了简化, 就基于最常用组合展开叙述: **48bit地址总线**(物理地址), **4级页表**, **页面大小4KB**. 且不包括ARM64虚拟化模式和安全模式下的情况.

# 2. 新内核变动

kernel变化的真快, `4.x` 的内核的**内核空间**的**线性映射区**位于**内核空间**的**高地址处**的**128TB**, 且当前的博客和一些书籍也都还是这样介绍. 可翻了翻kernel的 `Documentation/arm64/memory.rst` 文档, 发现**最新的kernel**已将**这128TB**移到了内核空间的**最低地址处**了. 具体是2019年8月的一个commit, 如下:

```
commit 14c127c957c1c6070647c171e72f06e0db275ebf
Author: Steve Capper <steve.capper@arm.com>
Date:   Wed Aug 7 16:55:14 2019 +0100

    arm64: mm: Flip kernel VA space

    In order to allow for a KASAN shadow that changes size at boot time, one
    must fix the KASAN_SHADOW_END for both 48 & 52-bit VAs and "grow" the
    start address. Also, it is highly desirable to maintain the same
    function addresses in the kernel .text between VA sizes. Both of these
    requirements necessitate us to flip the kernel address space halves s.t.
    the direct linear map occupies the lower addresses.

    This patch puts the direct linear map in the lower addresses of the
    kernel VA range and everything else in the higher ranges.
```

本文基于目前mainline的内核版本 v5.9-rc2 展开叙述

# 3. 虚拟地址空间

因为目前应用程序没有那么大的内存需求, 所以ARM64处理器**不支持**完全的**64位虚拟地址**, 实际支持情况如下.

(1) 虚拟地址的最大宽度是48位, 如图3.2所示. **内核虚拟地址**在64位地址空间的**顶部**, 高16位是全1, 范围是 `[0xFFFF0000 0000 0000,0xFFFF FFFF FFFF FFFF]`; **用户虚拟地址**在 64 位地址空间的底部, 高16位是全0, 范围是[0x0000 0000 00000000,0x0000 FFFF FFFF FFFF]; 高16位是全1或全0的地址称为规范的地址, 两者之间是不规范的地址, 不允许使用.

ARM64内核/用户虚拟地址空间划分:

![2022-04-14-15-01-26.png](./images/2022-04-14-15-01-26.png)

(2) 如果处理器实现了 ARMv8.2 标准的大虚拟地址(LargeVirtual Address, LVA) 支持, 并且页长度是64KB, 那么虚拟地址的最大宽度是**52位**.

(3) 可以为虚拟地址配置比最大宽度小的宽度, 并且可以为内核虚拟地址和用户虚拟地址配置不同的宽度. 转换控制寄存器(Translation Control Register) `TCR_EL1`的字段T0SZ定义了必须是全0的最高位的数量, 字段T1SZ定义了必须是全1的最高位的数量, 用户虚拟地址的宽度是(`64-TCR_EL1.T0SZ`) , 内核虚拟地址的宽度是(`64-TCR_EL1.T1SZ`) .

# 4. 地址空间定义

下面是ARM64位处理器使用**48位虚拟地址**, **4级页表**, **页面大小4KB**时的layout:

```
  Start			End			Size		Use
  -----------------------------------------------------------------------
  0000000000000000	0000ffffffffffff	 256TB		user
  ffff000000000000	ffff7fffffffffff	 128TB		kernel logical memory map
 [ffff600000000000	ffff7fffffffffff]	  32TB		[kasan shadow region]
  ffff800000000000	ffff800007ffffff	 128MB		bpf jit region
  ffff800008000000	ffff80000fffffff	 128MB		modules
  ffff800010000000	fffffbffefffffff	 124TB		vmalloc
  fffffbfff0000000	fffffbfffdffffff	 224MB		fixed mappings (top down)
  fffffbfffe000000	fffffbfffe7fffff	   8MB		[guard region]
  fffffbfffe800000	fffffbffff7fffff	  16MB		PCI I/O space
  fffffbffff800000	fffffbffffffffff	   8MB		[guard region]
  fffffc0000000000	fffffdffffffffff	   2TB		vmemmap
  fffffe0000000000	ffffffffffffffff	   2TB		[guard region]
```

注: 以上layout来自内核文档 `Documentation/arm64/memory.rst`. **x86**的位于 `Documentation/x86/x86_64/mm.rst`

为了直观点, 画了幅图:

![2022-04-19-11-15-17.png](./images/2022-04-19-11-15-17.png)

# 5. 虚拟地址宽度

在编译ARM64架构的Linux内核时, 可以选择虚拟地址宽度.

(1) 如果选择页长度**4KB**, **默认**的**虚拟地址宽度**是**39位**.

(2) 如果选择页长度**16KB**, 默认的虚拟地址宽度是**47位**.

(3) 如果选择页长度**64KB**, 默认的虚拟地址宽度是42位.

(4) 可以选择**48位**虚拟地址.

# 6. 功能信息

在ARM64架构的Linux内核中, **内核虚拟地址**和**用户虚拟地址**的**宽度相同**.

**所有进程共享内核虚拟地址空间**, **每个进程**有**独立**的**用户虚拟地址空间**, **同一个线程组**的用户线程**共享用户虚拟地址空间**, **内核线程没有用户虚拟地址空间**.

# 7. 寄存器TTBR0和TTBR1

本文讲到了内核地址空间和用户地址空间, 这就不得不提一下ARM64相关的两个寄存器TTBR0和TTBR1. 它们的功能类似于X86里的CR3寄存器用来存放进程的1级页表(PGD)的基地址. 但不同的是ARM64使用了两个寄存器分别存放用户空间和内核空间的1级页表基地址. 

我们知道所有进程的内核地址空间的页表是共用一套的, 所以TTBR1中的内容不会改变, 永远等于`init_mm->swapper_pg_dir`. 但各个进程的用户空间的页表各自独立, 那么TTBR0中的内容则等于各自进程的`task_struct->mm_struct->pgd`

最后提一下, 处理器如何知道什么时候访问TTBR0, 什么时候访问TTBR1呢？ARMv8手册中有提到, 当CPU访问地址时, 若地址的第63bit为1则自动使用TTBR1, 为0则使用TTBR0. 

![2022-04-19-11-23-28.png](./images/2022-04-19-11-23-28.png)
