
可以将本书源码编译为64位版本.

多数模块, 只需要维护一份代码, 即并不需要分别编写64位版本以及32位版本的代码. 极少部分才区分

# 使用符号__X64

为了做到64位和32位版本**只维护一份代码**, 需要将代码以**32位形式**进行编译. 同时, 引进__X64符号控制机器码的生成.

```assembly
bits 32             ;;重要, 以32位形式进行编译
        ... ...
%ifdef __X64
        ;;
        ;; 此处插入64位特定的代码!
        ;;
%else
        ;;
        ;; 此处插入32位特定的代码!
        ;;
%endif
        ... ...
```

注意: 由于在`64-bit`模式下, **绝大多数指令**的**操作位**默认为**32位**, 导致多数指令机器码在64位和32位环境下是一样的! 只有**少量的指令**, 我们需要进行特别处理. 因此, 引进`__X64`是为了解决某些特定指令的使用.

代码统一在**32位下编译**后, 处理器无论运行在`64-bit`模式下, 还是32位保护模式下, 都能正确执行. 当然, 除了某些需要特殊处理器的指令, 下面了解一下.

# 指令操作数

64位和32位混合编译之前, 有必要先了解下x86/64体系中**指令**的`operand size`(**操作数宽度**), 以及`address size`(**地址宽度**)相关知识. 更详细介绍看 http://www.mouseos.com/x64/index.html .

**指令**的**操作数大小**及**地址大小**有**default**(默认)和**effective**(有效)两种情况. 

表1\-1列出处理器各种工作模式下的default operand size(默认操作数宽度)与default address size(默认地址宽度), effective operand size(有效的操作数宽度)与effective address size(有效的地址宽度).

![2020-01-24-22-29-47.png](./images/2020-01-24-22-29-47.png)

![2020-01-24-22-33-24.png](./images/2020-01-24-22-33-24.png)

指令的默认operand size、address size由CS.D和CS.L位(IA\-32e/long\-mode可用)决定.

- 

另外, stack address(栈地址, 或栈指针)的宽度由SS.B位决定, 但不能被override(改写).

- 

栈地址宽度不能被address\-size override prefix(地址宽度改写前缀)修改, 例如下面的代码.

```assembly
DB 67h          ; address override prefix
push eax        ; 32位的栈地址不能被改写
```

上面的示例, 企图使用地址宽度改写前缀67H修改栈地址为16位是不起作用的. PUSH指令中的32位栈地址仍然是32位.

然而, 指令的default operand size(默认操作数宽度), 以及default address size(默认地址宽度)都可以使用override prefix(改写前缀)进行修改.

-
...

# 64-bit模式下的其他指令处理

对于较复杂的部分函数分别单独实现了32位与64位版本.


# 函数重定义表