
处理器在**建立 cache 信息时**，也必须**维护 cache 的归属信息**，也就是 cache **所属的域**。另一方面，在**刷新**(**invalidate**) **cache** 操作时，也需要指明刷新哪份cache 信息(**哪个域的 cache**)。

处理器引人VMX架构后，在原基础上添加了**新的 cache 归属标识**。当前处理器支持**三个归属标识**，分别为 **PCID**, **VPID** 及 **EP4TA**。它们用在不同的场合。

# PCID

> process context identifer, 进程上下文ID

顾名思义，PCID 用来为**每个进程**提供-一个 **ID 值**。引人初衷是当 OS 进行**进程切换时**可能也需要进行 **CR3 切换**(**每个进程**具有**独立**的 **paging-structure** 与**线性地址空间**)。

在**更新 CR3 寄存器**时，**PCID 值**提供在 **CR3** 寄存器的 `bits 11:0`(**12 位的 PCID 值**)中。因此，软件可以为**每份 paging structure** 定义一个 **ID 标识**(**线性地址空间**)，处理器通过这个 PCID 值来维护**线性地址**通过**对应的 paging structure 转换**而产生的 cache 信息。

在使用 PCID 功能前，软件需要通过 **CPUID** 指令来检查处理器是否支持。

* 当 `CPUID.01H:ECX[17] = 1` 时，软件可以**置** `CR4.PCIDE = 1` **开启 PCID 功能**。否则对 `CR4.PCIDE` 置位将产生 `#GP` 异常。
* PCID 只能在 **IA-32e 模式**下使用(`IA32_EFER.LMA = 1`)，在其他模式下置 `CR4.PCIDE= 1` 则产生 `#GP` 异常。

在开启 PCID 功能后，软件可以为**每份 paging structure** 提供一个非 0 的 **PCID** 值。当 `CR4.PCIDE = 0` 或者在**其他模式**下时，**默认的 PCID 值**为 **000H**。在这种情况下，处理器只维护 PCID 值为 000H 的那份 cache 信息。关于 PCID 更详细的信息请参考《x86/x64 体系探索及编程》11.5.1.3 节。

注意: 处理器用 PCID 来维护与线性地址转换相关的cache信息( 即linear mapping 及combined mapping，参见前面6.2.1 节与6.2.3节)。

# EP4TA

> EPT PML4T address, 扩展页表的 PML4T 地址, 标识一个 guest-physical address space

在启用 EPT 机制后，`guest-physical address`(GPA) 需要通过 EPT paging structure 转换到 `host-physical address`(HPA)。 层级EPT paging structure 的地址则需要在 **EPTP** 字段 `bits N-1:12` 中提供(参见6.1.4节)。

EPT paging structure 中**顶层**的**页表 PML4T 地址**被称为 “**EP4TA**”(`EPT PML4T address`，**扩展页表的PML4T地址**)。在 EPT 机制中，**一个 EP4TA 值**也被作为 **ID 标识符**，用来**标识**由 EPT paging structure 所映射的 **guest-physical address space**(**GPA**).

注意: 处理器用 EP4TA 来维护与 guest-physical address 转换相关的cache信息，包括 **guest-physical mapping** 与 combined mapping 所产生的cache信息(参见前面 6.2.2 节与 6.2.3 节)。

如果在每次进行VM-entry时提供不同的EP4TA值( 即不同的EPTP字段值)，处理
器将维护不同EP4TA值所对应的cache信息。

取决于 secondary processor-based VM-execution control 字段 “enable VPID” 位的值，处理器在每次 VM-entry 与 VM-exit 时决定是否刷新所有 EP4TA 值对应的combined mapping产生的cache信息，但不刷新guest-physical mapping产生的cache信息。

# VPID 

> virtual-processor identifier, 虚拟处理器ID

VPID 用来为**每个虚拟处理器**提供-一个 ID 值。在第 4 章开头我们已经了解过“虚拟处理器”的概念，每次 VM-entry 与 VM-exit 都相当于进行一次虚拟处理器的切换。

**一个 VM** (虚拟机)就**代表**着**一个虚拟处理器**。在每次VM切换时(在一个逻辑处理器下可能管理多个 VM 实例)，VPID 用来标识该 VM (**一个 VPID 对应一个 VM**)。从另一个角度看，**VPID** 用来标识 **VM** 在**处理器中**的 **cache** 域。

当 `secondary procesor-based VM-execution control` 字段的“**enable VPID**”为 1 时, VMM 需要在 `virtual-processor identifier` 字段提供一个 **16** 位的非 0 值作为 VPID(参见 3.5.18 节与 4.4.1.3 节)。VMM应该为**每个 VM** 准备**独立的 VPID 值**，用来**隔离每个 VM 的 cache 域**。也就是每个 VM 应该有自己的 VPID 值，用来标识自己的 cache 空间。

有下面的情形之一，处理器使用**默认的 VPID 值**(**0000H**) :

* 当 “**enable VPID**” 为 **0** 时(**VMX non-root operation模式**)。
* 处理器处于 **VM root operation 模式**(VMM 或 host)
* 处理器运行在**非 VMX 模式**(**没执行 VMXON** 指令，或执行了 **VMXOFF** 指令)
* 处理器切换到 **SMM 模式**(在VMX中使用默认的 SMM 处理机制)

每个 VM 使用默认的 VPID 值时，处理器在 VM-entry 与 VM-exit 时维护当前 VPID 为 0000H 的那份 cache 信息。也就是 VM 与 VMM 的都在同-一个 VPID cache 域下。

处理器用 VPID 来维护与线性地址转换相关的 cache 信息，包括下面的情形。

* 当 VM 没有 EPT 机制时(或者在 host 里)，处理器在 VPID 域中结合 PCID 为




