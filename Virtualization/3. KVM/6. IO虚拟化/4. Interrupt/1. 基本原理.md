<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 中断组成](#1-中断组成)
- [2. 中断的模拟](#2-中断的模拟)
  - [2.1. 中断源模拟](#21-中断源模拟)
  - [2.2. 虚拟机响应虚拟中断](#22-虚拟机响应虚拟中断)
    - [2.2.1. 中断退出](#221-中断退出)
    - [2.2.2. 中断注入](#222-中断注入)
- [3. 中断虚拟化](#3-中断虚拟化)
- [4. 物理中断](#4-物理中断)
  - [4.1. vcpu运行时的截获和注入](#41-vcpu运行时的截获和注入)
- [5. 虚拟中断](#5-虚拟中断)
- [6. 参考](#6-参考)

<!-- /code_chunk_output -->

# 1. 中断组成

中断从宏观上看可以分为软件部分和硬件部分.

软件部分:

软件部分在**操作系统**中实现, 如Linux中断的**x86**, 每一个中断对应一个**中断门**, 中断门中包含中断处理函数(ISR或者别的)地址, 优先级等等. CPU可以通过**LIDT**加载这个描述符表, 跳转到指定的中断门.

硬件部分:

中断硬件部分就是**产生中断脉冲**, **传给中断控制器**, 然后**通知CPU**, CPU在执行**下条指令前**会去**查询中断情况**, 如果有中断信号, 就执行中断. 我们在这里模拟的就是硬件部分内容.

# 2. 中断的模拟

因此中断的模拟按照我的理解可以分为两个主要部分, 一个是**中断源的模拟**, 一个是**给虚拟机的VCPU响应中断**.

## 2.1. 中断源模拟

**虚拟机**的**中断源**大致有两种方式, 来自于**用户空间qemu**和来自于**KVM内部**.

## 2.2. 虚拟机响应虚拟中断

KVM中断虚拟化主要依赖于`VT-x`技术, VT-x主要提供了**两种中断事件机制**, 分别是

- **中断退出**
- **中断注入**

### 2.2.1. 中断退出

是指**虚拟机发生中断时**, 主动使得客户机发生`VM-exit`, 这样能够在主机中实现**对客户机中断的注入**.

### 2.2.2. 中断注入

是指负责将虚拟中断控制器采集的中断请求注入到虚拟处理器, 即**将中断写入VMCS对应的中断信息位**, 来实现中断的注入, 当中断完成后通过**读取中断的返回信息**来分析中断是否正确.

需要处理两个问题, 什么时候注入, 如何注入?

# 3. 中断虚拟化

中断虚拟化, 涉及两方面工作:

1. **如何保证物理中断只由host来处理**;
2. host如何将一个**虚拟中断注入到guest**中.

# 4. 物理中断

首先看物理中断情况:

在**没有guest**情况下, 一旦CPU检测到**中断信号**, 将在**下一条指令之前响应中断**, 根据**中断号**从**host OS IDT**中取到对应的中断向量, 然后调用**interrupt handler**.

但是, 假如**guest vcpu**正在**执行中**, 来了**物理中断**, 此时的**物理IDTR**指向的是**guest OS的IDT**. 原则上肯定**不会是由guest handler**去处理**物理中断**, 所以必须通过**某种机制**来处理, 这个机制由两部分配合:

1. 首先是**vmx规定**, 只要此**虚拟机 vmcs**的"`VM-Execution control field`"中的"`External -interrupt exiting`"**位设置为1**, **物理中断**将**导致VMExit**(vmcs的配置可以参考"IA32 Intel Architecture Software Developer’s Manual Volume 3B System Programming Guide").

2. 知道了1. 后, **物理中断不是应该立刻由硬件来响应**么, 那么是**响应中断在前**, 还是**VMExit在前**呢?如果**响应在前**, 此时**IDTR还没有恢复为host**的, 将导致取guest IDT, 所以**显然不行**, **只能是VMExit在前**, 但是**VMExit过程**中**硬件只能恢复host的非通用寄存器！！！**, **通用寄存器**还得由**软件！！！来恢复(vmx_vcpu_run函数代码**), **物理中断**却要在**恢复通用寄存器之间**了, 显然也不行.

后来才发现, 原来在**进入guest执行前**, **kvm是关中断的**, 在**VMExit完全恢复了host上下文**后, **才开中断**——关中断是`vcpu_enter_guest`函数中调用了`local_irq_disable`, **开中断**是在这个函数从`kvm_x86_ops->run`**返回后**(即**VMExit后**)调用`local_irq_enable`.

现在一切都明白了: **guest vcpu执行时**, **物理中断来了**, 它可以导致**VMExit**, 但是此时是**关中断**, 所以**硬件不会响应中断**, 中断处于**pending**, 在**中断开后**, 硬件发现**pending中断并开始响应**, 此时已经是在**host上下文**中, **IDTR已经指向host的IDT**, 因此物理中断实际上是由**host handler来处理**了.

## 4.1. vcpu运行时的截获和注入

假如在**guest运行期间**发生了一个**物理中断**, kvm是**如何截获**进入将其**注入到guest**中去的呢?有两个步骤:

1. 在`vmx_vcpu_run`中, 从**guest mode返回！！！** 后会**调用**`complete_interrupt`函数. 因为硬件会将**中断类型**和那个**中断号**写入到**VMCS**中, 所以`complete_interrupt`的任务就是**从VMCS中取出中断信息**, 然后**写入vcpu的控制块**中去, 使得这个中断变成一种**pending event**.

2. 在`vcpu_enter_guest`中, 在**进入guest mode前！！！** 会调用`inject_pending_event`. `inject_pending_event`发现**vcpu控制块**中**有pending的中断信息**, 就调用`vmx_inject_irq`将其**写入VMCS中**去, 就相当于**将中断注入到guest**中去了.

对于1. 情况, 暂时也还不知道KVM具体是如何实现的. 不过vmx倒也是支持这种注入操作. 只要vmcs的"`VM-Execution control field`"中的"`Interrupt-window exiting`"位设**置为1**, **只要guest IF=1**, 在**下一条任意指令前**, 会发生**VMExit**, 就像**普通情况下发生了一次中断**一样. 也就是说, **kvm**应该可以通过设置"`Interrupt-window exiting`"**中断guest vcpu的执行**, 然后像后一种情况一样, **把虚拟中断注入到虚拟机中**.

# 5. 虚拟中断

再来看虚拟中断的情况;

KVM用QEMU来提供**设备模拟**, 与物理设备一样, **模拟的设备**也可以**发出中断信号**, 但是这个**中断信号是软件虚拟**的, 那么这个虚拟中断是怎样注入到虚拟机中去的呢?这个又要分两种情况:

1. 此时**guest vcpu正在执行**;

2. **guest vcpu**刚到**用户模式**执行完**IO指令模拟操作**, 还**没有开始VMEntry**.

对于2. 情况, 可以参考`vmx_inject_irq`和`vmx_inject_nmi`(`vmx.c`), 可以发现, kvm是利用**vmx支持**这种**注入操作的特性**: vmcs中有"`VM-Entry control fields`", 其中又包含"`VM-entry interruption-information field`", 可以将**中断类型**和**中断号**记录到其中, 在**VMEntry过程**中, 硬件会**自动检测这个信息域**, 如果有效, 就会在**真正执行任何guest指令之前**, 像原来硬件一样**响应此中断**(包括**压IP,CS,FLAGS**; 从**IDT中取interrupt vector**等), 注意此操作是在**恢复了guest上下文之后**, 所以**物理IDTR**已经是指向**guest OS IDT**了, 因此这个虚拟中断就由guest handler来处理了.

# 6. 参考

https://blog.csdn.net/xidianjiapei001/article/details/89293842

https://blog.csdn.net/leoufung/article/details/48781089