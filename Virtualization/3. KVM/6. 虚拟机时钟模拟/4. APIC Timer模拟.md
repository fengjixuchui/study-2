
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. APIC timer中断](#1-apic-timer中断)
  - [1.1. 硬件原理](#11-硬件原理)
  - [1.2. 流程简介](#12-流程简介)
- [2. 相关结构体](#2-相关结构体)
- [3. 创建和初始化虚拟定时器设备](#3-创建和初始化虚拟定时器设备)
- [4. 配置定时器模式: 写LVTT](#4-配置定时器模式-写lvtt)
- [5. 设置定时器: 写TMICT或TSC-Deadline](#5-设置定时器-写tmict或tsc-deadline)
  - [5.1. 定时器的触发](#51-定时器的触发)
  - [5.2. 整体流程](#52-整体流程)
  - [5.3. 入口代码](#53-入口代码)
  - [5.4. set_target_expiration(): 设置目标过期时间](#54-set_target_expiration-设置目标过期时间)
  - [5.5. restart_apic_timer(): 重启apic timer定时器](#55-restart_apic_timer-重启apic-timer定时器)
    - [5.5.1. start_hv_timer(): 优先使用hv timer](#551-start_hv_timer-优先使用hv-timer)
    - [5.5.2. start_sw_timer(): 使用sw timer](#552-start_sw_timer-使用sw-timer)
      - [5.5.2.1. start_sw_period(): 周期性或一次性模式](#5521-start_sw_period-周期性或一次性模式)
      - [5.5.2.2. start_sw_tscdeadline(): tscdeadline模式](#5522-start_sw_tscdeadline-tscdeadline模式)
- [6. timer到期](#6-timer到期)
  - [6.1. preemption timer到期](#61-preemption-timer到期)
    - [6.1.1. 整体流程](#611-整体流程)
    - [6.1.2. handle_preemption_timer(): 到期vmexit处理函数](#612-handle_preemption_timer-到期vmexit处理函数)
    - [6.1.3. preemption timer处理](#613-preemption-timer处理)
  - [6.2. hrtimer到期的外部中断](#62-hrtimer到期的外部中断)
    - [6.2.1. 整体流程](#621-整体流程)
    - [6.2.2. apic_timer_fn(): hrtimer到期的响应函数](#622-apic_timer_fn-hrtimer到期的响应函数)
  - [6.3. apic_timer_expired(): apic timer已经到期处理](#63-apic_timer_expired-apic-timer已经到期处理)
- [7. trace](#7-trace)
  - [7.1. 使用ftrace](#71-使用ftrace)
    - [7.1.1. tscdeadline_immed](#711-tscdeadline_immed)
    - [7.1.2. tscdeadline](#712-tscdeadline)
      - [7.1.2.1. Intel禁用preemption timer](#7121-intel禁用preemption-timer)
      - [7.1.2.2. Intel启用preemption timer](#7122-intel启用preemption-timer)
      - [7.1.2.3. AMD启用avic](#7123-amd启用avic)
      - [7.1.2.4. AMD禁用avic](#7124-amd禁用avic)

<!-- /code_chunk_output -->

# 1. APIC timer中断

## 1.1. 硬件原理

见`Architecture/Learning/x86_64编程体系探索及编程/第4篇 中断体系/第18章 local APIC体系/12. APIC timer.md`

## 1.2. 流程简介

前面提到, APIC Timer的APIC定时器有3种定时器模式: 周期触发periodic和一次性触发one-shot和TSC-Deadline模式. 

![2020-05-26-09-28-21.png](./images/2020-05-26-09-28-21.png)

从图中可以看到, timer中断大概分为下面几步

注: 详细见 `Architecture/Learning/x86_64编程体系探索及编程/第4篇 中断体系/第18章 local APIC体系/12. APIC timer.md`中APIC timer的操作步骤

guest的lapic是通过host上的hrtimer模拟的, guest的timer到期后, vCPU收到host上hrtimer interrupt, 导致 vCPU vmexit, KVM把这个timer interrupt inject给guest, guest里最终感受到了timer fire的interrupt, 这个过程比较长, 等guest里感受到timer fire的时候, 实际已经格外经历了上述虚拟化tax.  社区的advance lapic timer让guest的timer提前到期, 这样加上虚拟化层的tax, 期望guest感受到timer fire的时间与guest期望的timer到期时间接近. 


1. 设置timer模式, 通过写LVTT实现, 发生 VM-exit
2. 虚拟机设置APIC timer, 主要包括两个, 写TMICT寄存器(用于one-shot/period模式); 写TSCDEADLINE MSR寄存器(用于tscdeadline模式). 从而发生vm-exit, 进入KVM中
3. 在KVM中, 模拟虚拟机的APIC设置, 先设置这几个寄存器, 然后启用lapic timer定时器(优先使用**hv timer**`<preemption timer>`, 其次使用**hrtimer**)作为中断源, 最后进入Guest模式

intel下还有posted interrupt, amd下有doorbell机制

4.timer到期会发生vm-exit, 进入KVM中
* preemption timer导致的vm-exit, exit reason就是preemption timer
* hrtimer到期会产生外部中断, 导致虚拟机vm-exit, 这个exit reason是外部中断到期后处理
5. KVM中调用timer处理函数, 注入中断, 进入guest模式
6. 虚拟机执行时间中断处理函数, 发送EOI, 导致vm-exit
7. KVM中模拟EOI行为后, 进入Guest模式

注: TMICT, Timer Initial Count寄存器

注2: 还有exitless timer情况

a. 设置timer
b. 启动timer
c. 停止timer
d. 取消timer

下面分析QEMU-KVM模拟APIC Timer**周期触发**(periodic)**模式**中断过程

# 2. 相关结构体

```cpp
// arch/x86/kvm/lapic.h
struct kvm_lapic {
        // APIC Timer
        struct kvm_timer lapic_timer;
}
```

`struct kvm_lapic`详细见`Virtualization/KVM/5. IO虚拟化/4. Interrupt/2. 数据结构.md`

```cpp
// arch/x86/kvm/lapic.h
struct kvm_timer {
        // 这个timer使用hrtimer
        struct hrtimer timer;
        s64 period;                             /* unit: ns */
        ktime_t target_expiration;
        u32 timer_mode;
        u32 timer_mode_mask;
        u64 tscdeadline;
        // 通过blame看到最开始是tscdeadline模式下给advanced timer用
        u64 expired_tscdeadline;
        u32 timer_advance_ns;
        s64 advance_expire_delta;
        atomic_t pending;                       /* accumulated triggered timers */
        bool hv_timer_in_use;
};
```

# 3. 创建和初始化虚拟定时器设备

由于APIC Timer设备实际就是**lapic**的一个**功能**, 所以在创建lapic设备同时, 也就辅助设置了. 

不存在qemu侧流程

```cpp
int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
{
        ......
        // 建立hrtimer定时器, 回调函数 apic_timer_fn
        hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,
                     HRTIMER_MODE_ABS_HARD);
        // hrtimer定时器回调函数, 即APIC Timer设备产生中断的函数
        apic->lapic_timer.timer.function = apic_timer_fn;
        ......
}
```

该如何模拟APIC Timer设备呢？对于**周期性时钟中断**, 我们可以采用**定时器方式**, **一定间隔**调用一次**中断源产生函数**, **模拟时钟中断发生**. 

首先创建一个**定时器**, 然后初始化**APIC Timer设备**产生**中断的函数**, 实际就是定时器回调函数. 


查看:

```
/sys/kernel/debug/kvm/97073-19/vcpu3/lapic_timer_advance_ns
```

# 4. 配置定时器模式: 写LVTT

```cpp
void kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
{
        case APIC_LVTT:
                if (!kvm_apic_sw_enabled(apic))
                        val |= APIC_LVT_MASKED;
                val &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);
                kvm_lapic_set_reg(apic, APIC_LVTT, val);
                apic_update_lvtt(apic);
                break;
}
```

# 5. 设置定时器: 写TMICT或TSC-Deadline



## 5.1. 定时器的触发

```cpp
vmx_handle_exit [kvm_intel]() {
handle_wrmsr [kvm_intel]() {
kvm_set_msr [kvm]() {
vmx_set_msr [kvm_intel]() {
kvm_set_msr_common [kvm]() {
kvm_set_lapic_tscdeadline_msr [kvm]() {

// 写寄存器 TMICT, 初始计数寄存器, one-shot/period
void kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
{
        case APIC_TMICT:
                // tscdeadline模式, 直接忽略返回
                if (apic_lvtt_tscdeadline(apic))
                        break;
                // 取消lapic的hrtimer
                hrtimer_cancel(&apic->lapic_timer.timer);
                // 设置lapic的APIC_TMICT寄存器值
                kvm_lapic_set_reg(apic, APIC_TMICT, val);
                // 启用lapic的timer
                start_apic_timer(apic);
                break;
}
```

```cpp
// 写tscdeadline的msr寄存器, tscdeadline模式, tsc到达触发中断
void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)
{
        struct kvm_lapic *apic = vcpu->arch.apic;
        // lapic 不在内核态实现, 
        // 或lapic处于oneshot模式
        // 或lapic处于周期性模式, 
        // 则直接返回
        if (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||
                        apic_lvtt_period(apic))
                return;
        // 取消lapic的hrtimer
        hrtimer_cancel(&apic->lapic_timer.timer);
        // 设置lapic timer的tscdeadline值
        apic->lapic_timer.tscdeadline = data;
        // 启用lapic的timer
        start_apic_timer(apic);
}
```

启用上面的定时器, 最终会调用apic timer回调函数

## 5.2. 整体流程

```cpp
start_apic_timer()  // 启动apic timer定时器
 ├─ __start_apic_timer(apic, APIC_TMICT); // 传入 TMICT 初始计数寄存器
 |   ├─ atomic_set(&apic->lapic_timer.pending, 0); // 清空lapci timer的pending
 |   ├─ set_target_expiration(apic, count_reg); // 设置到期时间, 当前流程中, 周期性/一次性模式情况下才调用, tscdeadline不会调用
 |   |   ├─ ktime_t now = ktime_get(); // 获取当前ktime
 |   |   ├─ apic->lapic_timer.period = tmict_to_ns(apic, kvm_lapic_get_reg(apic, APIC_TMICT)); // 设置触发周期时间, 即TMICT初始计数寄存器值, 即TMICT寄存器的值(只不过转换成ns单位)
 |   |   ├─ apic->lapic_timer.tscdeadline = 0; return false; // TMICT为0的话, 意味着停止一次性/周期性timer, 则设置tscdeadline为0然后返回
 |   |   ├─ limit_periodic_timer_frequency(apic); //
 |   |   ├─ deadline = apic->lapic_timer.period; // 等于TMICT
 |   |   ├─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, deadline); // tscdeadline设置, 虚拟机tsc+deadline
 |   |   └─ apic->lapic_timer.target_expiration = ktime_add_ns(now, deadline); // target_expiration设置, now + deadline
 |   └─ restart_apic_timer();  // 重启定时器
 |       ├─ preempt_disable(); // 关闭抢占
 |       ├─ !period(apic) && pending; return;// 如果apic timer当前不是周期模式(即一次性/tscdeadline模式)而且有pending事件, 直接返回, 不重启
 |       ├─ start_hv_timer(); // 优先使用hv timer, 即preemption timer
 |       |   ├─ kvm_can_use_hv_timer(vcpu); // 不能使用hv timer, 则直接返回false
 |       |   ├─ !apic->lapic_timer->tscdeadline; return false// tscdeadline是0, 则直接返回false
 |       |   ├─ kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired); // 设置vmx->hv_deadline_tsc, 失败则直接返回false
 |       |   |   ├─ guest_tscl = kvm_read_l1_tsc(vcpu, tscl);// 获取虚拟机tsc 
 |       |   |   ├─ delta_tsc = max(ktimer->tscdeadline, guest_tscl) - guest_tscl;// 虚拟机tscdeadline的tsc差值
 |       |   |   ├─ vmx->hv_deadline_tsc = tscl + delta_tsc;// 设置hv_deadline_tsc
 |       |   |   └─ *expired = !delta_tsc; // 设置是否到期
 |       |   ├─ ktimer->hv_timer_in_use = true; // 设置apic timer的hv timer在使用
 |       |   ├─ hrtimer_cancel(&ktimer->timer); // 取消hrtimer定时器
 |       |   ├─ cancel_hv_timer(apic); // 非周期性且有timer pending, 取消hv timer
 |       |   |   ├─ kvm_x86_ops.cancel_hv_timer(apic->vcpu); // 取消hv timer
 |       |   |   |   └─ to_vmx(vcpu)->hv_deadline_tsc = -1; // 
 |       |   |   └─ ktimer->hv_timer_in_use = false; // 设置apic timer的hv timer不在使用
 |       |   ├─ apic_timer_expired(apic, false); // 非周期性, 没有pending且已经到期, 
 |       |   |   ├─ kvm_get_running_vcpu();
 |       |   |   └─ kvm_apic_local_deliver(); //
 |       |   |       └─ __apic_accept_irq();
 |       |   |           └─ vmx_deliver_posted_interrupt();
 |       |   |               └─ kvm_get_running_vcpu();
 |       |   └─ cancel_hv_timer(vcpu); // 非周期性, 没有pending且已经到期, 取消hv timer
 |       |   |   └─ vmx_cancel_hv_timer(); //
 |       ├─ start_sw_timer(); // 不能使用hv timer, 则使用sw timer
 |       |   ├─ cancel_hv_timer(); // 如果hv timer在使用, 则取消hv timer
 |       |   ├─ (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending)); return; // 如果不是周期性的, 但是存在pending, 直接返回
 |       |   ├─ start_sw_period(); // 周期性或一次性模式, 调用这个
 |       |   |   ├─ (!apic->lapic_timer.period); return; // 如果周期为0(一般是TMICT), 表明停用one-shot或period, 直接返回
 |       |   |   ├─ apic_timer_expired(apic, false); // 当前时间晚于target_expiration, 即已经过期, 则直接注入pending timer irq
 |       |   |   ├─ apic_lvtt_oneshot(apic); return;// 已经到期并且是一次性模式, 则直接结束, 返回
 |       |   |   ├─ advance_periodic_target_expiration();// 已经过期, 对于周期性的, 设置周期性下一次目标超时时间
 |       |   |   |   ├─ apic->lapic_timer.target_expiration = ktime_add_ns(apic->lapic_timer.target_expiration, apic->lapic_timer.period) // 下一个周期的超时时间
 |       |   |   |   ├─ delta = ktime_sub(apic->lapic_timer.target_expiration, now); // 下一个周期的超时时间和现在时间的差值
 |       |   |   |   └─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, delta); // 设置tscdeadline = 虚拟机中当前tsc + 差值
 |       |   |   └─ hrtimer_start(lapic_timer.timer, apic->lapic_timer.target_expiration, HRTIMER_MODE_ABS_HARD); // 启用hrtimer, 一次性或者周期性的
 |       |   └─ start_sw_tscdeadline(vcpu); // tscdeadline模式, 调用这个
 |       |   |   ├─ tscdeadline = ktimer->tscdeadline; // 获取apic timer的tscdeadline值
 |       |   |   ├─ local_irq_save(flags); // 关闭中断
 |       |   |   ├─ ns = (tscdeadline - guest_tsc) * 1000000ULL; // 根据vcpu tsc频率得到目标tscdeadline与虚拟机tsc差值, ns单位
 |       |   |   ├─ do_div(ns, this_tsc_khz); // 根据vcpu的tsc计数频率计算差
 |       |   |   ├─ hrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD); // 当还没有到期并且差值大于advanced timer调整时间, 即没有超时, 则启用hrtimer
 |       |   |   ├─ apic_timer_expired(apic, false); // 已经到期了
 |       |   |   └─ local_irq_restore(flags); // 恢复中断
 |       └─ preempt_enable(); // 打开抢占
```

## 5.3. 入口代码

```cpp
// Timer initial counter register, timer初始计数寄存器
#define APIC_TMICT 0x380

// arch/x86/kvm/lapic.c
static void start_apic_timer(struct kvm_lapic *apic)
{
        // APIC_TMICT 是初始计数寄存器
        __start_apic_timer(apic, APIC_TMICT);
}

static void __start_apic_timer(struct kvm_lapic *apic, u32 count_reg)
{
        // 清空lapci timer的pending
        atomic_set(&apic->lapic_timer.pending, 0);
        // APIC timer是周期性模式或者一次性模式 并且
        // 设置到期时间失败的话, 直接返回
        // 当前流程 count_reg 是 APIC_TMICT
        if ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))
            && !set_target_expiration(apic, count_reg))
                return;
        // 重启apic timer定时器
        restart_apic_timer(apic);
}
```

只有**周期性/一次性**模式, 才会去调用`set_target_expiration()`**设置目标过期时间**, 再调用`restart_apic_timer()`, 启用apic timer定时器.

如果是**周期性/一次性**模式的话, 但是`set_target_expiration()`返回false的话, 直接返回, 也就是停止timer. 结合代码可以看到, 停止也就是周期性/一次性模式下设置TMICT为0, 符合APIC的硬件语义.

对于tscdeadline模式, 直接调用`restart_apic_timer()`, 启用apic timer定时器

## 5.4. set_target_expiration(): 设置目标过期时间

当前流程中, 只有**周期性/一次性**模式才调用, tscdeadline模式不调用

```cpp
// 这个函数本身是都会调用, 不限于周期性/一次性
// 根据传入的count_reg计数寄存器(apic的一个寄存器)设置到期时间
static bool set_target_expiration(struct kvm_lapic *apic, u32 count_reg)
{
        ktime_t now;
        // 读取当前tsc
        u64 tscl = rdtsc();
        s64 deadline;
        // 当前ktime
        now = ktime_get();
        // 获取TMICT寄存器值, 设置触发周期时间
        // 即, TMICT初始计数寄存器值(转换成ns单位)
        apic->lapic_timer.period =
                        tmict_to_ns(apic, kvm_lapic_get_reg(apic, APIC_TMICT));
        // 如果初始计数寄存器值为0, 则是停止one shot/period
        if (!apic->lapic_timer.period) {
                // 设置tscdeadline为0, 返回false
                apic->lapic_timer.tscdeadline = 0;
                return false;
        }

        // 再往下面, 说明period即TMICT不为0, 即已经有初始计数值了
        limit_periodic_timer_frequency(apic);
        // deadline就是TMICT初始计数寄存器的值(只不过转换成ns单位)
        deadline = apic->lapic_timer.period;
        // 周期性/一次性时
        if (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {
                // 传入的不是TMICT寄存器时, 当前流程不进入
                if (unlikely(count_reg != APIC_TMICT)) {
                        // deadline是count_reg寄存器值(只不过转换成ns单位)
                        deadline = tmict_to_ns(apic,
                                     kvm_lapic_get_reg(apic, count_reg));
                        // count_reg寄存器值小于0的话, 还是使用TMICT寄存器值
                        if (unlikely(deadline <= 0))
                                // deadline 还是 TMICT
                                deadline = apic->lapic_timer.period;
                        // count_reg寄存器值大于TMICT值, 即大于初始计数器值
                        // 使用TMICT值
                        else if (unlikely(deadline > apic->lapic_timer.period)) {
                                pr_info_ratelimited(
                                    "kvm: vcpu %i: requested lapic timer restore with "
                                    "starting count register %#x=%u (%lld ns) > initial count (%lld ns). "
                                    "Using initial count to start timer.\n",
                                    apic->vcpu->vcpu_id,
                                    count_reg,
                                    kvm_lapic_get_reg(apic, count_reg),
                                    deadline, apic->lapic_timer.period);
                                // 设置传入的count_reg寄存器为0
                                kvm_lapic_set_reg(apic, count_reg, 0);
                                // deadline等于 TMICT
                                deadline = apic->lapic_timer.period;
                        }
                }
        }
        // tscdeadline值 = 虚拟机tsc + deadline
        apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +
                nsec_to_cycles(apic->vcpu, deadline);
        // 到期时间 = now + deadline
        apic->lapic_timer.target_expiration = ktime_add_ns(now, deadline);

        return true;
}
```

1. 将TMICT初始计数寄存器值(转换成ns单位)作为lapic timer的触发周期, `apic->lapic_timer.period`

`tmict_to_ns()` 用于将**初始计数值**转换成ns单位, 初始计数值类似于TMICT寄存器的值.

```cpp
#define APIC_BUS_CYCLE_NS 1
static inline u64 tmict_to_ns(struct kvm_lapic *apic, u32 tmict)
{
        // 根据clock时钟频率将tmict(初始计数)转换成ns单位
        return (u64)tmict * APIC_BUS_CYCLE_NS * (u64)apic->divide_count;
}
```

2. 计算deadline, 默认TMICT寄存器的值; 
3. 设置`apic->lapic_timer.tscdeadline`为 `虚拟机tsc + deadline`
4. 设置`apic->lapic_timer.target_expiration`为 `ktime_get() + deadline`

## 5.5. restart_apic_timer(): 重启apic timer定时器

```cpp
static void restart_apic_timer(struct kvm_lapic *apic)
{
        preempt_disable();
        // 不是周期性模式 并且
        // apic timer有pending事件, 直接退出
        if (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))
                goto out;
        // 优先使用hv timer
        if (!start_hv_timer(apic))
                start_sw_timer(apic);
out:
        preempt_enable();
}
```

如果**不是周期性模式**时(即**一次性/tscdeadline模式**), 而apic timer**有pending事件**, 则不启动timer, 直接退出.

先试图启用hv timer, 如果启动失败, 则使用sw timer.

### 5.5.1. start_hv_timer(): 优先使用hv timer

这个就是`preemption timer`

```cpp

static bool start_hv_timer(struct kvm_lapic *apic)
{
        // 获取apic timer
        struct kvm_timer *ktimer = &apic->lapic_timer;
        struct kvm_vcpu *vcpu = apic->vcpu;
        bool expired;

        WARN_ON(preemptible());
        // 判断能不能使用hv_timer
        if (!kvm_can_use_hv_timer(vcpu))
                return false;
        // tscdeadline是0, 直接返回false
        if (!ktimer->tscdeadline)
                return false;
        // 对应vmx的vmx_set_hv_timer, 设置vmx->hv_deadline_tsc
        // 设置失败, 直接返回false
        if (kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired))
                return false;
        // 设定hv timer正在使用
        ktimer->hv_timer_in_use = true;
        // 取消lapic hrtimer
        hrtimer_cancel(&ktimer->timer);

        /*
         * To simplify handling the periodic timer, leave the hv timer running
         * even if the deadline timer has expired, i.e. rely on the resulting
         * VM-Exit to recompute the periodic timer's target expiration.
         */
        // 非周期性, 也就是one-shot或tscdeadline模式
        if (!apic_lvtt_period(apic)) {
                /*
                 * Cancel the hv timer if the sw timer fired while the hv timer
                 * was being programmed, or if the hv timer itself expired.
                 */
                // timer pending事件存在
                if (atomic_read(&ktimer->pending)) {
                        // 取消hv timer
                        cancel_hv_timer(apic);
                // 没有pending, 已经到期
                } else if (expired) 
                        apic_timer_expired(apic, false);
                        // 取消hv timer
                        cancel_hv_timer(apic);
                }
        }

        trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);

        return true;
}
```

1. 判断能否使用hv timer, 不能使用即退出

```cpp
bool kvm_can_use_hv_timer(struct kvm_vcpu *vcpu)
{
        return kvm_x86_ops.set_hv_timer
               // mwait没有透传, 或kvm不能能够post timer interrupt
               && !(kvm_mwait_in_guest(vcpu->kvm) ||
                    kvm_can_post_timer_interrupt(vcpu));
}
```

mwait指令没有透传给虚拟机, 或者不能够post timer interrupt, 这个都不成立, 则表明能够使用hv timer, 为什么???

preemption只有vcpu run才会生效, 非透传下虚拟机pause不会vmexit, 而hlt会



2. 设置hv timer, 调用vmx的`vmx_set_hv_timer`, 设置`vmx->hv_deadline_tsc`, 设置失败则直接返回

```cpp
static int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,
                            bool *expired)
{
        struct vcpu_vmx *vmx;
        u64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;
        // 获取lapic timer
        struct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;

        vmx = to_vmx(vcpu);
        // 读取host tsc
        tscl = rdtsc();
        // 读取guest tsc ???
        guest_tscl = kvm_read_l1_tsc(vcpu, tscl);
        // 虚拟机tscdeadline到期的差值, 可能是0
        delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;
        // timer advanced 
        lapic_timer_advance_cycles = nsec_to_cycles(vcpu,
                                                    ktimer->timer_advance_ns);

        if (delta_tsc > lapic_timer_advance_cycles)
                // tscdeadline到期的差值大于advanced time, 则减去这个advanced time
                delta_tsc -= lapic_timer_advance_cycles;
        else
                delta_tsc = 0;

        /* Convert to host delta tsc if tsc scaling is enabled */
        if (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&
            delta_tsc && u64_shl_div_u64(delta_tsc,
                                kvm_tsc_scaling_ratio_frac_bits,
                                vcpu->arch.tsc_scaling_ratio, &delta_tsc))
                return -ERANGE;

        /*
         * If the delta tsc can't fit in the 32 bit after the multi shift,
         * we can't use the preemption timer.
         * It's possible that it fits on later vmentries, but checking
         * on every vmentry is costly so we just use an hrtimer.
         */
        if (delta_tsc >> (cpu_preemption_timer_multi + 32))
                return -ERANGE;
        // 让下次到期的tsc, 经过advanced time调整了, 所以会更提前到期
        vmx->hv_deadline_tsc = tscl + delta_tsc;
        // tsc差是0, 表明已经过期
        *expired = !delta_tsc;
        return 0;
}
```

其实就是设置`vmx->hv_deadline_tsc = tscl + delta_tsc;`

3. 对于**非周期性**(即`tscdeadline`或`one-shot`)
* 如果已经有pending的, 则取消hv timer后返回; 
* 如果没有timer pending且已经到期, 调用`apic_timer_expired()`再取消hv timer.

```cpp
static void cancel_hv_timer(struct kvm_lapic *apic)
{
        WARN_ON(preemptible());
        WARN_ON(!apic->lapic_timer.hv_timer_in_use);
        // 调用 vmx_cancel_hv_timer
        kvm_x86_ops.cancel_hv_timer(apic->vcpu);
        // hv timer设为不在用
        apic->lapic_timer.hv_timer_in_use = false;
}
```

```cpp
static void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)
{
        // 设置hv_deadline_tsc 为 -1
        to_vmx(vcpu)->hv_deadline_tsc = -1;
}
```

注: 很明显, kvm-unit-test的`tscdeadline_immed`会走这个到这个`apic_timer_expired()`流程

### 5.5.2. start_sw_timer(): 使用sw timer

```cpp
static void start_sw_timer(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;

        WARN_ON(preemptible());
        // hv timer在使用, 则取消
        if (apic->lapic_timer.hv_timer_in_use)
                cancel_hv_timer(apic);
        // 不是周期性, 但是存在pending, 直接返回
        if (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))
                return;
        // 周期性或一次性模式
        if (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))
                start_sw_period(apic);
        // tscdeadline模式
        else if (apic_lvtt_tscdeadline(apic))
                start_sw_tscdeadline(apic);
        trace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);
}
```

1. 如果hv timer在使用, 则取消;
2. 对于非周期性但是却存在pending的, 直接返回;
3. 针对周期性或一次性的, 调用`start_sw_period()`;
4. 针对tscdeadline的, 调用`start_sw_tscdeadline()`;

#### 5.5.2.1. start_sw_period(): 周期性或一次性模式

使用`apic->lapic_timer.target_expiration`

```cpp
static void start_sw_period(struct kvm_lapic *apic)
{
        // 周期为0, 直接返回
        if (!apic->lapic_timer.period)
                return;
        // 当前时间晚于 target_expiration
        if (ktime_after(ktime_get(),
                        apic->lapic_timer.target_expiration)) {
                // 已经过期了, 处理
                apic_timer_expired(apic, false);
                // oneshot的话, 不用做什么了, 直接返回
                if (apic_lvtt_oneshot(apic))
                        return;
                // 周期性的, 设置下个周期的超时时间 target_expiration
                advance_periodic_target_expiration(apic);
        }
        // 启用hrtimer, 超时时间是apic->lapic_timer.target_expiration
        hrtimer_start(&apic->lapic_timer.timer,
                apic->lapic_timer.target_expiration,
                HRTIMER_MODE_ABS_HARD);
}
```

1. 如果**周期为0**(一般是TMICT初始计数寄存器值), 表明**停用oneshot或者周期性**, 则直接返回, 不启用
2. 如果当前时间晚于目标过期时间, 即**已经过期**的:
- 调用`apic_timer_expired()`处理过期, 其中会进行中断注入, 下面详细讲
- 如果是**一次性的话**, 那就此**结束**, 直接返回
- 否则(**周期性**)调用`advance_periodic_target_expiration()`设置**下一次的周期性目标过期时间**
3. 如果没有过期或者已经过期的进行了处理但是是周期性的, 则启动apic timer的hrtimer, 超时时间是`apic->lapic_timer.target_expiration`(`ktime_get() + deadline`), 

apic timer的hrtimer是在lapic创建时候初始化的, 该hrtimer的中断响应回调函数是`apic_timer_fn()`, 详细见`中断虚拟化`部分

```cpp
// 设置周期性的下一次超时时间
static void advance_periodic_target_expiration(struct kvm_lapic *apic)
{
        // 当前时间
        ktime_t now = ktime_get();
        // 当前tsc
        u64 tscl = rdtsc();
        ktime_t delta;

        /*
         * Synchronize both deadlines to the same time source or
         * differences in the periods (caused by differences in the
         * underlying clocks or numerical approximation errors) will
         * cause the two to drift apart over time as the errors
         * accumulate.
         */
        // 设置 target_expiration = 下一个周期的超时时间
        apic->lapic_timer.target_expiration =
                ktime_add_ns(apic->lapic_timer.target_expiration,
                                apic->lapic_timer.period);
        // 下一个周期超时时间和现在时间的差值
        delta = ktime_sub(apic->lapic_timer.target_expiration, now);
        // 设置tscdeadline = 虚拟机中当前tsc + 差值
        apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +
                nsec_to_cycles(apic->vcpu, delta);
}
```

总结: 

- 对于周期性的, 无论如何都会**启用hrtimer**; 
- 对于一次性的, **已经过期的直接注入一次**, 否则**启用hrtimer**

#### 5.5.2.2. start_sw_tscdeadline(): tscdeadline模式

使用`apic->lapic_timer.tscdeadline`

```cpp
static void start_sw_tscdeadline(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;
        u64 guest_tsc, tscdeadline = ktimer->tscdeadline;
        u64 ns = 0;
        ktime_t expire;
        struct kvm_vcpu *vcpu = apic->vcpu;
        unsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;
        unsigned long flags;
        ktime_t now;

        if (unlikely(!tscdeadline || !this_tsc_khz))
                return;
        // 关中断
        local_irq_save(flags);
        // 当前时间
        now = ktime_get();
        // 虚拟机tsc值
        guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
        // 目标tscdeadline与虚拟机tsc差值
        ns = (tscdeadline - guest_tsc) * 1000000ULL;
        // 根据vcpu tsc计数频率得到差值的ns单位值
        do_div(ns, this_tsc_khz);
        // tscdeadline大于虚拟机当前tsc, 即没有超时
        // 并且差值大于advanced timer调整的时间
        if (likely(tscdeadline > guest_tsc) &&
            likely(ns > apic->lapic_timer.timer_advance_ns)) {
                // tscdeadline的到期时间
                expire = ktime_add_ns(now, ns);
                // advanced timer进行的调整
                expire = ktime_sub_ns(expire, ktimer->timer_advance_ns);
                // 启用hrtimer, 超时时间是expire
                hrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD);
        } else
                // timer超时, 直接注入
                apic_timer_expired(apic, false);
        // 恢复中断
        local_irq_restore(flags);
}
```
不存在周期性的说法

1. 关闭中断
2. 
3. 恢复中断 

# 6. timer到期

步骤三和步骤四

涉及到 “acknowledge interrupt on exit” 机制, 可以参见intel手册关于外部中断部分.

有两个相关commit: 

f2485b3e0c6c0aa3a9546babc2fad3739e964ebb

d7a08882a0a4b4e176691331ee3f492996579534

在`vm-entry`之前, 会调用`vmx_update_hv_timer(vcpu);`

在`vm-entry`之前, 会调用`kvm_wait_lapic_expire(vcpu);`

## 6.1. preemption timer到期

### 6.1.1. 整体流程

```cpp
handle_preemption_timer()  // preemption timer处理
 ├─ handle_fastpath_preemption_timer(vcpu); // 
 |   ├─ kvm_lapic_expired_hv_timer(vcpu); // 清空lapci timer的pending
 |   |   ├─ preempt_disable(); // 禁用抢占
 |   |   ├─ cancel_hv_timer(apic); // 取消hv timer
 |   |   |   ├─ kvm_x86_ops.cancel_hv_timer(apic->vcpu); // 取消hv timer
 |   |   |   |   └─ to_vmx(vcpu)->hv_deadline_tsc = -1; // 
 |   |   |   └─ ktimer->hv_timer_in_use = false; // 设置apic timer的hv timer不在使用
 |   |   ├─ apic_timer_expired(apic, false); // 
 |   |   |   ├─ kvm_get_running_vcpu();
 |   |   |   └─ kvm_apic_local_deliver(); //
 |   |   |   |   └─ __apic_accept_irq();
 |   |   |   |       └─ vmx_deliver_posted_interrupt();
 |   |   |   |           └─ kvm_get_running_vcpu();
 |   |   ├─ apic_lvtt_period() && apic->lapic_timer.period; // 周期性的
 |   |   |   ├─ advance_periodic_target_expiration();// 已经过期, 对于周期性的, 设置周期性下一次目标超时时间
 |   |   |   |   ├─ apic->lapic_timer.target_expiration = ktime_add_ns(apic->lapic_timer.target_expiration, apic->lapic_timer.period) // 下一个周期的超时时间
 |   |   |   |   ├─ delta = ktime_sub(apic->lapic_timer.target_expiration, now); // 下一个周期的超时时间和现在时间的差值
 |   |   |   |   └─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, delta); // 设置tscdeadline = 虚拟机中当前tsc + 差值
 |   |   |   └─ restart_apic_timer();  // 重启定时器
 |   |   └─ preempt_disable(); // 打开抢占
```

### 6.1.2. handle_preemption_timer(): 到期vmexit处理函数

preemption timer到期会发生vmexit, exit reason就是`preemption timer`, 最终在`vmx_handle_exit`中调用了`handle_preemption_timer`

两种情况调用:

1. `CONFIG_RETPOLINE`下直接调用并return

```cpp
#ifdef CONFIG_RETPOLINE
        if (exit_reason == EXIT_REASON_MSR_WRITE)
                return kvm_emulate_wrmsr(vcpu);
        else if (exit_reason == EXIT_REASON_PREEMPTION_TIMER)
                return handle_preemption_timer(vcpu);
        ......
#endif
```

2. 或者在函数最后调用

```cpp
return kvm_vmx_exit_handlers[exit_reason](vcpu);
```

### 6.1.3. preemption timer处理

```cpp
static int handle_preemption_timer(struct kvm_vcpu *vcpu)
{
        handle_fastpath_preemption_timer(vcpu);
        return 1;
}

static fastpath_t handle_fastpath_preemption_timer(struct kvm_vcpu *vcpu)
{
        struct vcpu_vmx *vmx = to_vmx(vcpu);

        if (!vmx->req_immediate_exit &&
            !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled)) {
                kvm_lapic_expired_hv_timer(vcpu);
                return EXIT_FASTPATH_REENTER_GUEST;
        }

        return EXIT_FASTPATH_NONE;
}
```

```cpp
// arch/x86/kvm/lapic.c
void kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)
{
        struct kvm_lapic *apic = vcpu->arch.apic;

        preempt_disable();
        /* If the preempt notifier has already run, it also called apic_timer_expired */
        if (!apic->lapic_timer.hv_timer_in_use)
                goto out;
        WARN_ON(rcuwait_active(&vcpu->wait));
        cancel_hv_timer(apic);
        apic_timer_expired(apic, false);

        if (apic_lvtt_period(apic) && apic->lapic_timer.period) {
                advance_periodic_target_expiration(apic);
                restart_apic_timer(apic);
        }
out:
        preempt_enable();
}
```

## 6.2. hrtimer到期的外部中断

### 6.2.1. 整体流程

```cpp
// hrtimer到期处理函数
apic_timer_fn()  // hrtimer到期处理函数
 ├─ apic_timer_expired(apic, false); // 已经到期了
 |   ├─ set_target_expiration(apic, count_reg); // 
 ├─ lapic_is_periodic(apic) // 周期性
 |   ├─ advance_periodic_target_expiration(apic); // 设置周期性的目标过期时间
 |   ├─ hrtimer_add_expires_ns(&ktimer->timer, ktimer->period); // 修改hrtimer, 以便再次重启使用 
 |   └─ return HRTIMER_RESTART; // 周期性的, 所以重启hrtimer
 └─ return HRTIMER_NORESTART; // one-shot/tscdeadline模式, 不重启hrtimer
```

### 6.2.2. apic_timer_fn(): hrtimer到期的响应函数

hrtimer到期后的响应函数

```cpp
static enum hrtimer_restart apic_timer_fn(struct hrtimer *data)
{
        struct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);
        struct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);
        // 到期处理函数
        apic_timer_expired(apic, true);
        // 周期性
        if (lapic_is_periodic(apic)) {
                // 设置周期性的下一次目标超时时间
                advance_periodic_target_expiration(apic);
                // 修改hrtimer
                hrtimer_add_expires_ns(&ktimer->timer, ktimer->period);
                // 重启hrtimer
                return HRTIMER_RESTART;
        } else
                // 一次性或tscdeadline, 不重启
                return HRTIMER_NORESTART;
}
```


## 6.3. apic_timer_expired(): apic timer已经到期处理

无论`hvtimer(preemption timer)`还是`sw timer`, 都可能会调用到

```cpp
static void apic_timer_expired(struct kvm_lapic *apic, bool from_timer_fn)
{
        struct kvm_vcpu *vcpu = apic->vcpu;
        struct kvm_timer *ktimer = &apic->lapic_timer;
        // 如果有pending, 返回
        if (atomic_read(&apic->lapic_timer.pending))
                return;
        // tscdeadline模式或者hv timer在使用
        if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
                // 设置 expired_tscdeadline
                ktimer->expired_tscdeadline = ktimer->tscdeadline;
        // 不是从timer回调函数过来的 并且 apicv激活
        if (!from_timer_fn && vcpu->arch.apicv_active) {
                WARN_ON(kvm_get_running_vcpu() != vcpu);
                // 注入pending timer irq
                kvm_apic_inject_pending_timer_irqs(apic);
                return;
        }
        // vcpu使用posted timer interrupt
        if (kvm_use_posted_timer_interrupt(apic->vcpu)) {
                // 等它到期
                if (apic->lapic_timer.timer_advance_ns)
                        __kvm_wait_lapic_expire(vcpu);
                // 注入pending timer irq
                kvm_apic_inject_pending_timer_irqs(apic);
                return;
        }
        // pending加1
        atomic_inc(&apic->lapic_timer.pending);
        // 设置pending
        kvm_set_pending_timer(vcpu);
}
```

```cpp
static void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;

        kvm_apic_local_deliver(apic, APIC_LVTT);
        // 
        if (apic_lvtt_tscdeadline(apic)) {
                // tscdeadline 设为0
                ktimer->tscdeadline = 0;
        } else if (apic_lvtt_oneshot(apic)) {
                // tscdeadline 设为0
                ktimer->tscdeadline = 0;
                // 目标过期时间设为0
                ktimer->target_expiration = 0;
        }
}
```

```cpp
int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)
{
        // 获取lvt寄存器值, 这里是LVT timer寄存器
        u32 reg = kvm_lapic_get_reg(apic, lvt_type);
        int vector, mode, trig_mode;

        if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
                // lvtt的vector
                vector = reg & APIC_VECTOR_MASK;
                // lvtt的mode
                mode = reg & APIC_MODE_MASK;
                // lvtt的trig_mode
                trig_mode = reg & APIC_LVT_LEVEL_TRIGGER;
                // lapic接收中断
                return __apic_accept_irq(apic, mode, vector, 1, trig_mode,
                                        NULL);
        }
        return 0;
}
```

`kvm_apic_local_deliver()`用于传递中断到lapci相应功能单元, `__apic_accept_irq`函数在`中断虚拟化`有分析

```cpp
void kvm_set_pending_timer(struct kvm_vcpu *vcpu)
{
        // 设置vcpu->requests中的KVM_REQ_PENDING_TIMER位为1
        kvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);
        // 唤醒这个vcpu
        kvm_vcpu_kick(vcpu);
}
```



# 7. trace

## 7.1. 使用ftrace

```
cd /sys/kernel/debug/tracing/
echo nop > current_tracer
echo 0 > tracing_on
echo ':mod:kvm' > set_ftrace_filter
echo ':mod:kvm_amd' >> set_ftrace_filter
echo ':mod:kvm_intel' >> set_ftrace_filter
echo > set_graph_function
echo > set_ftrace_pid
echo pvclock_gtod_notify > set_ftrace_notrace
echo 1 > tracing_on
echo function_graph > current_tracer
```

如果效果不明显, 使用下面类似的

```
cd /sys/kernel/debug/tracing/
echo nop > current_tracer
echo 0 > tracing_on
echo > set_graph_function
echo > set_ftrace_pid
echo > set_ftrace_filter
echo vcpu_enter_guest > set_graph_function
echo handle_exit >> set_graph_function
echo kvm_emulate_wrmsr >> set_graph_function
echo kvm_set_lapic_tscdeadline_msr >> set_graph_function
echo kvm_cpu_has_pending_timer >> set_graph_function
echo kvm_inject_pending_timer_irqs >> set_graph_function
echo pvclock_gtod_notify > set_ftrace_notrace
echo 1 > tracing_on
echo function_graph > current_tracer
```


使用 `kvm-unit-test` 的vmexit中的`tscdeadline`和`tscdeadline_immed`, 当然也可以自己编写`kvm-unit-test`测试

- intel还涉及`preemption timer`和`posted interrupt`
        - intel启用/禁用`preemption timer`会有影响
- AMD也有`posted interrupt`, 但是没有`preemption timer`, 但是AMD有avic
        - AMD启用/禁用avic影响到apicv, 进而影响posted interrupt

### 7.1.1. tscdeadline_immed

### 7.1.2. tscdeadline

1. 仅仅打开tscdeadline, 将代码修改下, 只执行一次

```diff
diff --git a/Makefile b/Makefile
index 0e21a49..625ed48 100644
--- a/Makefile
+++ b/Makefile
@@ -50,7 +50,8 @@ include $(SRCDIR)/$(TEST_DIR)/Makefile

 COMMON_CFLAGS += -g $(autodepend-flags) -fno-strict-aliasing -fno-common
 COMMON_CFLAGS += -Wall -Wwrite-strings -Wempty-body -Wuninitialized
-COMMON_CFLAGS += -Wignored-qualifiers -Werror
+#COMMON_CFLAGS += -Wignored-qualifiers -Werror
+COMMON_CFLAGS += -Wignored-qualifiers

 frame-pointer-flag=-f$(if $(KEEP_FRAME_POINTER),no-,)omit-frame-pointer
 fomit_frame_pointer := $(call cc-option, $(frame-pointer-flag), "")
diff --git a/x86/run b/x86/run
index 8b2425f..a56f822 100755
--- a/x86/run
+++ b/x86/run
@@ -37,7 +37,8 @@ else
        pc_testdev="-device testdev,chardev=testlog -chardev file,id=testlog,path=msr.out"
 fi

-command="${qemu} --no-reboot -nodefaults $pc_testdev -vnc none -serial stdio $pci_testdev"
+#command="${qemu} --no-reboot -nodefaults $pc_testdev -vnc none -serial stdio $pci_testdev"
+command="${qemu} -cpu host,-x2apic --no-reboot -nodefaults $pc_testdev -vnc none -serial stdio $pci_testdev"
 command+=" -machine accel=$ACCEL -kernel"
 command="$(timeout_cmd) $command"

diff --git a/x86/vmexit.c b/x86/vmexit.c
index 47efb63..4cf64a6 100644
--- a/x86/vmexit.c
+++ b/x86/vmexit.c
@@ -462,6 +462,7 @@ static void wr_ibpb_msr(void)
 }

 static struct test tests[] = {
+/*
        { cpuid_test, "cpuid", .parallel = 1,  },
        { vmcall, "vmcall", .parallel = 1, },
 #ifdef __x86_64__
@@ -474,7 +475,9 @@ static struct test tests[] = {
        { outl_elcr_kernel, "outl_to_kernel", .parallel = 1 },
        { mov_dr, "mov_dr", .parallel = 1 },
        { tscdeadline_immed, "tscdeadline_immed", has_tscdeadline, .parallel = 1, },
+*/
        { tscdeadline, "tscdeadline", has_tscdeadline, .parallel = 1, },
+/*
        { self_ipi_sti_nop, "self_ipi_sti_nop", .parallel = 0, },
        { self_ipi_sti_hlt, "self_ipi_sti_hlt", .parallel = 0, },
        { self_ipi_tpr, "self_ipi_tpr", .parallel = 0, },
@@ -496,6 +499,7 @@ static struct test tests[] = {
        { rd_tsc_adjust_msr, "rd_tsc_adjust_msr", .parallel = 1 },
        { NULL, "pci-mem", .parallel = 0, .next = pci_mem_next },
        { NULL, "pci-io", .parallel = 0, .next = pci_io_next },
+*/
 };

 unsigned iterations;
@@ -534,7 +538,8 @@ static bool do_test(struct test *test)

        do {
                tsc_eoi = tsc_ipi = 0;
-               iterations *= 2;
+               //iterations *= 2;
+               iterations = 1;
                t1 = rdtsc();

                if (!test->parallel) {
@@ -544,7 +549,8 @@ static bool do_test(struct test *test)
                        on_cpus(run_test, func);
                }
                t2 = rdtsc();
-       } while ((t2 - t1) < GOAL);
+       //} while ((t2 - t1) < GOAL);
+       } while (0);
        printf("%s %d\n", test->name, (int)((t2 - t1) / iterations));
        if (tsc_ipi)
                printf("  ipi %s %d\n", test->name, (int)(tsc_ipi / iterations));
```


2. 测试有没有preemption timer两种情况的

```diff
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 4ce2ddd..4d769ef 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -118,9 +118,12 @@ static bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)

 bool kvm_can_use_hv_timer(struct kvm_vcpu *vcpu)
 {
+       return false;
+/*
        return kvm_x86_ops.set_hv_timer
               && !(kvm_mwait_in_guest(vcpu->kvm) ||
                    kvm_can_post_timer_interrupt(vcpu));
+*/
 }
 EXPORT_SYMBOL_GPL(kvm_can_use_hv_timer);
```

#### 7.1.2.1. Intel禁用preemption timer

```

```

#### 7.1.2.2. Intel启用preemption timer

```

```

#### 7.1.2.3. AMD启用avic

```

```

#### 7.1.2.4. AMD禁用avic



两种










```cpp
 65)               |        kvm_set_lapic_tscdeadline_msr [kvm]() {
 65)               |          __start_apic_timer [kvm]() {
 65)               |            restart_apic_timer [kvm]() {
 65)   0.124 us    |              kvm_can_use_hv_timer [kvm]();
 65)               |              vmx_set_hv_timer [kvm_intel]() {
 65)   0.128 us    |                kvm_read_l1_tsc [kvm]();
 65)   0.389 us    |              }
 65)               |              apic_timer_expired [kvm]() {
 65)   0.138 us    |                kvm_get_running_vcpu [kvm]();
 65)               |                kvm_apic_local_deliver [kvm]() {
 65)               |                  __apic_accept_irq [kvm]() {
 65)               |                    vmx_deliver_posted_interrupt [kvm_intel]() {
 65)   0.162 us    |                      kvm_get_running_vcpu [kvm]();
 65)   0.413 us    |                    }
 65)   0.713 us    |                  }
 65)   0.943 us    |                }
 65)   1.459 us    |              }
 65)               |              cancel_hv_timer.isra.40 [kvm]() {
 65)   0.125 us    |                vmx_cancel_hv_timer [kvm_intel]();
 65)   0.405 us    |              }
 65)   3.083 us    |            }
 65)   3.329 us    |          }
 65)   3.576 us    |        }
```

可以看到`tscdeadline_immed`是直接




http://chinaunix.net/uid-25739055-id-4092821.html

