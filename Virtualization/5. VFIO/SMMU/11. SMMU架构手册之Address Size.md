
在SMMU中需要考虑三种地址size概念，从系统来的输入地址size，中间地址size(IAS)，以及输出地址size(OAS)。

1. SMMU输入地址size为64bit

NOTE: 可以查看章节3.4.1 Input Address size and virtual address size，它介绍了如何向SMMU提供小的互联或设备地址能力。

2. IAS反映了stage1产生的最大可用的IPA，IPA为stage2的输入。

该术语用来定义中间地址的处理，而不是配置参数。

SMMU最大可用的IPA大小可根据SMMU的实现选项来定义，如：

IAS = MAX(SMMU_IDR0.TIF[0]==1?40:0, SMMU_IDR0.TIF[1]==1?OAS:0)

AArch32 LPAE转换要求支持40bit IPA，而AArch64限制了对最大PA size的最大IPA size。否则，当不实现AArch32 LPAE时，IP A size等于OAS size和PA size，也可能小于40bits。

定义IAS的目的是为了从实现的变量中抽象出来。

3. OAS反映了AArch64转换的最后阶段的最大可用PA输出，必须匹配系统物理地址size。SMMU_IDR5.OAS决定了OAS。AArch32转换的最后阶段通常输出40bits，这可能0扩展为更大的OAS，或截断为更小的OAS。

NOTE: 除了明确说明的外，所有的地址转换和错误检查行为都与Armv8-A一致。

如果SMMU不使能（SMMU_CR0.SMMUEN=0,SMMU_GBPA.ABORT允许bypass），输入的地址直接给输出PA。若事务的输入地址超过OAS size，转换以abort终止且没有event被记录。否则，当SMMU_CR0.SMMUEN=1时，事务将在下面章节描述里做处理。

当stream通过STE.Config[2:0]=0b100选择STE时，事务bypass转换的所有阶段。如果输入的地址超过OAS的地址，事务将以abort终结，stage1地址大小fault F_ADDR_SIZE被记录。

NOTE：在Armv8-A PE侧，当转换的两个阶段都bypass时，stage的address size fault产生，这时输入地址大于PA size（依赖PE是在Arch32还是AArch64状态）。这个行为不会直接转换到SMMU，因为没有有效的配置来选择转换系统（bypass 或disable），因此地址大小一直被检测。

当一个或多个转换stage存在时，stream选择一个STE:

1. 对于输出，如果VA超出相关CD的特定范围时，stage1转换错误（F_TRANSLATION）产生；

A. 对于AArch32 LPAE配置的CD，最大的输入范围固定为32bit，对给定TTB0或TTB1转换表的输入地址范围由T0SZ和T1SZ域决定。

NOTE: TTB0/TTB1转换表输入范围的安排是这样的：在TTB0和TTB1范围之外的32位地址范围，并且最终会导致转换错误。

B. 对于AArch64配置的CD，范围由T0SZ和T1SZ域决定。

i. 对于SMMUv3.0，最多支持49bits(2个48bit TTB0/TTB1);

ii. 对于SMMUv3.1以及以后的版本，当SMMU_IDR5.VAX=1，使用CD.TGX配置为64KB粒度的TTBX最大输入size为52bit。当SMMU_ID R5.VAX=0或TTBX被配置为4K或16K粒度，TTBX最大输入size为48bit。

只有当VA从范围大小的顶部向上符号扩展时，VA才在范围内。虽然TBI配置会有例外。

例如，49bit VA范围（TBI disabled），0x0000FFFFFFFFFFFF和0xFFFF000000000000都在范围内，但0x0001000000000000和0xfffe000000000000不在范围内。更详细的看3.4.1。

2. 转换的输出地址若超出了给定CD的有效IPA范围会导致stage1 address size fault。

A. 对于AArch32 LPAE CD，IPA大小固定为40bit（CD的IPS域被忽略）；

B. 对于AArch64 CD，IPA的大小由CD的IPS域的有效值决定，上限为OAS。

如果bypass stage1（由于STE.Config[0]=0, STE.S1DSS=0b01 或没有实现），输入地址直接作为IPA传递给stage2。若事务的输入地址超过IAS的大小，stage1地址大小错误产生，事务以abort终止且F_ADDR_SIZE被记录。否则，地址可能位于stage2可接受的范围之外。在这种情况下，stage2将检查1中描述，会产生stage2转换错误。

NOTE：TBI配置只有当CD被使用时才被使能，当stage1 bypass或disable时，它会一直disable。

NOTE：SMMU stage1 bypass行为与PE侧stage1 disable但stage2转换相同。SMMU根据IAS检查stage1 bypass地址，IAS可能大于PA(当AArch32 LPAE支持时)。这也支持仅stage2将设备分配给guest虚拟机来变成40bit DMA地址，这是stage2转换的输入。

NOTE: 这也意味着只支持stage2的SMMU实现，或实现了两个stage但只对stage2转换，会产生被标记为来自stage1的错误。

Stage2接受IPA，若不bypass，会检查下列stage2的地址大小：

1. 对于输入，如果IPA超出了STE中的S2T0SZ配置的范围，stage2转换错误产生。

A. 对于AArch32 LPAE配置的STE，输入范围的上限为40bit无论IAS的大小；

B. 对于AArch64 LPAE配置的STE，输入范围的上限为IAS；

C. 对于SMMUv3.1以及之后的版本，OAS=IAS=52，stage2的输入范围限制为48bit，除非STE.S2TG表明为64KB粒度。

NOTE: 对于OAS < 40的系统，这可以保证AArch64 stagea2为接受来自AArch32 stage1的40bit IPA(若SMMU支持AArch32)。

2. 转换的输出地址如果超出有效的PA输出范围会导致stage2 address size fault：

A. 对于AArch64 STE, STE中S2PS域配置的有效值（上限为OAS）;

NOTE：对于SMMUv3.1以及后续版本，若OAS=52且64KB粒度被使用时，有效的大小为52位。

B. 对于AArch32 STE，输入范围固定为40bit，STE.S2PS域被忽略。若OAS小于40，若输出地址在OAS范围之外，地址默认截断来满足OAS。

在这判断后，若stage2的输出地址小于OAS，地址进行0扩展来匹配OAS。

若bypass stage2（由于STE.Config[1]=0或没有实现），IPA直接作为PA输出地址。若IPA在OAS的范围之外，地址默认被阶段来满足OAS。若IPA小于OAS，需要0来扩展。

NOTE: 因为SMMU包含配置结构，这些配置结构在开始TTW前作为验证被检查，可以检测到某些配置错误作为无效的结构配置。包括STE.S2TTB不在stage2输出地址大小的有效范围，或CD.TTBX在stage1输出地址的有效范围。这会导致C_BAD_STE或C_BAD_CD配置错误，而不是address size fault。

