
从前面IOMMU DMA MAP/UNMAP API调用可以知道，DMA MAP时无论是dma_alloc_coherent() 还是dma_map_sg()，最终调用函数__iommu_map()函数。它会计算需要映射的pgsize页表大小和count个数。当支持ops->map_pages时，表示一次可映射多个连续的页，此时会调用arm_lpae_map_pages()，SMMUv3支持此方式。

![2022-08-16-20-47-28.png](./images/2022-08-16-20-47-28.png)

对于DMA UNMAP API，无论是dma_free_coherent()，还是dma_unmap_sg()，最终会调用函数__iommu_dma_unmap()，它首先同样也是获取unmap的pgsize页大小和count个数，然后根据是否支持多页unamp，调用页表unmap函数，对于SMMUv3，调用arm_lpae_unamp_pages()，最后需要对TLB中的缓存进行无效化处理。

![2022-08-16-20-47-35.png](./images/2022-08-16-20-47-35.png)

# 页表的简单介绍

SMMU的页表与MMU的页表两者是一样的，将在ARMv8-A编程指导中做详细介绍，这里仅介绍ARM64的几个基本概念，便于代码和映射和取消映射过程的理解。

这里以4K系统为例，在4K系统上支持的页表大小为4K/2M/1G。其中level3页表项（成为page描述符）指向4K大小的内存页，level2页表项通常指向level3页表项的基地址（此时页表项称为table描述符），但也可以直接指向2M大小的内存（页表项称为block描述符）。下图对三者做简单的描述。

![2022-08-16-20-47-46.png](./images/2022-08-16-20-47-46.png)

另外SMMU的页表属性与CPU的页表属性一样。

# 页表的初始化

在SMMU与IO设备建立关联时会为每个IO设备建立iommu_domain，在最后阶段会与页表建立联系。通过函数alloc_io_pgtable_ops()和free_io_pgtable_ops()进行页表的分配和释放。

这里有多种页表格式，如32位的LPAE，64位的LPAE，同时各自又分为stage1和stage2的格式。这里仅介绍ARM_64_LPAE_S1即64位的LPAE的stage1的页表操作。

页表ARM_64_LPAE_S1的分配函数alloc_io_pgtable_ops()会调用回调arm_64_lpae_alloc_pgtable_s1()，它分配用于表示页表操作的结构体arm_lpae_io_pgtable，并填充其回调函数其中包括map/map_pages/unmap/unmap_pages/iova_to_phys。这些回调函数做页表真正的映射和取消映射操作。后面重点介绍map_pages和unmap_pages。另外就是设置页表的TCR和TTBR寄存器，并分配PGD页表（其他级的页表在动态添加和释放）。

页表ARM_64_LPAE_S1的释放函数free_io_pgtable_ops()会调用__arm_lpae_free_pgtable()逐级递归释放页表，并刷TLB。

# 页表的操作

## 页表的映射过程

页表的映射首先通过函数 arm_lpae_prot_to_pte() 进行页表属性的转换和设置，然后通过函数 __arm_lpae_map() 递归进行每一级的查找，并将最终将物理地址填到最终找到的页表项中，即建立页表项并指向对应的物理内存。

![2022-08-16-20-49-12.png](./images/2022-08-16-20-49-12.png)

这里有两种情况：

1. 在进行下级页表项查找时，下一级页表中还没有建立过映射，即当前页表项指向NULL，此时需要分配下一级页表项，并将当前页表项指向分配的下一级页表项，进行下一级查找；
2. 在进行夏季页表项查找时，若下一级页表项已经存在，这时在下一级页表项中找到对应的页表项，进行下一级查找；

这里以下图例子来说明这两种情况：

![2022-08-16-20-49-18.png](./images/2022-08-16-20-49-18.png)

分别建立两个4K页的映射，上面的情况是在level2时可以找到下一级页表（之前应该有其他映射建立），此时找到level3中对应的页表项，建立起映射即可；

下面的情况是level2指向的level3页表还没有建立，此时需要分配物理内存建立页表，并将level2的页表项指向level3的页表。

3.2 页表的取消映射过程
页表的取消映射过程通过函数arm_lpae_unmap_pages()实现，它需要找到对应的页表项，清除页表，并进行TLB无效化。



当前级的block大小与需要unmap的页大小相等时，表明找到对应需要映射的位置，但这里也有几种情况：

当前页表项为非叶子节点，这种情况表示下一级全部属于当前映射，这时需要无效化下一级页表，并释放物理页；
当前页表项为叶子节点，这种情况即block/page页表情况，这时无效化叶子节点页表项即可；
这里以下图来说明这两种情况：



如上图，需要unmap的大小为2M大小，因此该大小与level2的block相等，此时找到level2对应的页表项，在上面的情况中，页表项为非叶子节点，此时指向的下一级页表为需要取消的映射范围，这时需要对下一级页表所有的页表项清除，并进行TLB无效化。在下面一种情况时，页表项为叶子节点，直接指向一块2M大小的物理内存，此时对当前页表项清除，并进行TLB无效化即可。

实际上还有一种情况：虽然需要unmap的页大小与当前级的block大小相等，但是需要unmap的大小需要横跨两个页表，此时需要分别对两部分进行unmap。

这里仍以图来说明：



本例中需要unmap的大小仍为2M，但是并不是在level2中的一个页表项来表示，而是横跨两个页表项，且各占1M，这时在level3上有两个页表与之对应，这时是先处理第一个页表的部分，在处理第二个页表的部分。

https://blog.csdn.net/flyingnosky/article/details/122951474