
前面我们对VFIO框架原理进行了简要的介绍, 本文则主要探讨一下VFIO实现中的几个技术关键点, 主要包括:

VFIO中如实现对直通设备的I/O地址空间访问的?
VFIO中如实现对直通设备的PCI 配置空间, PCI BAR空间, I/O Port, MMIO的访问支持?
VFIO中如何实现MSI/MSI-X, Interrupt Remapping, 以及Posted Interrupt的支持?
VFIO中是如何实现DMA Remapping的?
VFIO中是如何支持设备热插拔的?

# VFIO中如实现对直通设备的I/O地址空间访问

在设备直通的场景下guest OS到底该如何访问设备I/O空间? 有两种方法可选:

方法A: 直接呈现, 将设备在主机上的PCI BAR呈现给guest, 并通过VMCS的I/O bitmap和EPT页表使guest访问设备的PIO和MMIO都不引起VM-Exit, 这样guest驱动程序可以直接访问设备的I/O地址空间.

方法B: 建立转换表, 呈现虚拟的PCI BAR给guest, 当guest访问到虚拟机的I/O地址空间时VMM截获操作并通过转换表将I/O请求转发到设备在主机上的I/O地址空间上.

方法A看起来很高效, 因为直接呈现的方式下不引入VM-Exit, 但实际上是有问题的! 原因是: 设备的PCI BAR空间是由host的BIOS配置并由host操作系统直接使用的, guest的PCI BAR空间是由guest的虚拟BIOS(例如Seabios)配置的, 那么问题来了, 到底该由谁来配置设备的PCI BAR空间呢? 肯定不能两个都生效否则就打架了! 我们应该阻止guest来修改真实设备的PCI BAR地址以防止造成host上PCI设备的BAR空间冲突导致可能出现的严重后果.

所以我们要选择方案B, 建立转换表, 明白这一点很重要!

对于直通设备的PIO访问而言, 通过设置VMCS的I/O bitmap控制guest访问退出到VMM中然后通过转换表(模拟的方式)将PIO操作转发到真实物理设备上. 对于MMIO的访问, 可以通过EPT方式将虚拟的MMIO地址空间映射到物理设备的MMIO地址空间上, 这样guest访问MMIO时并不需要VM-Exit.

## 直通设备的PCI Config Space模拟

PCI配置空间是用来报告设备I/O信息的区域, 可以通过PIO或者MMIO方式进行访问. 设备直通场景的配置空间并不直接呈现给guest而是由VFIO配合qemu进行模拟的.

vfio_realize函数中, QEMU会读取物理设备的PCI配置空间以此为基础然后对配置空间做些改动然后呈现给虚拟机.

```cpp
    /* Get a copy of config space */  // 读取设备的原始PCI Config Space信息
    ret = pread(vdev->vbasedev.fd, vdev->pdev.config,
                MIN(pci_config_size(&vdev->pdev), vdev->config_size),
                vdev->config_offset);   // 调用vfio-pci内核中的vfio_pci_read实现
    ......              
    /* vfio emulates a lot for us, but some bits need extra love */
    vdev->emulated_config_bits = g_malloc0(vdev->config_size);
    // 我们可以选择性的Enable/Disable一些Capability
    /* QEMU can choose to expose the ROM or not */
    memset(vdev->emulated_config_bits + PCI_ROM_ADDRESS, 0xff, 4);
    /* QEMU can also add or extend BARs */
    memset(vdev->emulated_config_bits + PCI_BASE_ADDRESS_0, 0xff, 6 * 4);
    // 调用vfio_add_emulated_word修改模拟的PCI配置空间信息
    vfio_add_emulated_word
    /*
     * Clear host resource mapping info.  If we choose not to register a
     * BAR, such as might be the case with the option ROM, we can get
     * confusing, unwritable, residual addresses from the host here.
     */
    memset(&vdev->pdev.config[PCI_BASE_ADDRESS_0], 0, 24);
    memset(&vdev->pdev.config[PCI_ROM_ADDRESS], 0, 4);
    vfio_bars_prepare(vdev);    // 重点分析
    vfio_bars_register(vdev);   // 重点分析
    vfio_add_capabilities(vdev, errp);
```

通常MSI/MSIX等信息都需要被QEMU修改, 因为这些都是QEMU使用VFIO去模拟的.

## 直通设备MMIO(BAR空间)映射

vfio_realize函数中会对直通设备的MMIO空间进行映射, 大致包含以下几个步骤:

* 调用vfio_populate_device从VFIO中查询出设备的BAR空间信息
* 把设备的MMIO(BAR空间)重映射(mmap)到QEMU进程的虚拟地址空间
* 将该段虚拟机地址空间标记为RAM类型注册给虚拟机

这样一来, guest访问MMIO地址空间时直接通过EPT翻译到HPA不需要VM-Exit.我们分析下具体流程:

```cpp
vfio_realize
    |-> vfio_populate_device
            |-> vfio_region_setup  
                    |-> vfio_get_region_info   // call ioct VFIO_DEVICE_GET_REGION_INFO
                    |-> memory_region_init_io  // init region->mem MR as I/O
    |-> vfio_bars_prepare -> vfio_bar_prepare  // probe info of each pci bar from PCI cfg space
    |-> vfio_bars_register -> vfio_bar_register
            |-> memory_region_init_io // int bar->mr
            |-> memory_region_add_subregion // add bar->mr into region->mem MR
            |-> vfio_region_mmap
                |-> mmap // map device bar space into QEMU process address space -> iova
                |-> memory_region_init_ram_device_ptr // register iova into VM  physical AS
                |-> memory_region_add_subregion // add region->mmaps[i]. mem into region->mem MR
            |-> pci_register_bar
```

为了方便理解这个过程, 我画了一张示意图:

![2021-09-22-16-29-03.png](. /images/2021-09-22-16-29-03.png)

QEMU首先调用vfio_region_mmap, 通过mmap region->vbasedev->fd 把设备MMIO映射到QEMU进程的虚拟地址空间, 这实际上通过调用vfio-pci内核驱动vfio_pci_mmap -> remap_pfn_range, remap_pfn_range是内核提供的API, 可以将一段连续的物理地址空间映射到进程的虚拟地址空间, 这里用它将设备的BAR空间的MMIO先映射到QEMU进程的虚拟地址空间再注册给虚拟机.

```cpp
static int vfio_pci_mmap(void *device_data, struct vm_area_struct *vma)
{
    req_len = vma->vm_end - vma->vm_start;     // MMIO size
    vma->vm_pgoff = (pci_resource_start(pdev, index) >> PAGE_SHIFT) + pgoff;  // MMIO page address 
    return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
            req_len, vma->vm_page_prot);

}
```

再来看下QEMU是如何注册这段虚拟地址(IOVA)到虚拟机的.

vfio_region_mmap调用memory_region_init_ram_device_ptr把前面mmap过来的 这段IOVA作为RAM类型设备注册给虚拟机.

```cpp
int vfio_region_mmap(VFIORegion *region) 
{
    name = g_strdup_printf("%s mmaps[%d]",
                               memory_region_name(region->mem), i);
    memory_region_init_ram_device_ptr(&region->mmaps[i]. mem,
                                        memory_region_owner(region->mem),
                                        name, region->mmaps[i]. size,
                                        region->mmaps[i]. mmap);
    memory_region_add_subregion(region->mem, region->mmaps[i]. offset,
                                &region->mmaps[i]. mem);                                    
}
```

memory_region_init_ram_device_ptr中会标志 mr->ram = true, 那么QEMU就会通过kvm_set_phys_mem注册这段内存给虚拟机(是RAM类型才会建立EPT映射关系), 这样KVM就会为这段地址空间建立EPT页表, 虚拟机访问设备的MMIO空间时通过EPT页表翻直接访问不需要VM-Exit. 例如, 网卡的收发包场景, 虚拟机可以直接操作真实网卡的相关寄存器(MMIO映射)而没有陷入先出开销, 大幅度提升了虚拟化场景下的I/O性能.

```cpp
static void kvm_set_phys_mem(KVMMemoryListener *kml,
                             MemoryRegionSection *section, bool add)
{
    if (! memory_region_is_ram(mr)) {  // mr->ram = true 会注册到KVM
        if (writeable || !kvm_readonly_mem_allowed) {
            return;
        } else if (! mr->romd_mode) {
            /* If the memory device is not in romd_mode, then we actually want
             * to remove the kvm memory slot so all accesses will trap. */
            add = false;
        }
    }

    ram = memory_region_get_ram_ptr(mr) +   section->offset_within_region +  
          (start_addr - section->offset_within_address_space);
    kvm_set_user_memory_region  // 作为RAM设备注册到KVM中
}
```





# VFIO中如实现对直通设备的PCI 配置空间, PCI BAR空间, I/O Port, MMIO的访问支持?

值得注意的是直通设备的配置空间并不是直接呈现给虚拟机的, VFIO中会对设备的PCI 配置空间进行模拟. 为什么VFIO不直接把直通PCI 配置空间呈现给虚拟机呢? 主要原因是一部分PCI Capability不能直接对guest呈现, VFIO需要截获部分guest驱动对某些PCI配置空间的操作, 另外像MSI/MSIx等特性需要QEMU/KVM的特殊处理, 所以也不能直接呈现给虚拟机.

VFIO内核模块和QEMU会相互配合来完成设备的PCI配置空间的模拟, 在VFIO中vfio_config_init函数中会为PCI设备初始化模拟的PCI配置空间. 对于每个设备而言, VFIO内核模块为其分配了一个pci_config_map结构, 每个PCI Capability都有一个与之对应的perm_bits, 我们可以重写其hook函数来截获对这个Capability的访问(读/写).



https://kernelgo.org/vfio-insight.html

https://luohao-brian.gitbooks.io/interrupt-virtualization/content/vfio-ji-zhu-shi-xian-zhong-de-guan-jian-dian-fen-679028-1.html