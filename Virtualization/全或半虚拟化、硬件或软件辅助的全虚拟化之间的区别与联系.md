
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 全虚拟化](#1-全虚拟化)
  - [1.1 软件辅助的全虚拟化](#11-软件辅助的全虚拟化)
  - [1.2 硬件辅助的全虚拟化](#12-硬件辅助的全虚拟化)
- [2 半虚拟化](#2-半虚拟化)

<!-- /code_chunk_output -->

https://blog.csdn.net/dongfei2033/article/details/82756634

# 1 全虚拟化

**不需要**对**GuestOS 操作系统软件的源代码做任何的修改**, 就可以运行在这样的 VMM 中

在**全虚拟化的虚拟平台**中, **GuestOS**并**不知道**自己是一台**虚拟机**, 它会认为自己就是运行在计算机物理硬件设备上的 HostOS. 因为**全虚拟化的 VMM！！！**会将一个**OS**所能够操作的**CPU**、**内存**、**外设**等物理设备**逻辑抽象**成为**虚拟 CPU**、**虚拟内存**、**虚拟外设**等虚拟设备后, 再交由**GuestOS 来操作使用**. 这样的 GuestOS 会将底层硬件平台视为自己所有的, 但是实际上, 这些都是 VMM 为 GuestOS 制造了这种假象.

全虚拟化又分为: 软件辅助的全虚拟化 & 硬件辅助的全虚拟化.

## 1.1 软件辅助的全虚拟化

架构图

![config](./images/12.png)

在 Intel 等 CPU 厂商还没有发布**x86 CPU 虚拟化技术之前**, **完全虚拟化**都是通过**软件辅助**的方式来实现的.

而**软件辅助的全虚拟化**主要是应用了**两种机制**:

1. **特权解除(优先级压缩**): 从上述的软件辅助全虚拟化架构图中可以看出, **VMM**、**GuestOS**、**GuestApplications**都是运行在**Ring 1-3 用户态(！！！VMM 也处于用户态！！！**)中的应用程序代码. 当在**GuestOS**中执行**系统内核的特权指令**时, 一般都会**触发异常！！！**. 这是因为**用户态代码**不能直接运行在**核心态**中, 而且**系统内核的特权指令**大多都**只能运行在 Ring 0 核心态**中. 在**触发了异常**之后, 这些**异常就会被 VMM 捕获**, 再由**VMM！！！**将这些**特权指令！！！**进行**虚拟化**成为**只针对虚拟 CPU 起作用(！！！**)的**虚拟特权指令！！！**. 其本质就是使用**若干能运行在用户态中的非特权指令(！！！**)来**模拟**出**只针对 GuestOS 有效的虚拟特权指令**, 从而将特权指令的特权解除掉.

缺点: 但是特权解除的问题在于当初设计**标准 x86 架构 CPU**时, 并没有考虑到要支持虚拟化技术, 所以会存在**一部分特权指令**运行在**Ring 1 用户态**上, 而这些运行在 Ring 1 上的特权指令并**不会触发异常然后再被 VMM 捕获(！！！有些特权指令不会被 VMM 捕获！！！**). 从而导致在**GuestOS**中执行的**特权指令直接对 HostOS**造成了影响(GuestOS 和 HostOS 没能做到**完全隔离**).

针对这个问题, 再引入了**陷入模拟的机制**.

2. **陷入模拟(二进制翻译**): 就是**VMM**会对**GuestOS**中的**二进制代码(运行在 CPU 中的代码！！！**)进行**扫描！！！**, 一旦发现**GuestOS**执行的**二进制代码**中包含有**运行在用户态上的特权指令二进制代码**时, 就会将这些二进制代码翻译成**虚拟特权指令二进制代码(！！！**)或者是**翻译成运行在核心态中的特权指令！！！二进制代码从而强制的触发异常！！！**. 这样就能够很好的解决了运行在**Ring 1 用户态上的特权指令没有被 VMM 捕获！！！**的问题, 更好的实现了 GuestOS 和 HostOS 的隔离.

简而言之, **软件辅助虚拟化**能够成功的将所有在**GuestOS**中执行的**系统内核特权指令**进行**捕获、翻译**, 使之成为只能对 GuestOS 生效的虚拟特权指令. 但是退一步来说, 之所以需要这么做的前提是因为**CPU**并不能准确的去判断**一个特权指令！！！**到底是由**GuestOS 发出！！！**的还是由**HostOS 发出！！！**的, 这样也就**无法针对一个正确的 OS**去**将这一个特权指令执行**.

直到后来 CPU 厂商们发布了能够**判断特权指令归属！！！**的**标准 x86 CPU**之后, 迎来了**硬件辅助全虚拟化**.

## 1.2 硬件辅助的全虚拟化

![config](./images/13.png)

硬件辅助全虚拟化主要使用了**支持虚拟化功能**的**CPU**进行支撑, **CPU**可以明确的**分辨出**来自**GuestOS 的特权指令**, 并**针对 GuestOS 进行特权操作(！！！**), 而**不会影响到 HostOS**.

从更深入的层次来说, **虚拟化 CPU**形成了**新的 CPU 执行状态** —— **Non\-Root Mode& Root Mode**. 从上图中可以看见, **GuestOS(！！！**)运行在**Non\-Root Mode** 的**Ring 0 核心态**中, 这表明**GuestOS**能够**直接执行特却指令**而不再需要 **特权解除** 和 **陷入模拟** 机制. 并且在**硬件层**上面紧接的就是**虚拟化层的 VMM**, 而**不需要 HostOS！！！**. 这是因为在**硬件辅助全虚拟化的 VMM**会以一种更具协作性的方式来实现虚拟化 —— 将**虚拟化模块**加载到**HostOS 的内核**中, 例如: KVM, KVM 通过在 HostOS 内核中加载 KVM Kernel Module 来将**HostOS 转换成为一个 VMM！！！**. 所以此时**VMM 可以看作是 HostOS, 反之亦然**.

这种虚拟化方式创建的**GuestOS 知道**自己是正在**虚拟化模式**中运行的 GuestOS, KVM 就是这样的一种虚拟化实现解决方案.

# 2 半虚拟化

需要对**GuestOS 的内核代码**做一定的修改, 才能够将 GuestOS 运行在半虚拟化的 VMM 中.

**半虚拟化**通过在**GuestOS 的源代码级别上修改特权指令**来回避上述的虚拟化漏洞.

**修改内核**后的**GuestOS**也**知道**自己就是一台**虚拟机**. 所以能够很好的对**核心态指令**和**敏感指令**进行识别和处理, 但缺点在于**GuestOS 的镜像文件并不通用**.

具体的**x86 架构 CPU**解析, 请参考[虚拟化的发展历程和实现方式](https://blog.csdn.net/jmilk/article/details/51031118)
