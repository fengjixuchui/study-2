
探测 intel_iommu 时候

```cpp
// drivers/iommu/intel/dmar.c
struct acpi_table_header * __initdata dmar_tbl;

IOMMU_INIT_POST(detect_intel_iommu);

int __init detect_intel_iommu()
{
    ...
    // 探测 dmar table, 检查平台是否支持 DMAR 设备
    // 里面会初始化 dmar_tbl
    ret = dmar_table_detect();
    if (!ret)
        // 会调用到
        ret = dmar_walk_dmar_table((struct acpi_table_dmar *)dmar_tbl, &validate_drhd_cb);
    if (!ret && !no_iommu && !iommu_detected &&
        (!dmar_disabled || dmar_platform_optin())) {
            // 会调用到这里
            iommu_detected = 1;
            pci_request_acs();
    }
#ifdef CONFIG_X86
    if (!ret) {
        // iommu 的初始化函数
        x86_init.iommu.iommu_init = intel_iommu_init;
        x86_platform.iommu_shutdown = intel_iommu_shutdown;
    }
#endif
    if (dmar_tbl) {
        acpi_put_table(dmar_tbl);
        // 在这里会置 NULL, ??
        dmar_tbl = NULL;
    }
    return ret ? ret : 1;
}
```

先会调用 `dmar_table_detect()`, 后面再会调用 `intel_iommu_init()`

```cpp
static int __init dmar_table_detect(void)
{
    acpi_status status = AE_OK;

    if (dmar_tbl)
        // 两次都不会打印
        pr_info("---- %s, dmar_tbl exist: 0x%llx\n", __func__, dmar_tbl);

    status = acpi_get_table(ACPI_SIG_DMAR, 0, &dmar_tbl);

    if (ACPI_SUCCESS(status) && !dmar_tbl) {
        pr_warn("Unable to map DMAR\n");
        status = AE_NOT_FOUND;
    }
    // 两次都是打印: DMAR: ---- dmar_table_detect, 1, dmar_tbl (____ptrval____)
    pr_info("---- %s, %d, dmar_tbl %p\n", __func__, ACPI_SUCCESS(status), dmar_tbl);

    return ACPI_SUCCESS(status) ? 0 : -ENOENT;
}
```

所以真正初始化是下面部分: 在 PCI 子系统初始化以后, 会初始化 iommu

```cpp
// arch/x86/kernel/pci-dma.c
static int __init pci_iommu_init(void)
{
    // 调用 intel_iommu_init(), 初始化 intel iommu
    x86_init.iommu.iommu_init();
}
/* Must execute after PCI subsystem */
// 在 PCI 子系统初始化以后
rootfs_initcall(pci_iommu_init);

#define rootfs_initcall(fn)		__define_initcall(fn, rootfs)
```

在 iommu 初始化或者 irq remapping 初始化时候, 会对 dmar table 进行初始化

```cpp
// drivers/iommu/intel/iommu.c
intel_iommu_init() 或者
// drivers/iommu/intel/irq_remapping.c
intel_prepare_irq_remapping()

->

// drivers/iommu/intel/dmar.c
// dmar table 初始化
dmar_table_init() ->
// 解析 DMA reporting table
parse_dmar_table()
```

```cpp
#define tboot_get_dmar_table(dmar_tbl)	(dmar_tbl)

// drivers/iommu/intel/dmar.c
static int __init
parse_dmar_table(void)
{
    struct acpi_table_dmar *dmar;
    // 探测 dmar table, 检查平台是否支持 DMAR 设备
    // 里面会初始化 dmar_tbl
    // 在这里还是会再次调用
	dmar_table_detect();

	dmar_tbl = tboot_get_dmar_table(dmar_tbl);
    // 直接转换, 因为得到的这个表 就是 dmar 表
    dmar = (struct acpi_table_dmar *)dmar_tbl;

    pr_info("Host address width %d\n", dmar->width + 1);
    // 遍历整个 dmar 表
    ret = dmar_walk_dmar_table(dmar, &cb);
}
```

其中:

* `struct acpi_table_header` 是通用 ACPI 表的表头的数据结构

* `struct acpi_table_dmar` 就是 DMAR 表的数据结构, 包括了通用表头

```cpp
// include/acpi/actbl.h
// 通用的 ACPI 表的头部
struct acpi_table_header {
	char signature[ACPI_NAMESEG_SIZE];	// APCI 表签名
	u32 length;		// 表的长度(字节), 包括该通用表头和具体表
	u8 revision;		// ACPI 规范次要版本号
	u8 checksum;		// 整个表的总和必须为 0, 包括该通用表头和具体表
	char oem_id[ACPI_OEM_ID_SIZE];	// ASCII 原始设备制造商标识
	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE];	// ASCII OEM 表标识
	u32 oem_revision;	// OEM 修订号
	char asl_compiler_id[ACPI_NAMESEG_SIZE];	// 供应商 ID
	u32 asl_compiler_revision;	// 供应商 修订号
};

// DMAR 表, 注意: 没有 DRHD 链表
struct acpi_table_dmar {
	struct acpi_table_header header;	// 通用的 ACPI 表头
	u8 width;		// 最大 DMA 物理可寻址能力(也就是 host 地址宽度), 1个字节
	u8 flags;       // 标识, 1个字节
	u8 reserved[10];    // 保留位, 10个字节
};
```

最后一个字段, 各种结构的链表, 手册只是说明了在偏移第 48 字节处, 没有长度信息

