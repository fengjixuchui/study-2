
**主机与 PCIe 设备**之间, 或者 **PCIe 设备与设备之间**, 数据传输都是**以 Packet 形式**进行的. 事务层根据上层(软件层或者应用层)请求(Request)的类型、目的地址和其他相关属性, 把这些请求打包, 产生 TLP(Transaction Layer Packet, 事务层数据包). 然后这些 TLP 往下, 经历数据链路层、物理层, 最终到达目标设备.

根据软件层的不同请求, **事务层**产生**四种不同的 TLP 请求**：

* Memory;

* IO;

* Configuration;

* Message.

前三种分别用于**访问内存空间**、**IO 空间**、**配置空间**, 这三种请求在 PCI 或者 PCI-X 时代就有了, 最后的 Message 请求是 PCIe 新加的. 在 PCI 或者 PCI-X 时代, 像**中断**、**错误**以及**电源管理相关信息**, 都是通过**边带信号**(`Sideband Signal`)进行传输的, 但 PCIe 干掉了这些边带信号线, 所有的通信都是走**带内信号**, 即通过 Packet 传输, 因此, 过去一些由边带信号线传输的数据, 比如中断信息、错误信息等, 现在就交由 Message 来传输了.

我们知道, **一个设备的物理空间**, 可以通过**内存映射**(`Memory Map`)的方式映射到主机的主存, 有些空间还可以映射到主机的 IO 空间(如果主机存在 IO 空间的话). 但新的 PCIe 设备(区别于 Legacy PCIe 设备)只支持内存映射, 之所以还存在访问 IO 空间的 TLP, 完全是为了照顾那些老设备. 以后 IO 映射的方式会逐渐取消, 为减轻学习压力, 我们以后看到 IO 相关的东西, 大可忽略掉.

**所有配置空间**(`Configuration`)的**访问**, 都是**主机发起**的, 确切地说是 **RC 发起**的, 往往**只在上电枚举和配置阶段**会发起**配置空间的访问**, 这样的 TLP 很重要, 但不是常态; Message 也是一样, 只有在有中断或者有错误等情况下, 才会有 MessageTLP, 这是非主流的. PCIe 线上主流传输的是 Memory 访问相关的 TLP, 主机与设备或者设备与设备之间, 数据都是在彼此的 Memory 之间(抛掉 IO) 交互, 因此, 这种 TLP 是我们最常见的.

这四种请求, 如果**需要对方响应**的, 我们称之为 **Non-Posted TLP**; 如果不指望对方给响应的, 我们称之为 Posted TLP. Post, 有 “邮政” 的意思, 我们只管把信投到邮箱, 能不能到达对方, 就取决于邮递员了. Posted TLP, 就是不指望对方回复(信能不能收到都是个问题); Non-Posted TLP, 就是要求对方务必回复.

哪些 TLP 是 Posted, 哪些又是 Non-Posted 的呢？像 Configuration 和 IO 访问, 无论读写, 都是 Non-Posted 的, 这样的请求必须得到设备的响应; Message TLP 是 Posted 的; Memory Read 必须是 Non-Posted 的, 我读你数据, 你不返回数据(返回数据也是响应), 那肯定不行, 所以 Memory Read 必须得到响应; 而 Memory Write 是 Posted 的, 我数据传给你, 无须回复, 这样主机或者设备可以不等对方回复, 趁早把下一笔数据写下去, 这样一定程度上提高了写的性能. 有人会担心如果没有得到对方的响应, 发送者就没有办法知道数据究竟有没有成功写入, 就有丢数据的风险. 虽然这个风险存在(概率很小), 但数据链路层提供了 ACK/NAK 机制, 一定程度上能保证 TLP 正确交互, 因此能很大程度上减小了数据写失败的可能. TLP 的请求类型如表 5-2 所示.

TLP 请求类型:

![2021-11-09-21-45-13.png](./images/2021-11-09-21-45-13.png)

> 所以, 只要记住只有 Memory Write 和 Message 两种 TLP 是 Posted 的就可以了, 其他都是 Non-Posted 的.

Memory Read Lock 是历史的遗留物, Native PCIe 设备已经抛弃了它, 它存在的意义完全是为了兼容 Legacy PCIe 设备. 和 IO 一样, 我们也可以忽略. 能不看的就不看, PCIe 内容本来就多, 不要被这些过时没用的东西挡住我们学习的道路.

在 Configuration 一栏, 我们看到 Type 0 和 Type 1. 在之前的拓扑结构中, 我们看到除了 Endpoint 之外, 还有 Switch, 他们都是 PCIe 设备, 但配置种类不同, 因此用 Type 0 和 Type 1 区分, 如表 5-3 所示.

Native PCIe TLP 类型:

![2021-11-09-21-45-29.png](./images/2021-11-09-21-45-29.png)

这样, Request TLP 是不是清爽点？

对 Non-Posted 的 Request, 是一定需要对方响应的, 对方需要通过返回一个 Completion TLP 来作为响应. 对 Read Request 来说, 响应者通过 Completion TLP 返回请求者所需的数据, 这种 Completion TLP 包含有效数据; 对 Write Request(现在只有 Configuration Write 了)来说, 响应者通过 CompletionTLP 告诉请求者执行状态, 这样的 Completion TLP 不含有效数据.

因此, PCIe 里面所有的 TLP = Request TLP + CompletionTLP.

Native PCIe 请求和响应 TLP 类型:

![2021-11-09-21-45-49.png](./images/2021-11-09-21-45-49.png)

看个 Memory Read 的例子, 如图 5-17 所示.

![2021-11-09-21-46-07.png](./images/2021-11-09-21-46-07.png)

例子中, PCIe 设备 C 想读主机内存的数据, 因此, 它在事务层上生成一个 Memory Read TLP, 该 MRd 一路向上, 到达 RC. RC 收到该 Request, 就到内存中取 PCIe 设备 C 所需的数据, RC 通过 Completion with Data TLP(CplD)返回数据, 原路返回, 直到 PCIe 设备 C.

**一个 TLP 最多只能携带 4KB 有效数据**, 因此, 上例中, 如果 PCIe 设备 C 需要读 16KB 的数据, 则 RC 必须返回 4 个 CplD 给 PCIe 设备 C. 注意, PCIe 设备 C 只需发 1 个 MRd 就可以了.

再看个 Memory Write 的例子, 如图 5-18 所示.

![2021-11-09-21-46-14.png](./images/2021-11-09-21-46-14.png)

该例中, 主机想往 PCIe 设备 B 中写入数据, 因此 RC 在其事务层生成了一个 Memory Write TLP(要写的数据在该 TLP 中), 通过 Switch 直到目的地. 前面说过 Memory Write TLP 是 Posted 的, 因此, PCIe 设备 B 收到数据后, 不需要返回 CompletionTLP(如果这时返回 Completion TLP, 反而是画蛇添足).

同样的, 由于一个 TLP 只能携带 4KB 数据, 因此主机想往 PCIe 设备 B 上写入 16KB 数据, RC 必须发送 4 个 MWr TLP.