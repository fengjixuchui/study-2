
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 PCI桥](#1-pci桥)
- [2 PCI Agent设备的配置空间](#2-pci-agent设备的配置空间)

<!-- /code_chunk_output -->

PCI设备都有独立的配置空间HOST主桥通过配置读写总线事务访问这段空间. PCI总线规定了三种类型的PCI配置空间分别是PCI Agent设备使用的配置空间PCI桥使用的配置空间和Cardbus桥片使用的配置空间. 

本节重点介绍PCI Agent和PCI桥使用的配置空间而并不介绍Cardbus桥片使用的配置空间. 值得注意的是在PCI设备配置空间中出现的地址都是PCI总线地址属于PCI总线域地址空间. 

# 1 PCI桥

PCI桥的引入使PCI总线极具扩展性也极大地增加了PCI总线的复杂度. PCI总线的电气特性决定了在一条PCI总线上挂接的负载有限当PCI总线需要连接多个PCI设备时需要使用PCI桥进行总线扩展扩展出的PCI总线可以连接其他PCI设备包括PCI桥. 在一颗PCI总线树上最多可以挂接256个PCI设备包括PCI桥. PCI桥在PCI总线树中的位置如图2‑8所示. 

![config](./images/2.jpeg)

PCI桥作为一个特殊的PCI设备具有独立的配置空间. 但是PCI桥配置空间的定义与PCI Agent设备有所不同. PCI桥的配置空间可以管理其下PCI总线子树的PCI设备并可以优化这些PCI设备通过PCI桥的数据访问. PCI桥的配置空间在系统软件遍历PCI总线树时配置系统软件不需要专门的驱动程序设置PCI桥的使用方法这也是PCI桥被称为透明桥的主要原因. 

在某些处理器系统中还有一类PCI桥叫做非透明桥. 非透明桥不是PCI总线定义的标准桥片但是在使用PCI总线挂接另外一个处理器系统时非常有用非透明桥片的主要作用是连接两个不同的PCI总线域进而连接两个处理器系统本章将在第2.5节中详细介绍PCI非透明桥. 

使用PCI桥可以扩展出新的PCI总线在这条PCI总线上还可以继续挂接多个PCI设备. PCI桥跨接在两个PCI总线之间其中距离HOST主桥较近的PCI总线被称为该桥片上游总线(Primary Bus)距离HOST主桥较远的PCI总线被称为该桥片的下游总线(Secondary Bus). 如图2‑8所示PCI桥1的上游总线为PCI总线x0而PCI桥1的下游总线为PCI总线x1. 这两条总线间的数据通信需要通过PCI桥1. 

通过PCI桥连接的PCI总线属于同一个PCI总线域在图2‑8中PCI桥1、2和3连接的PCI总线都属于PCI总线x域. 在这些PCI总线域上的设备可以通过PCI桥直接进行数据交换而不需要进行地址转换; 而分属不同PCI总线域的设备间的通信需要进行地址转换如与PCI非透明桥两端连接的设备之间的通信. 

如图2‑8所示每一个PCI总线的下方都可以挂接一个到多个PCI桥每一个PCI桥都可以推出一条新的PCI总线. 在同一条PCI总线上的设备之间的数据交换不会影响其他PCI总线. 如PCI设备21与PCI设备22之间的数据通信仅占用PCI总线x2的带宽而不会影响PCI总线x0、x1与x3这也是引入PCI桥的另一个重要原因. 

由图2‑8我们还可以发现PCI总线可以通过PCI桥组成一个胖树结构其中每一个桥片都是父节点而PCI Agent设备只能是子节点. 当PCI桥出现故障时其下的设备不能将数据传递给上游总线但是并不影响PCI桥下游设备间的通信. 当PCI桥1出现故障时PCI设备11、PCI设备21和PCI设备22将不能与PCI设备01和存储器进行通信但是PCI设备21和PCI设备22之间的通信可以正常进行. 

使用PCI桥可以扩展一条新的PCI总线但是不能扩展新的PCI总线域. 如果当前系统使用32位的PCI总线地址那么这个系统的PCI总线域的地址空间为4GB大小在这个总线域上的所有设备将共享这个4GB大小的空间. 如在PCI总线x域上的PCI桥1、PCI设备01、PCI设备11、PCI桥2、PCI设备21和PCI设备22等都将共享一个4GB大小的空间. 再次强调这个4GB空间是PCI总线x域的”PCI总线地址空间"和存储器域地址空间和PCI总线y域没有直接联系. 

处理器系统可以通过HOST主桥扩展出新的PCI总线域如MPC8548处理器的HOST主桥x和y可以扩展出两个PCI总线域x和y. 这两个PCI总线域x和y之间的PCI空间在正常情况下不能直接进行数据交换但是PowerPC处理器可以通过设置PIWARn寄存器的TGI字段使得不同PCI总线域的设备直接通信详见第2.2.3节. 

许多处理器系统使用的PCI设备较少因而并不需要使用PCI桥. 因此在这些处理器系统中PCI设备都是直接挂接在HOST主桥上而不需要使用PCI桥扩展新的PCI总线. 即便如此读者也需要深入理解PCI桥的知识. 

PCI桥对于理解PCI和PCIe总线都非常重要. 在PCIe总线中虽然在物理结构上并不含有PCI桥但是与PCI桥相关的知识在PCIe总线中无处不在比如在PCIe总线的Switch中每一个端口都与一个虚拟PCI桥对应Switch使用这个虚拟PCI桥管理其下PCI总线子树的地址空间. 

# 2 PCI Agent设备的配置空间

在一个具体的处理器应用中**PCI设备**通常将**PCI配置信息存放在E2PROM**中. **PCI设备**进行**上电初始化**时将**E2PROM**中的**信息读到PCI设备的配置空间**中作为**初始值**. 这个过程由**硬件逻辑完成**绝大多数PCI设备使用这种方式初始化其配置空间. 

读者可能会对这种机制产生一个疑问如果**系统软件**在**PCI设备**将**E2PROM**中的信息**读到配置空间之前**就开始**操作配置空间**会不会带来问题？因为此时PCI设备的初始值并不”正确"仅仅是PCI设备使用的复位值. 

读者的这种担心是多余的因为PCI设备在配置寄存器**没有初始化完毕之前**即**E2PROM中的内容没有导入PCI设备的配置空间之前**可以使用**PCI总线规定**的”**Retry**"周期使**HOST主桥**在**合适的时机**重新发起配置读写请求. 

在x86处理器中**系统软件**使用**CONFIG\_ADDR！！！**和**CONFIG\_DATA寄存器！！！**读取**PCI设备配置空间**的这些**初始化信息**然后根据处理器系统的实际情况**使用DFS算法****初始化**处理器系统中**所有PCI设备的配置空间！！！**. 

在**PCI Agent设备**的配置空间中包含了许多寄存器这些寄存器决定了该设备在PCI总线中的使用方法本节不会全部介绍这些寄存器因为系统软件只对部分配置寄存器感兴趣. PCI Agent设备使用的配置空间如图2‑9所示. 

![config](./images/3.png)

在PCI Agent设备配置空间中包含的寄存器如下所示. 

(1) Device ID和Vendor ID寄存器

这两个寄存器的值由**PCISIG分配****只读**. 其中**Vendor ID**代表PCI设备的**生产厂商**而**Device ID**代表**这个厂商**所生产的**具体设备**. 如Intel公司的基于**82571EB芯片的系列网卡**其**Vendor ID**为0x8086[1]而**Device ID**为0x105E[2]. 

(2) Revision ID和Class Code寄存器

这两个寄存器**只读**. 其中**Revision ID**寄存器记载**PCI设备的版本号**. 该寄存器可以被认为是**Device ID寄存器的扩展**. 

(3) Header Type寄存器

该寄存器**只读**由**8位**组成. 

第7位为1表示当前PCI设备是**多功能设备**为0表示为**单功能设备**. 

第6\~0位表示**当前配置空间的类型**为**0**表示该设备使用PCI Agent设备的配置空间**普通PCI设备**都使用这种配置头; 为**1**表示使用**PCI桥**的配置空间PCI桥使用这种配置头; 为**2**表示使用**Cardbus桥片**的配置空间Card Bus桥片使用这种配置头本篇对这类配置头不感兴趣. 

**系统软件**需要使用该寄存器**区分不同类型的PCI配置空间**该寄存器的初始化必须与PCI设备的实际情况对应而且必须为一个合法值. 

(4) Cache Line Size寄存器

该寄存器记录**HOST处理器**使用的**Cache行长度**. 在PCI总线中和Cache相关的总线事务如存储器写并无效和Cache多行读等总线事务需要使用这个寄存器. 值得注意的是该寄存器由系统软件设置但是在PCI设备的运行过程中只有其硬件逻辑才会使用该寄存器比如PCI设备的硬件逻辑需要得知处理器系统Cache行的大小才能进行存储器写并无效总线事务单行读和多行读总线事务. 

如果PCI设备不支持与Cache相关的总线事务系统软件可以不设置该寄存器此时该寄存器为初始值0x00. 对于PCIe设备该寄存器的值无意义因为PCIe设备在进行数据传送时在其报文中含有一次数据传送的大小PCIe总线控制器可以使用这个”大小"判断数据区域与Cache行的对应关系. 

(5) Subsystem ID和Subsystem Vendor ID寄存器

这两个寄存器和Device ID和Vendor ID类似也是记录PCI设备的生产厂商和设备名称. 但是这两个寄存器和Device ID与Vendor ID寄存器略有不同. 下文以一个实例说明Subsystem ID和Subsystem Vendor ID的用途. 

Xilinx公司在FGPA中集成了一个PCIe总线接口的IP核即LogiCORE. 用户可以使用LogiCORE设计各种各样基于PCIe总线的设备但是这些设备的Device ID都是0x10EE而Vendor ID为0x0007[3]. 

(6) Expansion ROM base address寄存器

有些PCI设备在处理器还没有运行操作系统之前就需要完成基本的初始化设置比如显卡、键盘和硬盘等设备. 为了实现这个”预先执行"功能PCI设备需要提供一段ROM程序而处理器在初始化过程中将运行这段ROM程序初始化这些PCI设备. Expansion ROM base address记载这段ROM程序的基地址. 

(7) Capabilities Pointer寄存器

在 PCI 设备中该寄存器是**可选的**. 但是在 `PCI-X` 和PCIe设备中必须支持这个寄存器 Capabilities Pointer 寄存器存放 Capabilities寄存器组的基地址PCI设备使用 Capabilities寄存器组存放一些与PCI设备相关的扩展配置信息. 该组寄存器的详细说明见第4.3节. 

(8) Interrupt Line寄存器

这个寄存器是**系统软件！！！(BIOS？？**)对PCI设备进行**配置时写入**的该寄存器记录**当前PCI设备**使用的**中断向量号****设备驱动程序**可以**通过这个寄存器**判断**当前PCI设备**使用处理器系统中的**哪个中断向量号**并将驱动程序的**中断服务例程注册到操作系统**中[4]. 

该寄存器由系统软件初始化其保存的值与8259A中断控制器相关该寄存器的值也是由PCI设备与8259A中断控制器的连接关系决定的. 如果在一个处理器系统中**没有使用8259A中断控制器！！！**管理PCI设备的中断则**该寄存器中的数据并没有意义**. 

在多数PowerPC处理器系统中并不使用8259A中断控制器管理PCI设备的中断请求因此该寄存器没有意义. 即使在x86处理器系统中如果使用I/O APIC中断控制器该寄存器保存的内容仍然无效. 目前在绝大多数处理器系统中并没有使用该寄存器存放PCI设备使用的中断向量号. 

(9) Interrupt Pin寄存器

这个寄存器保存PCI设备使用的中断引脚PCI总线提供了四个中断引脚INTA\#、INTB\#、INTC\#和INTD\#. Interrupt Pin寄存器为1时表示使用INTA#引脚向中断控制器提交中断请求为2表示使用INTB#为3表示使用INTC#为4表示使用INTD#. 

如果PCI设备只有一个子设备时该设备只能使用INTA\#; 如果有多个子设备时可以使用INTB\~D\#信号. 如果PCI设备不使用这些中断引脚向处理器提交中断请求时该寄存器的值必须为0. 值得注意的是虽然在PCIe设备中并不含有INTA\~D#信号但是依然可以使用该寄存器因为PCIe设备可以使用INTx中断消息模拟PCI设备的INTA\~D#信号详见第6.3.4节. 

(10) **Base Address Register** 0\~5寄存器

该组寄存器简称为**BAR寄存器**BAR寄存器保存**PCI设备使用的地址空间的基地址！！！**该基地址保存的是**该设备在PCI总线域中的地址**. 其中**每一个设备**最多可以有**6个基址空间！！！**但多数设备不会使用这么多组地址空间. 

在PCI设备复位之后该寄存器将存放PCI设备需要使用的基址空间大小这段空间是I/O空间还是存储器空间[5]如果是存储器空间该空间是否可预取有关PCI总线预读机制的详细说明见第3.4.5节. 

**系统软件**对**PCI总线进行配置**时首先获**得BAR寄存器中的初始化信息**之后根据处理器系统的配置将**合理的基地址**写入相应的**BAR寄存器**中. 系统软件还可以使用该寄存器获得PCI设备使用的BAR空间的长度其方法是向BAR寄存器写入0xFFFF-FFFF之后再读取该寄存器. 

处理器访问PCI设备的BAR空间时需要使用BAR寄存器提供的基地址. 值得注意的是处理器使用存储器域的地址而BAR寄存器存放PCI总线域的地址. 因此处理器系统并不能直接使用”BAR寄存器+偏移"的方式访问PCI设备的寄存器空间而需要将PCI总线域的地址转换为存储器域的地址. 

如果x86处理器系统使能了IOMMU后这两个地址也并不一定相等因此处理器系统直接使用这个PCI总线域的物理地址并不能确保访问PCI设备的BAR空间的正确性. 除此之外在Linux系统中ioremap函数的输入参数为存储器域的物理地址而不能使用PCI总线域的物理地址. 

而在pci\_devàresource[bar].start参数中保存的地址已经经过PCI总线域到存储器域的地址转换因此在编写Linux系统的设备驱动程序时需要使用pci\_devàresource[bar].start参数中的物理地址然后再经过ioremap函数将物理地址转换为”存储器域"的虚拟地址. 

(11) Command寄存器

该寄存器为PCI设备的命令寄存器该寄存器在初始化时其值为0此时这个PCI设备除了能够接收配置请求总线事务之外不能接收任何存储器或者I/O请求. 系统软件需要合理设置该寄存器之后才能访问该设备的存储器或者I/O空间. 在Linux系统中设备驱动程序调用pci_enable_device函数使能该寄存器的I/O和Memory Space位之后才能访问该设备的存储器或者I/O地址空间. 
(12) Status寄存器

该寄存器的绝大多数位都是只读位保存PCI设备的状态. 

(13) Latency Timer寄存器

在PCI总线中多个设备共享同一条总线带宽. 该寄存器用来控制PCI设备占用PCI总线的时间当PCI设备获得总线使用权并使能Frame#信号后Latency Timer寄存器将递减当该寄存器归零后该设备将使用超时机制停止[6]对当前总线的使用. 

如果当前总线事务为Memeory Write and Invalidate时需要保证对一个完整Cache行的操作结束后才能停止当前总线事务. 对于多数PCI设备而言该寄存器的值为32或者64以保证一次突发传送的基本单位为一个Cache行. 

PCIe设备不需要使用该寄存器该寄存器的值必须为0. 因为PCIe总线的仲裁方法与PCI总线不同使用的连接方法也与PCI总线不同. 