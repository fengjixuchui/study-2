
在**多进程环境**下, **处理器**使用 **MMU** 机制， 使得**每一个进程**都有**独立的虚拟地址空间**，从而各个进程运行在独立的地址空间中， 互不干扰。MMU具有两大功能，一是进行**地址转换**，将分属**不同进程的虚拟地址**转换为**物理地址**；二是**对物理地址的访问**进行**权限检查**，判断虚实地址转换的合理性。

在多数操作系统中，**每一个进程**都具有**独立的页表**存放**虚拟地址**到**物理地址**的**映射关系和属性**。但是如果进程每次访问物理内存时，都需要访问页表时，将严重影响进程的执行效率。为此处理器设置了TLB(Translation Lookaside Buffer) 作为页表的Cache。如果进程的虚拟地址在TLB中命中时， 则从TLB中直接获得物理地址， 而不需要使用页表进行虚实地址转换，从而极大提高了访问存储器的效率。

从地址转换的角度来看， IOMMU与MMU较为类似。只是IOMMU完成的是外部设备地址到存储器地址的转换。我们可以将一个PCI设备模拟成为处理器系统的一个特殊进程，当这个进程访问存储器时使用特殊的MMU，即IOMMU，进行虚实地址转换，然后再访问存储器。在这个I0MMU中，同样存在10页表存放虚实地址转换关系和访问权限，而且处理器为了加速这种虚实地址的转换，还设置了IOTLB作为I0页表的Cache。单纯从这个角度来看，许多HOST主桥和RC也具备同样的功能，如PowerPC处理器的Inbound 窗口和Out-bound窗口，也可以完成这种特殊的地址转换。但是这些窗口仅能完成PCI总线域到一个存储器域的地址转换，无法实现PCI总线域到多个存储器域的转换。

目前设置IOMMU的主要作用是支持虚拟化技术，当然使用IOMMU也可以实现其他功能，如使“仅支持32位地址的PCI设备”访问4GB以上的存储器空间。IA处理器和AMD 处理器分别使用VT-d”和“I0MMU”，实现外部设备的地址转换。这两种技术都可以将PCI 总线域地址空间转换为不同的存储器域地址空间，便于虚拟化技术的设计与实现。

# IOMMU 的工作原理

