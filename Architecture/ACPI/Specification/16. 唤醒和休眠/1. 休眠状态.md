
下图显示了**工作状态**、**休眠状态**和**软关闭状态**之间的转换.

![2023-05-08-19-00-55.png](./images/2023-05-08-19-00-55.png)

SLP_EN




ACPI 定义了四种休眠状态的属性：S1、S2、S3 和 S4. (请注意, 从硬件的角度来看, S4 和 S5 非常相似. 与 ACPI 兼容的平台可以支持多种休眠状态. ACPI 指定将 **3 位二进制数**与每个**休眠状态相关联**(这些数字在 ACPI 的根命名空间中给定对象：(`\_S0`、`\_S1`、`\_S2`、`\_S3`、`\_S4` 和 `\_S5`).

进入系统休眠状态时, OSPM 将执行以下操作：

1. 选择平台和已启用的唤醒设备支持的最深休眠状态.

2. 执行 `_PTS` 控制方法(将预期**休眠状态的类型**传递给 **OEM AML 代码**)

3. 如果操作系统策略决定进入 S4 状态并选择使用 **S4BIOS** 机制, 并且平台支持 S4BIOS, OSPM 将通过将 `S4BIOS_REQ` 值写入 `SMI_CMD` 端口将控制权传递给平台运行时固件软件.

4. 如果不使用 S4BIOS 机制, OSPM 将从关联的休眠对象 (`\_S1`、`\_S2`、`\_S3`、`\_S4` 或 `\_S5`)获取 `SLP_TYPx` 值.

5. 用所选休眠对象中包含的值对 `SLP_TYPx` 字段进行编程.

> 兼容性 — `_GTS` 方法在 ACPI 5.0A 中已弃用. 对于早期版本, 执行 `_GTS` 控制方法, 传递一个参数, 指示要进入的休眠状态(1、2、3 或 4 表示 S1、S2、S3 和 S4).

6. 如果进入 S1、S2 或 S3, 请刷新处理器缓存.

7. 如果不进入 S4BIOS, 设置 `SLP_EN` 位以启动**休眠串行**. (这实际上发生在对 `PM1_CNT` 寄存器中的 `SLP_TYPx` 字段进行编程的**同一写入操作上**). 如果进入 S4BIOS, 请编写 `S4BIOS_REQ` 值到 SMI_CMD 端口.

8. 如果缺少硬件, 则使用 HWreduce ACPI 休眠类型值(从上述步骤 4 中的休眠状态对象检索)并将 `SLP_EN` 位设置为 1, 对 `SLEEP_CONTROL_REG FADT` 字段指示的寄存器进行编程.

9. 在包含没有硬件机制的处理器的系统上, 处理器处于低功耗状态, 执行适当的本机指令, 使处理器处于低功耗状态.

`_PTS` 控制方法为平台**运行时固件**提供了一种**执行某些内务处理**的机制, 比如在进入系统休眠状态之前, 将休眠类型值写入嵌入式控制器. 控制方法执行发生在**进入休眠状态**的 “**之前**”, 并且**不是**与写入 `PM1_CNT` 寄存器同步的事件. 执行可以在系统实际进入休眠状态之前几秒钟进行. 因此, 不会通过执行 `_PTS` 控制方法进行硬件电源平面排序.

> 兼容性 — `_BFS` 方法在 ACPI 5.0A 中已弃用. 在早期版本中, 唤醒时, 将执行 `_BFS` 控制方法. 然后, OSPM 执行 `_WAK` 控制方法. 此控制方法执行特定于 OEM 的 ASL/AML 代码, 该代码可以搜索在休眠状态期间添加或删除的任何设备.

# S1休眠态

S1 状态定义为低唤醒延迟休眠状态. 在此状态下, 将保留除 CPU 缓存之外的所有系统上下文. 在进入 S1 之前, OSPM 将刷新系统缓存. 如果平台支持 WBINVD 指令(如 FADT 中的 WBINVD 和 WBINVD_FLUSH 标志所示), OSPM 将执行 WBINVD 指令. 硬件负责维护所有其他系统上下文, 其中包括 CPU、内存和芯片组的上下文.

以下是 S1 休眠状态实现替代方案的示例.

##


# S2休眠态


# S3休眠态

S3 状态定义为低唤醒延迟(low wake-latency)休眠状态. 从软件的角度来看, 此状态在功能上与 S2 状态相同. 操作差异在于, 某些可能处于 S2 状态的电源资源可能不适用于 S3 状态. 因此, 当系统处于 S3 状态时, 某些设备可能处于比系统处于 S2 状态时更低的功耗状态. 同样, 某些设备唤醒事件可以在 S2 中起作用, 但不能在 S3 中起作用.

下面是 S3 休眠状态实现的示例.

## 示例:S3休眠态实现

当 `SLP_TYPx` 寄存器编程为 S3 值(在 `\_S3` 对象中找到)并设置 `SLP_EN` 位时, 或者将 S3 的硬件降低 ACPI 休眠类型值和 `SLP_EN` 位写入休眠控制寄存器时, 硬件将通过执行以下操作实现 S3 休眠状态转换：

1. 将内存置于低功耗自动刷新或自刷新状态.
2. 维护内存的设备将自己与系统中的其他设备隔离.
3. 断开系统电源. 此时, 只有支持内存的设备通电(可能部分通电). 系统中运行的唯一时钟是RTC时钟.

从 S3 休眠状态开始, 唤醒事件会重新为系统供电并重置大多数设备(具体取决于实施). 执行控制从 CPU 的引导矢量开始. 平台启动固件需要：

1. 对 CPU 的初始引导配置(如 MSR 和 MTRR 寄存器)进行编程.
2. 将缓存控制器初始化为其初始启动大小和配置.
3. 使内存控制器能够接受内存访问.
4. 跳转到唤醒的矢量.

请注意, 如果缓存控制器的配置在系统休眠时丢失, 则需要平台引导固件将其重新配置为休眠前状态或初始引导状态配置. 平台启动固件可以将缓存控制器的配置存储到保留的内存空间中, 然后在唤醒后可以在其中检索值.  OSPM 将在每个会话(休眠之前)调用一次 `_PTS` 方法.

平台启动固件还负责恢复内存控制器的配置. 如果此配置数据在 S3 休眠状态期间被破坏, 则平台启动固件需要将休眠前状态或初始启动状态配置存储在非易失性存储区(与 RTC CMOS RAM 一样)以使其能够恢复清醒过程中的值.

当 OSPM 重新枚举退出 S3 休眠状态的总线时, 它会发现任何已插入或移除的设备, 并在设备打开时对其进行配置.



# S5软关闭态


# 从工作状态转换成休眠状态

在系统从工作状态转换到休眠状态时，将发生以下情况：

一. OSPM 决定（通过策略方案）将系统置于休眠状态。

二. OSPM 调用 `_TTS` 方法来**指示**系统将转换到的最深层系统状态 （1， 2，3 或 4 表示 S1、S2、S3 和 S4）。

三. OSPM 检查所有启用唤醒系统的设备，并确定系统可以进入的最深休眠状态以支持已启用的唤醒功能。检查每个设备下的 _PRW 命名对象，以及它指向的电源资源对象。

四. OSPM 将所有设备驱动进程置于各自的 Dx 状态。如果设备已启用唤醒，它将进入与唤醒功能关联的 Dx 状态。如果未启用设备来唤醒系统，它将进入 D3 状态。

五. OSPM 执行 _PTS 控制方法,传递一个参数, 该参数指示所需的休眠状态(1、2、3、或 4 代表 S1、S2、S3 和S4)。

六. OSPM 将任何其他处理器的上下文（本地处理器除外）保存到内存中。

七. OSPM 将唤醒向量写入内存中的 FACS 表中。

> 注意：兼容性 — _GTS方法在 ACPI 5.0A 中已弃用。对于早期版本，OSPM 执行 _GTS 控制方法，传递一个参数，指示要进入的休眠状态（1、2、3 或 4 表示 S1、S2、S3 和 S4）。

八. 如果不是硬件降低的 ACPI 平台，OSPM 将清除 PM1a_STS 和 PM1b_STS 寄存器中的 WAK_STS。在硬件降低的 ACPI 平台上，OSPM 清除休眠状态寄存器中的 WAK_STS 位。

九. OSPM 将本地处理器的上下文保存到内存中。

十. OSPM 刷新缓存（仅当进入 S1、S2 或 S3 时）。

十一. OSPM 设置 GPE 使能寄存器或启用可唤醒中断以确保准备好所有适当的唤醒信号。

十二. 如果使用 S4BIOS 机制进入 S4 状态，OSPM 将 S4BIOS_REQ 值（来自 FADT）写入 SMI_CMD 端口。这会将控制传递给平台运行时固件，然后将平台转换为 S4BIOS 状态。

十三. 如果没有进入 S4BIOS 状态，也不是硬件减少的 ACPI 平台，则 OSPM 将 SLP_TYPa（来自关联的休眠对象）写入 PM1a_CNT 寄存器的 SLP_ENa 位。

十四. OSPM 将 SLP_EN 位设置为SLP_TYPb写入PM1b_CNT寄存器，或将硬件降低的 ACPI 休眠类型值和SLP_EN位写入休眠控制寄存器。

十五. 在包含没有硬件机制将处理器置于低功耗状态的处理器的系统上，OSPM 会执行适当的本机指令以将处理器置于低功耗状态。

十六. OSPM 在WAK_STS位上循环，无论是在PM1a_CNT和PM1b_CNT寄存器中，还是在SLEEP_STATUS_REG中，如果是硬件降低的 ACPI 平台。

十七. 系统进入指定的休眠状态。

> 注意：这是在上述步骤 14 或 15 之后完成的。
