
下图显示了**工作状态**、**休眠状态**和**软关闭状态**之间的转换。

![2023-05-08-19-00-55.png](./images/2023-05-08-19-00-55.png)

SLP_EN




ACPI 定义了四种休眠状态的属性：S1、S2、S3 和 S4。（请注意, 从硬件的角度来看, S4 和 S5 非常相似。与 ACPI 兼容的平台可以支持多种休眠状态。ACPI 指定将 **3 位二进制数**与每个**休眠状态相关联**（这些数字在 ACPI 的根命名空间中给定对象：（`\_S0`、`\_S1`、`\_S2`、`\_S3`、`\_S4` 和 `\_S5`）。

进入系统休眠状态时, OSPM 将执行以下操作：

1. 选择平台和已启用的唤醒设备支持的最深休眠状态。

2. 执行 `_PTS` 控制方法（将预期**休眠状态的类型**传递给 **OEM AML 代码**）

3. 如果操作系统策略决定进入 S4 状态并选择使用 **S4BIOS** 机制, 并且平台支持 S4BIOS, OSPM 将通过将 `S4BIOS_REQ` 值写入 `SMI_CMD` 端口将控制权传递给平台运行时固件软件。

4. 如果不使用 S4BIOS 机制, OSPM 将从关联的休眠对象 （`\_S1`、`\_S2`、`\_S3`、`\_S4` 或 `\_S5`）获取 `SLP_TYPx` 值。

5. 用所选休眠对象中包含的值对 `SLP_TYPx` 字段进行编程。

> 兼容性 — `_GTS` 方法在 ACPI 5.0A 中已弃用。对于早期版本, 执行 `_GTS` 控制方法, 传递一个参数, 指示要进入的休眠状态（1、2、3 或 4 表示 S1、S2、S3 和 S4）。

6. 如果进入 S1、S2 或 S3, 请刷新处理器缓存。

7. 如果不进入 S4BIOS, 设置 `SLP_EN` 位以启动**休眠串行**。（这实际上发生在对 `PM1_CNT` 寄存器中的 `SLP_TYPx` 字段进行编程的**同一写入操作上**). 如果进入 S4BIOS, 请编写 `S4BIOS_REQ` 值到 SMI_CMD 端口。

8. 如果硬件减少, 则使用 HWreduce ACPI 休眠类型值（从上述步骤 4 中的休眠状态对象检索）并将 SLP_EN 位设置为 1, 对 SLEEP_CONTROL_REG FADT 字段指示的寄存器进行编程。

9. 在包含没有硬件机制的处理器的系统上, 处理器处于低功耗状态, 执行适当的本机指令, 使处理器处于低功耗状态。

`_PTS` 控制方法为平台**运行时固件**提供了一种**执行某些内务处理**的机制, 比如在进入系统休眠状态之前, 将休眠类型值写入嵌入式控制器。控制方法执行发生在**进入休眠状态**的 “**之前**”, 并且**不是**与写入 `PM1_CNT` 寄存器同步的事件。执行可以在系统实际进入休眠状态之前几秒钟进行。因此, 不会通过执行 `_PTS` 控制方法进行硬件电源平面排序。

> 兼容性 — `_BFS` 方法在 ACPI 5.0A 中已弃用。在早期版本中, 唤醒时, 将执行 `_BFS` 控制方法。然后, OSPM 执行_WAK控制方法。此控制方法执行特定于 OEM 的 ASL/AML 代码, 该代码可以搜索在休眠状态期间添加或删除的任何设备。

# S1休眠态

S1 状态定义为低唤醒延迟休眠状态。在此状态下, 将保留除 CPU 缓存之外的所有系统上下文。在进入 S1 之前, OSPM 将刷新系统缓存。如果平台支持 WBINVD 指令（如 FADT 中的 WBINVD 和 WBINVD_FLUSH 标志所示）, OSPM 将执行 WBINVD 指令。硬件负责维护所有其他系统上下文, 其中包括 CPU、内存和芯片组的上下文。

以下是 S1 休眠状态实现替代方案的示例。

## 


# S2休眠态


# S3休眠态

S3 状态定义为低唤醒延迟(low wake-latency)休眠状态。从软件的角度来看, 此状态在功能上与 S2 状态相同。操作差异在于, 某些可能处于 S2 状态的电源资源可能不适用于 S3 状态。因此, 当系统处于 S3 状态时, 某些设备可能处于比系统处于 S2 状态时更低的功耗状态. 同样, 某些设备唤醒事件可以在 S2 中起作用, 但不能在 S3 中起作用。

下面是 S3 休眠状态实现的示例。

## 示例:S3休眠态实现

当 `SLP_TYPx` 寄存器编程为 S3 值（在 `\_S3` 对象中找到）并设置 `SLP_EN` 位时, 或者将 S3 的硬件降低 ACPI 休眠类型值和 `SLP_EN` 位写入休眠控制寄存器时, 硬件将通过执行以下操作实现 S3 休眠状态转换：

1. 将内存置于低功耗自动刷新或自刷新状态。
2. 维护内存的设备将自己与系统中的其他设备隔离。
3. 断开系统电源。此时, 只有支持内存的设备通电（可能部分通电）。系统中运行的唯一时钟是RTC时钟。

从 S3 休眠状态开始, 唤醒事件会重新为系统供电并重置大多数设备（具体取决于实施）。执行控制从 CPU 的引导矢量开始。平台启动固件需要：

1. 对 CPU 的初始引导配置（如 MSR 和 MTRR 寄存器）进行编程。
2. 将缓存控制器初始化为其初始启动大小和配置。
3. 使内存控制器能够接受内存访问。
4. 跳转到唤醒的矢量。

请注意, 如果缓存控制器的配置在系统休眠时丢失, 则需要平台引导固件将其重新配置为休眠前状态或初始引导状态配置。平台启动固件可以将缓存控制器的配置存储到保留的内存空间中, 然后在唤醒后可以在其中检索值。 OSPM 将在每个会话（休眠之前）调用一次 `_PTS` 方法。

平台启动固件还负责恢复内存控制器的配置。如果此配置数据在 S3 休眠状态期间被破坏, 则平台启动固件需要将休眠前状态或初始启动状态配置存储在非易失性存储区（与 RTC CMOS RAM 一样）以使其能够恢复清醒过程中的值。

当 OSPM 重新枚举退出 S3 休眠状态的总线时, 它会发现任何已插入或移除的设备, 并在设备打开时对其进行配置。

