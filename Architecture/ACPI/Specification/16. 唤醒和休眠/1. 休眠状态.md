
下图显示了**工作状态**、**休眠状态**和**软关闭状态**之间的转换。

![2023-05-08-19-00-55.png](./images/2023-05-08-19-00-55.png)

SLP_EN




ACPI 定义了四种休眠状态的属性：S1、S2、S3 和 S4。（请注意，从硬件的角度来看，S4 和 S5 非常相似。与 ACPI 兼容的平台可以支持多种休眠状态。ACPI 指定将 **3 位二进制数**与每个**休眠状态相关联**（这些数字在 ACPI 的根命名空间中给定对象：（`\_S0`、`\_S1`、`\_S2`、`\_S3`、`\_S4` 和 `\_S5`）。进入系统休眠状态时，OSPM 将执行以下操作：

1. 选择平台和已启用的唤醒设备支持的最深睡眠状态。

2. 执行 `_PTS` 控制方法（将预期睡眠状态的类型传递给 OEM AML 代码）

3. 如果操作系统策略决定进入 S4 状态并选择使用 S4BIOS 机制，并且平台支持 S4BIOS，OSPM 将通过将 S4BIOS_REQ 值写入 SMI_CMD 端口将控制权传递给平台运行时固件软件。

4. 如果不使用 S4BIOS 机制，OS `SLP_TYPx` PM 将从关联的休眠对象 （`\_S1`、`\_S2`、`\_S3`、`\_S4` 或 `\_S5`）。

5. 用所选睡眠对象中包含的值对 `SLP_TYPx` 字段进行编程。



> 兼容性 — `_GTS` 方法在 ACPI 5.0A 中已弃用。对于早期版本，执行 `_GTS` 控制方法，传递一个参数，指示要进入的休眠状态（1、2、3 或 4 表示 S1、S2、S3 和 S4）。


6. 如果进入 S1、S2 或 S3，请刷新处理器缓存。

7. 如果未进入 S4BIOS，请设置 SLP_EN 位以启动休眠串行。（这实际上发生在对 `PM1_CNT` 寄存器中的 SLP_TYPx 字段进行编程的同一写入操作上。如果输入 S4BIOS，请编写 S4BIOS_REQ 值到 SMI_CMD 端口。

8. 如果硬件减少，则使用 HWreduce ACPI 睡眠类型值（从上述步骤 4 中的睡眠状态对象检索）并将 SLP_EN 位设置为 1，对 SLEEP_CONTROL_REG FADT 字段指示的寄存器进行编程。

9. 在包含没有硬件机制的处理器的系统上，处理器处于低功耗状态，执行适当的本机指令，使处理器处于低功耗状态。

`_PTS` 控制方法为平台运行时固件提供了一种执行某些内务处理的机制，
比如在进入系统休眠状态之前，将睡眠类型值写入嵌入式控制器。控制方法执行发生在进入休眠状态的“之前”，并且不是与写入 `PM1_CNT` 寄存器同步的事件。执行可以在系统实际进入休眠状态之前几秒钟进行。因此，不会通过执行 `_PTS` 控制方法进行硬件电源平面排序。

> 兼容性 — `_BFS` 方法在 ACPI 5.0A 中已弃用。在早期版本中，唤醒时，将执行 `_BFS` 控制方法。然后，OSPM 执行_WAK控制方法。此控制方法执行特定于 OEM 的 ASL/AML 代码，该代码可以搜索在睡眠状态期间添加或删除的任何设备。

