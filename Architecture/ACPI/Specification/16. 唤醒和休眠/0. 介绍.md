
ACPI 定义了在**工作状态** (`G0`) 和**休眠状态** (`G1`) 或**软关闭** (`soft-off`, `G2`) 状态之间系统转换的机制. 在工作和休眠状态之间的转换期间，将维护用户操作环境的上下文. ACPI 通过定义**四种类型**的 ACPI **休眠状态**(`S1`、`S2`、`S3` 和 `S4`)的系统属性来定义 **G1 休眠状态**的质量. 每个休眠状态都经过定义，以允许在成本、功耗和唤醒延迟之间进行权衡的实现. 此外，ACPI 还定义了休眠状态，以便 ACPI 平台可以支持多个休眠状态，从而允许平台在预定义的时间段内转换到特定的休眠状态，然后转换到低功耗/较高的唤醒延迟休眠状态(通过 G0 状态转换)(请参阅下面的注释).

> OSPM 使用 RTC 唤醒功能或时间和警报命名空间设备在时间转换延迟中进行编程。在休眠之前，OSPM会将警报编程为最近的（及时）唤醒事件：过渡到低功耗休眠状态或日历事件（运行某些应用进程）。

ACPI 定义了一个**编程模型**, 该模型为 OSPM 提供了**一种机制**来启动**进入休眠**或**软关闭状态** (`S1-S5`); 该模型由一个 **3 位字段** `SLP_TYPx` (见下方注释)组成, 该字段指示要进入的**休眠状态类型**, 以及一个控制位 `SLP_EN` 来**启动休眠过程**. 在 HW 少的 ACPI 系统上, 使用 **FADT** 中的 `SLEEP_CONTROL_REG` 字段的寄存器, 而不是固定的 `SLP_TYPx` 和 `SLP_EN` 寄存器位字段.

> 请注意，可以有**两个**固定的 `PM1x_CNT` 寄存器，每个寄存器指向不同的**系统 I/O 空间区域**。通常，寄存器分组仅允许位或位字段驻留在单个寄存器组实例（a 或 b）中; 但是，每个平台可以有两个实例 SLP_TYP（每个分组寄存器一个：a和b）。\_Sx 控制方法给出一个包含两个值的包：第一个是 SLP_TYPa 值，第二个是 SLP_TYPb 值。

