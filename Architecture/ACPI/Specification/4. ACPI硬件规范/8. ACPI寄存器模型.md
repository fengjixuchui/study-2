
ACPI 硬件驻留在以下六个地址空间中的一个:

* System I/O, 系统 I/O
* System Memory, 系统内存
* PCI configuration, PCI 配置
* SMBus
* Embedded controller, 嵌入式控制器
* Functional Fixed Hardware, 固定功能硬件

不同的实现将导致不同的地址空间用于不同的功能. ACPI 规范由**固定硬件寄存器**(`fixed hardware registers`)和**通用硬件寄存器**(`generic hardware registers`)组成.

* **固定硬件寄存器**用来实现 ACPI 定义的接口;

* 增值硬件(value-added)生成的任何事件都需要**通用硬件寄存器**.

ACPI 定义了寄存器块. ACPI 兼容系统提供了一个 **ACPI 表**(`FADT`, 在启动时内置在内存中), 该表包含了一个**指针列表**, 用于指向 OSPM 使用的不同**固定硬件寄存器块**. 这些寄存器中的位具有为给定寄存器块定义的属性. ACPI 定义的**寄存器类型**有:

* 状态/使能 寄存器(用于事件)
* 控制 寄存器

如果一个寄存器块是 `状态/使能` 类型, 则它将包含一个**带有状态位的寄存器**和一个相应的**带有使能位的寄存器**. **状态位**和**使能位**有一个确切的实现定义, 这个实现定义是需要遵循的(除非另有说明), 如下图所示:

状态/使能单元格块图:

![2023-05-10-09-24-56.png](./images/2023-05-10-09-24-56.png)

注意, **状态位**(在本例中由硬件设置的**事件输入**)只能通过软件向其位位置写入 1 来清除. 同样, **使能位**对状态位的设置或重置没有影响; 它只确定 SET 状态位是否将生成一个"事件输出", 如果它的使能位被设置, 则在设置时生成一个 SCI.

ACPI 还定义了**寄存器分组**. **一个寄存器组**由**两个寄存器块**组成, **两个指针**指向两个不同的寄存器块, 其中**寄存器组中**的**每个位**位置是固定的, 不能改变. 一个寄存器组中的位具有固定的位位置, 可以在两个寄存器块之间分割. 这允许一个寄存器组中的位驻留在一个或两个寄存器块中, 促进了将几个不同芯片中的位映射到同一个寄存器的能力, 从而提供了具有单个寄存器组位结构的编程模型.

OSPM 将一个寄存器分组视为一个单独的寄存器; 但位于多个地方. 为了读取一个寄存器分组, OSPM 将读取"a"寄存器块, 然后读取"B"寄存器块, 然后在逻辑上"OR"这两个结果(SLP_TYP 字段是这个规则的一个例外). 寄存器块中的保留位或未使用位对于读总是返回 0, 对于写没有副作用(这是必需的).

对于每个寄存器分组, `SLP_TYPx` 字段可以是不同的. 各自的休眠对象\_Sx 包含一个 SLP_TYPa 和一个 SLP_TYPb 字段. 也就是说, 该对象返回一个包, 其中包含两个 0-7 的整数值. OSPM 总是将 SLP_TYPa 值写入"A"寄存器块, 然后将字段中的 SLP_TYPb 值写入"B"寄存器块. 所有其他位将被写入相同的值. 另外, OSPM 不会读取 SLP_TYPx 值, 而是将其丢弃.

示例固定硬件功能寄存器分组:

![2023-05-10-21-06-37.png](./images/2023-05-10-21-06-37.png)







