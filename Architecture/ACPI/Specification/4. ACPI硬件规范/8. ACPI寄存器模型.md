
ACPI 硬件驻留在以下六个地址空间中的一个:

* System I/O, 系统 I/O
* System Memory, 系统内存
* PCI configuration, PCI 配置
* SMBus
* Embedded controller, 嵌入式控制器
* Functional Fixed Hardware, 固定功能硬件

不同的实现将导致不同的地址空间用于不同的功能. ACPI 规范由**固定硬件寄存器**(`fixed hardware registers`)和**通用硬件寄存器**(`generic hardware registers`)组成.

* **固定硬件寄存器**用来实现 ACPI 定义的接口;

* 增值硬件(value-added)生成的任何事件都需要**通用硬件寄存器**.

ACPI 定义了寄存器块. ACPI 兼容系统提供了一个 **ACPI 表**(`FADT`, 在启动时内置在内存中), 该表包含了一个**指针列表**, 用于指向 OSPM 使用的不同**固定硬件寄存器块**. 这些寄存器中的位具有为给定寄存器块定义的属性. ACPI 定义的**寄存器类型**有:

* **状态/使能** 寄存器(用于事件)
* **控制** 寄存器

如果一个寄存器块是 `状态/使能` 类型, 则它将包含一个**带有状态位的寄存器**和一个相应的**带有使能位的寄存器**. **状态位**和**使能位**有一个确切的实现定义, 这个实现定义是需要遵循的(除非另有说明), 如下图所示:

状态/使能单元格块图:

![2023-05-10-09-24-56.png](./images/2023-05-10-09-24-56.png)

注意, **状态位**(在本例中由硬件设置的**事件输入**)只能通过**软件**向其 bit 位置**写入 1 来清除**. 同样, **使能位**对状态位的设置或重置没有影响; 它只确定 SET 状态位是否将生成一个"**事件输出**", 如果它的使能位被设置, 则在设置时生成一个 SCI.

ACPI 还定义了**寄存器分组**. **一个寄存器组**由**两个寄存器块**组成, **两个指针**指向两个不同的寄存器块, 其中**寄存器组中**的**每个位**位置是固定的, 不能改变. 一个寄存器组中的位具有固定的位位置, 可以在两个寄存器块之间分割. 这允许一个寄存器组中的位驻留在一个或两个寄存器块中, 促进了将**几个不同芯片**中的**位**映射到**同一个寄存器**的能力, 从而提供了具有单个寄存器组位结构的编程模型.

**OSPM** 将**一个寄存器分组**视为**一个单独的寄存器**; 但位于多个地方. 为了**读取**一个寄存器分组, OSPM 将读取"**A**"寄存器块, 然后再读取"**B**"寄存器块, 然后在逻辑上"OR"这两个结果(`SLP_TYP` 字段是这个规则的一个例外). 寄存器块中的**保留位**或**未使用位**对于读总是**返回 0**, 对于写没有副作用(这是必需的).

对于每个寄存器分组, `SLP_TYPx` 字段可以是不同的. 各自的休**眠对象** `\_Sx` 包含一个 `SLP_TYPa` 和一个 `SLP_TYPb` 字段. 也就是说, 该对象返回一个包, 其中包含**两个** 0-7 的整数值. OSPM 总是将 `SLP_TYPa` 值写入"**A**"寄存器块, 然后将字段中的 `SLP_TYPb` 值写入"**B**"寄存器块. 所有其他位将被写入相同的值. 另外, OSPM **不会读取** `SLP_TYPx` 值, 而是将其丢弃.

示例固定硬件功能寄存器分组:

![2023-05-10-21-06-37.png](./images/2023-05-10-21-06-37.png)

作为一个例子，上面的图代表了一个由**寄存器块 A** 和**寄存器块 B** 组成的**寄存器组**。Bit "a" 和 Bit "d" 是在寄存器块 b 中实现的，并且寄存器块 A 对这些位返回一个零。Bit "b"，"c" 和 "e" 在寄存器块 A 中实现，寄存器块 b 对这些位返回一个零。所有保留位或忽略位返回它们定义的 ACPI 值。

当**读**这个寄存器组时，OSPM 必须先**读 A 寄存器块**，然后读 B 寄存器块，然后对这两个寄存器做逻辑或，然后对结果进行操作。

**写入**到该寄存器组时，OSPM 先将需要的值写入到 A 寄存器组，再将**相同的值**写入到 B 寄存器组。

ACPI 定义了以下 Fixed Hardware 寄存器块。每个寄存器块从 FADT 获得一个单独的指针。这些地址由 OEM 设置为静态资源，因此它们永远不会被更改——OSPM 不能重新映射 ACPI 资源。定义了以下寄存器块:

寄存器块与寄存器分组:

![2023-06-25-10-57-20.png](./images/2023-06-25-10-57-20.png)

PM1 EVT 寄存器分组由 `PM1a_EVT` 和 `PM1b_EVT` 寄存器块组成，其中包含 Fixed Hardware 特征事件位。每个事件寄存器块(如果实现了)包含两个寄存器:一个状态寄存器和一个启用寄存器。每个寄存器组都有一个定义的不能更改的位位置; 但是，位可以在寄存器块(A 或 B)中实现。事件的 A 和 B 寄存器块允许芯片组将事件划分为两个或多个芯片。对于读操作，OSPM 将生成对关联的 A 和 B 寄存器的读操作，或这两个值，然后对这个结果进行操作。对于写操作，OSPM 将值写入两个寄存器块中关联的寄存器。因此，在实现事件寄存器时需要遵循两个规则:

* 保留位或未实现位总是返回零(控制或启用)。

* 写入保留位或未实现位没有影响。

PM1 CNT 组包含 Fixed Hardware 特征控制位，由 `PM1a_CNT_BLK` 和 `PM1b_CNT_BLK` 寄存器块组成。每个寄存器块与单个控制寄存器相关联。每个寄存器组都有一个定义的不能更改的位位置; 然而，位可以在寄存器块(A 或 B)中实现。当实现 CNT 寄存器时，有两个规则要遵循:

* 保留位或未实现位总是返回零(控制或启用)。

* 写入保留位或未实现位没有影响。

`PM2_CNT_BLK` 寄存器块目前包含一个用于仲裁禁用功能的位。通用事件寄存器包含通用特性的事件编程模型。与固定事件一样，所有通用事件都会生成 SCI。一般的事件状态位可以驻留在任何地方;但是，顶级通用事件驻留在一个通用寄存器块中。任何不在通用目的寄存器空间中的通用特性事件状态都被视为子状态位或兄弟状态位，其父状态位在通用目的事件寄存器空间中。请注意，在达到 GPE 事件状态之前，可能有 N 级通用事件。

通用的事件寄存器由两个寄存器块描述: `GPE0_BLK` 或 `GPE1_BLK`。每个寄存器块分别从 FADT 中指向。每个寄存器块进一步分解为两个寄存器: `GPEx_STS` 和 `GPEx_EN`。通用事件寄存器中的状态寄存器和启用寄存器遵循 Fixed Hardware 事件寄存器的事件模型。
