
前面我们已经看到过图6-29所示的结构，任何一种计算机协议都是采用这种分层结构的，下层总是为上层服务的。有些协议，图中所有的层次都有定义和实现；而有些协议，只定义了其中的几层。然而，要让一种协议能工作，它需要一个完整的协议栈，PCIe定义了下三层，NVMe定义了最上层，两者一拍即合，构成一个完整的主机与SSD通信的协议。

PCIe+NVMe协议栈:



PCIe最直接接触的是NVMe的事务层。在NVMe层，我们能看到的是64字节的命令、16字节的命令返回状态，以及跟命令相关的数据。而在PCIe的事务层，我们能看到的是事务层数据包（Transaction Layer Packet），即TLP。还是跟快递做类比，你要寄东西，可能是手机，可能是电脑，不管是什么，你交给快递小哥，他总是把你要寄的东西打包，快递员看到的就是包裹，他根本不关心你里面的内容。PCIe事务层作为NVMe最直接的服务者，不管你NVMe发给我的是命令，还是命令状态，或者是用户数据，我统统帮你放进包裹，打包后交给下一层，即数据链路层继续处理，如图6-30所示。

PCIe两设备通信示意图:



对 PCIe，我们这里只关注事务层，因为它跟NVMe的接触是最直接、最亲密的。PCIe事务层传输的是TLP，它就是个包裹，一般由包头和数据组成，当然也有可能只有包头没有数据。NVMe传下来的数据都是放在TLP的数据部分的（Payload）。为实现不同的目的，TLP可分为以下几种类型：

* Configuration Read/Write

* I/O Read/Write

* Memory Read/Write

* Message

* Completion

>注意，这个Completion跟NVMe层的Completion不是同一个东西，它们处在不同层。PCIe层的Completion TLP，是对所有Non-Posted型的TLP的响应，比如一个Read TLP，就需要Completion TLP来作为响应。
> 
> NVMe层的Completion，是对每个SQ中的命令，都需要一个Completion来作为响应。

在 NVMe 命令处理过程中，PCIe 事务层基本只用 Memory Read/Write TLP 来为 NVMe 服务，其他类型 TLP 我们可以不用管。主机发送一个 Read 命令，PCIe 是如何服务的？接下来，结合 NVMe 命令处理流程，我将带着大家把图6-31看懂，看看 NVMe 和 PCIe 的事务层发生了什么。

NVMe 读命令的 PCIeTrace图:



这张图密密麻麻的，到底是什么？别急，蛋蛋带你一步一步把它看懂。首先，主机准备了一个 Read 命令给 SSD（见图）。

首先，主机准备了一个Read命令给SSD（见图6-32）。

NVMe读命令:



也许你对NVMe Read命令格式不是很清楚，但从图6-32中，我们还是能得到下面的信息：主机需要从起始LBA 0x20E0448（SLBA）上读取128个DWORD（512字节）的数据，读到哪里去呢？PRP1给出内存地址是0x14ACCB000。这个命令放在编号为3的SQ里（SQID = 3）, CQ编号也是3（CQID = 3）。我觉得知道这些就够了。相信你看了前面章节的介绍，刚才说的这些应该都能懂。

当主机把一个命令准备好放到SQ后，接下来步骤是什么呢？回想一下NVMe命令处理的八个步骤。

第一步：主机准备好命令在SQ;（完成）

第二步：主机通过写SQ的Tail DB，通知SSD来取命令。

图6-33中，上层是NVMe层，下层是PCIe的事务层，这一层我们看到的是TLP。主机想往SQ Tail DB中写入的值是5。PCIe是通过一个Memory Write TLP来实现主机写SQ的Tail DB的。

