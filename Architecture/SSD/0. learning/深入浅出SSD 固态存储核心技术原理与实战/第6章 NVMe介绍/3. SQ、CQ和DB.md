
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [队列](#队列)
- [小结](#小结)

<!-- /code_chunk_output -->

# 队列


那么, DB 在命令处理流程中起了什么作用呢?




在这个限制下, 我们看看**主机**是怎样维护 SQ 和 CQ 的. SQ 的尾巴没有问题, 主机是生产者, 对新命令来说, 它清楚自己应该站在队伍哪里. 但是Head呢? SSD 在取指的时候, 是偷偷进行的, 主机对此毫不知情. **主机**发了取指通知后, 它并**不清楚 SSD 什么时候去取命令**、取了多少命令. 怎么办? 机智如你, 如果是你, 你会怎么做? 山人自有妙计. 给个提示(见图).

**SQ** 的 **Head DB** 在**命令完成状态**里:

![2023-02-05-23-18-47.png](./images/2023-02-05-23-18-47.png)

这是什么? 这是 **SSD** 往 **CQ** 中写入的**命令完成状态信息**(16字节).

是的, **SSD** 往 **CQ** 中**写入命令状态信息**的**同时**, 还把 **SQ Head DB 的信息**告知了主机！这样, **主机**对 **SQ 队列**的**头部和尾部的信息**就都有了, 可以轻松玩转 SQ.

CQ 呢? **主机**知道它队列的头部, 不知道尾部. 那**怎么能知道尾部**呢? 思路很简单, 既然 SSD 知道, 那你告诉我呗！SSD 怎么告诉主机呢? 还是**通过 SSD 返回命令状态信息**获取. 看到上图中所示的 "**P**" 了吗? 干什么用? 做标记用.

具体是这样的: 一开始 **CQ** 中每条命令完成将条目中的 "P" 比特初始化为 0 的工作, SSD 在往 CQ 中写入命令完成条目时, 会把 "P" 写成 1(如果之前该位置为 1, Controller 写 CQ 的时候翻转该比特, 即写 0). 记住一点, CQ 是在主机端的内存中, 主机可以检查 CQ 中的所有内容, 当然包括 "P"了. 主机记住上次队列的尾部, 然后往下一个一个检查 "P", 就能得出新的队列尾部了. 就是这样, 如下图所示.

主机根据 PhaseTag 计算 CQ 队列的尾部:

![2023-02-05-23-18-39.png](./images/2023-02-05-23-18-39.png)

# 小结

最后, 给大宝做个小结:

* DB 在 SSD Controller 端, 是寄存器;

* DB 记录着 SQ 和 CQ 队列的头部和尾部;

* 每个 SQ 或者 CQ 有两个 DB —— Head DB 和 Tail DB;

* 主机只能写 DB, 不能读 DB;

* 主机通过 SSD 往 CQ 中写入的命令完成状态获取其队列头部或者尾部.




----


PCIe TLP 的类型有很多, 如下图, 不过,  NVMe 只挑选了 Memory Read/Wirte 传递信息

----














