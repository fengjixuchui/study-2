
# 指令处理的数据类型

在x86/x64体系中, **指令处理的数据**分为`fundamental`(基础)和`numeric`(数值)两大类. 

## fundamental基础类型

- **基础类型**包括: `byte`(8位), `word`(16位), `doubleword`(32位), 以及`quadword`(64位), 它们代表指令能一次性处理的**数据宽度**. 

## numeric数值类型

- **numeric数据类型**使用在**运算类指令**上, 总结来说x86/x64体系的**运算类指令**能处理下面**四大类数据**. 

    ① `integer(整型数)`: 包括**unsigned类型**和**singed类型**. 

    ② `floating-point(浮点数)`: 包括`single-precision floating-point`(单精度浮点数), `double-precision floating-point`(双精度浮点数), 以及`double extended-precision floatingpoint`(扩展双精度浮点数). 

    ③ `BCD(binary-code decmial integer)`: 包括`non-packed BCD码`和`packed-BCD码`. 

    ④ `SIMD(single instruction, multiple data)`: 这是属于`packed类型`的数据. 

SIMD数据是在一个operand(操作数)里集成了多个integer、floating-point或者BCD数据. SIMD指令可以一性次同时处理这些数据. 

# integer数

在计算机处理中, **整数**会区分**signed**(`有符号数`)和**unsigned**(`无符号数`)两种情况, 数值的**MSB值**被作为**符号位**. 每个数值类型有自己的取值范围, 如下所示. 

![2020-02-09-19-49-24.png](./images/2020-02-09-19-49-24.png)

可是在计算机中根本无法判断一个整数是signed数还是unsigned数. 例如0ABh这个整数就无法知道它是signed数还是unsigned数. 

计算机能做到的是: 在整数的使用中, 在应该使用signed数的场合下认为它是signed数, 而在使用unsigned数的场合下认为它是unsigned数. 

在这种假定下, 即使不是signed数也会被当做signed数进行处理. 既然这样, 在计算机运算中就无须判断是signed数还是unsigned数, 只需假定它是signed数或是unsigned数. 

而在浮点数上, 每个浮点数都有符号位, 因此浮点数能够清楚地识别它就是signed数. 所以浮点数不存在unsigned数的情况. 

在x86机器上, 对整数的加减法运算过程中不会识别signed数与unsigned数, 而根据signed与unsigned两种运算结果进行相应的eflags标志位设置. 

代码清单1-3: 

```asm
mov eax, 0x70000000
mov ebx, 0x80000000
sub eax, ebx
```

上面的代码中, 0x70000000和0x80000000是signed数还是unsigned数呢?

二进制运算结果值是0xF0000000, 指令会同时对结果进行两种分析设置. 

## 为signed时

假定运算双方是signed数时, 这个结果是错误的, 它产生了溢出. 它会置eflags寄存器的OF(Overflow Flag)标志为1, 以及SF(Sign Flag)标志为1, 表示结果为负数. 

## 为unsigned时

假定双方是unsigned数时, 它会置CF(Carry Flag)标志为1, 表示产生了借位. 

因此: 这条指令会同时对OF、SF及CF标志置位. 而对这个结果如何运用那是程序员的职责. 

另外, RISC体系的机器普遍会在指令层上做假定运算, 如在MIPS机器上add是进行signed数相加, addu是进行unsigned数相加, 对指令进行了区分, 明确了使用场合. 

x86的乘法和除法指令也进行了区分, mul是无符号数乘法, imul是符号数乘法, div是无符号除法, idiv是符号数除法. 另外, 所有的条件转移、条件传送、条件设置指令会对指令运算的结果进行signed与unsigned的区分. 

## 整数运算规则

当假定它是signed数时, 这个数需要使用另一种形式去解析, 这就产生了signed数的表示方法. signed的表示法是以MSB(Most Significant Bit)作为符号位, MSB为1时是负数, MSB为0时为正数. 

![2020-02-09-19-56-19.png](./images/2020-02-09-19-56-19.png)

以32位的数为例: 0是正数的最小值, 0x7FFFFFFF是正数的最大值, 0x80000000是负数的最小值, 0xFFFFFFFF是负数的最大值, 超过这个表达范围就产生了溢出情况. 

>0x7FFFFFFF+0x00000001结果为0x80000000, 这个结果超过了32位正数能表达的最大值, 于是就产生了溢出. 两个正数相加, 32位的结果为负数(负数的最小值). 这个结果是错误的. 

signed数是以二进制的补码来表示, 以4位二进制数为例, 求出-7的二进制补码形式. 

![2020-02-09-19-58-21.png](./images/2020-02-09-19-58-21.png)

-7的补码形式是1001B, 它的计算过程是: ～7+1=-7. 那么反过来, 1001B这个值是多少呢?从-7的求值过程可以推出: ～((-7)-1), 从而得出

![2020-02-09-19-58-36.png](./images/2020-02-09-19-58-36.png)

由于1001B表达的是负数, 求值后要加上负号, 这就是我们所知道的十进制的signed数. 

# floating-point数

现在的计算机浮点数格式都遵循`IEEE754`标准. 

在x86/x64体系中有**三种浮点数**. 

① `single-precision floating point`(单精度浮点数): 使用23位的精度. 

② `double-precision floating point`(双精度浮点数): 使用52位的精度. 

③ `double extended-precision floating point`(扩展双精度浮点数): 使用64位的精度. 

x87 FPU的硬件上使用扩展双精度浮点类型, 所有浮点数最终都要转为扩展双精度浮点数进行处理(使用64位精度). 

## 二进制格式

在计算机上, 浮点数需要换化为二进制格式进行处理, 分为3个部分: sign(符号位), exponent(指数位), 以及significand(有效数位), 如下所示. 

![2020-02-09-21-45-47.png](./images/2020-02-09-21-45-47.png)

最高位为符号位, 单精度浮点数的exponent位是8位, significand位是23位; 双精度浮点数的exponent位是11位, significand位是52位. 

在单精度和双精度浮点数里, 它们的significand部分有一个隐式的integer位(或被称为J-bit), 这个位的值固定为1. 因此, 单精度浮点数的精度实际为24位, 而双精度浮点数的精度实际为53位. 

## 扩展双精度浮点数

在扩展双精度浮点数里, significand部分为64位, exponent为15位, 如下所示. 

![2020-02-09-21-47-53.png](./images/2020-02-09-21-47-53.png)

在扩展双精度浮点数里, 它的integer位是显式的, 在normal(合规的)数里, 这个位必须为1, 否则属于denormal(不合规的)数. 

## normalized(规格化)

在IEEE754里, 规格化是浮点数的基础. 正常情况下机器中的浮点数使用规格化的格式, 这类浮点数被称为normal数. 

看看这个浮点数: 0.625, 在机器中是如何表示的呢?

首先需要转化为规格化的科学计数形式. 

![2020-02-09-21-50-15.png](./images/2020-02-09-21-50-15.png)

于是0.625的二进制科学计数法表达是`1.01×2^-1`. 

在IEEE 754中规定规格化数的significand(有效数)部分第1位是1, 不能是0. 如下所示. 

![2020-02-09-21-58-39.png](./images/2020-02-09-21-58-39.png)

接下来, 这个浮点数被转化为单精度的二进制形式, 其值为0x3F200000. 如下所示. 

![2020-02-09-21-58-45.png](./images/2020-02-09-21-58-45.png)

由于单精度浮点数的significand部分含有隐式的1值, 因此在二进制数格式里, significand部分的值为01000000...(即1.01中前面的1去掉). 

指数部分需要加上一个127值, 这个值被称为biased notation(移码或校正值). 

## biased notation(校正值)

biased notation用来解决浮点数使用integer方法进行比较时出现的问题. 我们看看下面这两个浮点数大小的比较: 1.00×2-1和1.00×21. 

前面的指数为-1, 后面的指数为1, 指数大的那个必定会大. 因此1.0×21的值是大于1.0×2-1的. 在指数相同的情况下才需要对有效数部分进行比较. 

基于这种考虑, IEEE 754在浮点数的格式中, 将指数部分安排在有效数前面, 这样就可以使用快速的整数比较方法来比较浮点数. 

可是当指数是负数时, 按照这样的比较方法, 会得出比指数为正数还要大的结论, 这是错误的. 

>`1.0×2^-1`会比`1.0×2^1`要大！(因为: -1的二进制8位值为11111111)

为了解决这个问题, 于是引入了biased notation值, 如下所示. 

![2020-02-09-22-00-40.png](./images/2020-02-09-22-00-40.png)

单精度的biased码是127, 双精度的biased码是1023, 扩展双精度的biased码是16383. 这个biased码值加上指数值, 就得出了一个浮点数格式中的指数值: -1+127=126, 1+127=128. 

算一下. 

`1.0×2^-1`的二进制序列是: 001111110000000000000000000000000(0x3F000000). 

`1.0×2^1`的二进制序列是: 010000000000000000000000000000000(0x40000000). 

这样就解决了在使用整数进行比较时, 负的指数会比正的指数要大的问题. 

在nasm汇编语言语法里, 可以使用一系列的宏来获得浮点数以整数形式表现的常量值. 
代码清单1-4: 

```
mov eax, __float32__(0.625)                    ;  获得浮点数的整数形式值
```

`__float32__(0.625)`这个宏的求值结果是`0x3f200000`, 即0.625的浮点数值是0x3f200000. 

# real number(实数)与NaN(not a number)

IEEE754标准定义了多种实数的编码格式, 它们包括以下面几种格式. 

① zero: 包括`+0.0`和`-0.0`编码. 

② denormal数字: 不合规格的数, denormal数有时候被称为tiny(极小)数. 

③ normal数字: 合规的普通浮点数, 这是一个finite(有限的)取值范围. 

④ infinite(无限)数字: 包括`+∞`(正无穷大数)和`-∞`(负无穷大数). 

⑤ NaN(not a number): 包括SNaN和QNaN. 

其编码值如下所示. 

![2020-02-09-22-05-45.png](./images/2020-02-09-22-05-45.png)

## zero

在0的编码里, exponent和significand都为0. +0(正零)和-0(负零)的值是相等的. 

## denormal(不合规)数

denormal数是一个极小的数(即tiny数), 接近于0值. 它是一种不合规的表示方法. denormal数的exponent部分为0值. 不同于zero值, 它的significand部分不为0值(在扩展双精度下exponent为0值, J位为0值也属于denormal数). 因此, 下面的数是denormal数. 

① 00000001H: exponent为0, significand不为0. 

② 007FFFFFH: exponent为0, significand不为0. 

normal(合规)数

normal数是在finite(有限)集合里的一个数. 在normal数编码中, J位的值必须为1(在扩展双精度下). 在单精度和双精度里, J位(或称integer位)是隐式的, 固定为1值. 

![2020-02-09-22-08-26.png](./images/2020-02-09-22-08-26.png)

上面列出了三种浮点格式的exponent和significand取值范围, 于是有以下结论. 

① 单精度的表达范围, 正数是0x00800000～0x7F7FFFFF, 负数是0x80800000～FF7FFFFF. 

② 双精度的表达范围, 正数是0x00100000_00000000～0x7FEFFFFF_FFFFFFFF, 负数是0x80100000_00000000～0xFFEFFFFF_FFFFFFFF. 

③ 扩展双精度的表达范围, 正数是0x0001_800000000_00000000～0x7FFE_FFFFFFFF_FFFFFFFF, 负数是0x8001_80000000_00000000～0xFFFE_FFFFFFFF_FFFFFFFF. 

用科学计数法表示如下. 

① 单精度: 2-126到2127×1.11...(23个1), 因此X的取值就是2-126<=X<2128. 

② 双精度: 2-1022到21023×1.11...(52个1), 因此X的取值就是2-1022<=X<21024. 

③ 扩展双精度: 2-16382到216383×1.11...(64个1), 因此X的取值就是2-16382<=X<216384. 

infinite(无穷大)数

显然, 这是与finite数相对的. 在无穷大数里值是固定的, 分为+∞(正无穷大)和-∞(负无穷大). exponent和significand的值如下所示. 

![2020-02-09-22-08-41.png](./images/2020-02-09-22-08-41.png)

对于扩展双精度来说, 由于它的J位是显式的, 必须为1值(否则是unsupported类型), 因此significand的值为0x80000000_00000000. 

NaN(not a number)数

如果一个数超出infinite, 那就是一个NaN(not a number)数. 在NaN数中, 它的exponent部分为可表达的最大值, 即FF(单精度)、7FF(双精度)和7FFF(扩展双精度). 

NaN数与infinite数的区别是: infinite数的significand部分为0值(扩展双精度的bit63位为1). 而NaN数的significand部分不为0值. 

NaN数包括下列两类. 

① SNaN(Signaling NaN)数: SNaN数表示是一种比较严重的错误值. 

② QNaN(Quiet NaN)数: 在一般情况下, QNaN数是可接受的. 

SNaN和QNaN数的编码区别在于significand部分的不同, 如下所示. 

![2020-02-09-22-09-01.png](./images/2020-02-09-22-09-01.png)

.....