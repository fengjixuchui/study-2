
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 时钟分类](#1-时钟分类)
  - [1.1. 周期性时钟](#11-周期性时钟)
  - [1.2. 单次计时时钟](#12-单次计时时钟)
- [2. x86平台的常用时钟](#2-x86平台的常用时钟)
  - [2.1. PIT: 可编程间隔时钟](#21-pit-可编程间隔时钟)
  - [2.2. RTC: 实时时钟](#22-rtc-实时时钟)
  - [2.3. TSC: 时间戳计数器](#23-tsc-时间戳计数器)
  - [2.4. LAPIC Timer: 本地时钟中断](#24-lapic-timer-本地时钟中断)
  - [2.5. HPET: 高精度时钟](#25-hpet-高精度时钟)
- [3. 操作系统的时钟观](#3-操作系统的时钟观)
  - [3.1. 统计值和驱动事件](#31-统计值和驱动事件)
  - [3.2. 定时器](#32-定时器)

<!-- /code_chunk_output -->

# 1. 时钟分类

现代计算机中, 操作系统中很多事件都是时钟驱动的, 例如进程调度、定时器等.

操作系统时钟从作用上分为两种: 计时和定时器

硬件方面，x86 主流平台，**计时**靠**tsc**，**定时**靠**local apic timer**. 

软件方面，linux, 低精度，高精度，先低精度然后切换到高精度. 

时钟根据**工作方式**不同, 可以分为如下两类.

## 1.1. 周期性时钟

⓵ **周期性时钟**(Periodic Timer): 时钟以固定频率产生时钟中断. 

通常, 周期性时钟会有**一个计数器**, 
- 要么以**固定值递减到0**产生**中断**, 例如PIT; 
- 要么**固定增长**, 当**达到某个阙值**时产生**中断**, 同时自动将阙值增加一个固定值, **计数器继续递增**, 例如**HPET**.

## 1.2. 单次计时时钟

⓶ **单次计时时钟**(One\-shot Timer): 多数时钟都可以配置成这种方式, 例如PIT、HPET. 

其工作方式和**到达阙值产生中断的周期性时钟**类似, 不同的是**产生中断后阙值不会自动增加**, 而是需要**软件**(通常是时钟中断处理函数)**增加该阙值**. 

这提供给软件**动态调整下一次时钟中断**到来时间的能力, 使一些新技术,例如**无滴答声内核**(**Tickless Kernel**)的实现成为可能.

# 2. x86平台的常用时钟

由于历史原因, x86平台有多种时钟, 目前仍广泛使用的有以下几种.

## 2.1. PIT: 可编程间隔时钟

(1) **PIT**: Programmable Interrupt Timer或Programmable Interval Timer, **可编程中断/间隔时钟**

IBM PC平台产生, 频率为**1000Hz左右**, 即**每次中断间隔约为1ms**, 通常接**IRQ0**产生**周期性的时钟中断信号！！！** 来充当**系统定时器**, 软件可以通过`0x40~0x43 I/O`端口进行操作. 

通过古老的8259pic 0号中断响应 `timer_interrupt` 这个中断处理函数

PIT是一种低精度的时钟, 容易溢出(16位), 已渐渐被高精度时钟取代. 现在的Linux基本上不怎么用它. 说白了它就是个**硬件实现的计数器系统**，通过**时钟中断**来满足操作系统的**定时器需求**，通过写某些位来设置定时器，操作系统同时也要维护一套软件的定时器链表，与这个硬件链表进行对应

PIT支持**周期性**和**单次计时**两种方式.

8254 PIT有**3个计时通道**, 每个通道都有其不同的用途:

- **通道0**用来负责**更新系统时钟**. 它在**每个时钟滴答**会通过**IRQ0**向系统发出一次**时钟中断信号**.
- **通道1**通常用来控制**DMAC对RAM的刷新**
- **通道3**被连接到**PC机的扬声器**, 以产生**方波信号**.

## 2.2. RTC: 实时时钟

(2) **RTC(Real Time Clock, 实时时钟**): 支持**周期性**和**单次计时**两种方式.

通常**和CMOS集成**在一起, 由**CMOS电池供电**, 故能在**关机后继续计时**. 开机时读取，需要的时候写入，它能够提供**稳定的时钟脉冲**，其频率范围是`2~8192Hz`, 通常接**IRQ8**, 软件可以通过`0x70~0x71 I/O`端口操作. 

此外, 它还可以配置成**每秒产生一次中断！！！**, 具有**闹钟功能**. 由于具有**关机继续计时**的功能, RTC常被用来作**为操作系统提供日期**. 即"年/月/日".

在Linux中，可以用RTC来获取当前的时间. 它提供的稳定的脉冲就是可编程计数器的最底层. 也就是说它是PIT和HPET的源头. 

## 2.3. TSC: 时间戳计数器

参见: `Architecture/Learning/x86_64编程体系探索及编程/第3篇 调试和性能监控/第15章 性能监控/6. Time-stamp counter与clock.md`

(3) **TSC(Time Stamp Counter, 时间戳计数器**): 由于**不产生时钟中断！！！**, 故没有周期性或单次计时方式之说.

和普通时钟不同, 可以看作一个**单调递增的计数器(64位**), 是由x86架构引入的. 

TSC的主体是位于CPU里面的一个64位的**TSC寄存器**. **每个CPU时钟周期**其值加一, 即**每个时钟信号**到来时加1.

其**时钟频率**和**CPU的频率**相关, 操作系统在使用前**需要计算其频率**, 例如**1GHz**的TSC, 其值**每纳秒增加1**. 

通过**rdtsc**指令, 可以读取**当前TSC的值**. 通过它**也可以校准RTC**. 很多系统都是通过**读取这个时间**来作为**系统的时间**.



Linux提供的API —— `gettimeofday()`可以获取**微秒级的精度**. 但是，首先它**不能**提供**纳秒级精度**，其次，他是一个**库函数**(可能不是系统调用)，自身就有一定的开销，当需要纳秒级精度时，误差会很大. 

而且，**测定函数的性能**，以**时钟周期**为单位比纳秒更加合理. 当不同型号的CPU的频率不同时，运行时间可能差很多，但是时钟周期应该差不了多少(如果指令集一样的话). 

那么怎么测定时钟周期呢？x86处理器为我们提供了rdtsc指令. 从pentium开始，很多x86处理器都引入了TSC(Time Stamp Counter)，一个64位的寄存器，每个CPU时钟周期其值加一. 它记录了CPU从上电开始总共经历的时钟周期数. 一个2.5GHz的CPU如果全速运行的话，那么其TSC就会在一秒内增加2,500,000,000. 在使用过程中，不用担心TSC会溢出，因此64位整数可以“应付”一个2.5GHz的CPU运行217年！

rdtsc指令把TSC的低32位存放在EAX寄存器中，把TSC的高32位存放在EDX寄存器中. 该指令可以在用户态执行. 




## 2.4. LAPIC Timer: 本地时钟中断

(4) **LAPIC Timer**: 该时钟是根据**LAPIC所在总线**(**系统总线**或**APIC总线**)频率产生的. 

这个是针对smp系统的时钟，当系统没有本地时钟的时候，也可以通过时钟广播的方式模拟这个本地时钟，在smp系统中linux会优先选择这个时钟源，一旦使用了这个时钟，0号中断绑定的时钟源的profiling和update功能将会被switched off. 比如pit将会从periodic转变为oneshot. 所以只要打开了local apic，将优先使用这个时钟源. 它的中断处理函数smp_apic_timer_interrupt. 它在x86 arch里面的entry_64.s汇编文件中built. 有点复杂. 实现在apic.c中. 

为32位, 有如下两个特点.

⓵ 由于LAPIC是每个CPU一个, 故其中断也是**对于本地CPU的**(Per CPU Interrupt).

⓶ 可通过**寄存器配置**, 对总线周期进行不同的分频而产生**不同频率的时钟中断！！！**.

LAPIC Timer可配置成**周期性**和**单次计时**两种工作方式.

## 2.5. HPET: 高精度时钟

(5) **HPET**(High Precision Event Timer, 高精度事件时钟): Intel和微软共同开发的新型高精度时钟, **最低频率10MHz**, 可作为64位或32位时钟使用. 

HPET可以提供**最多8个时钟**, 典型实现至少有一个时钟可用. 

HPET时钟通过**一个主计数器**, 和**32个比较器、匹配器**一起, 又可以被配置成**32个子时钟**(又称channel), **每个子时钟**可按不同频率产生不同的中断. 

例如, 可将**一个子时钟**配置成**每毫秒**产生一个**IRQ8中断**, **另一个子时钟**可配置成每毫秒产生一个**IRQ0中断**. 

HPET被设计用来**代替**传统8254 **PIT**可编程定时器的**全部功能**和实时钟**RTC**芯片的**周期性中断功能**, 此时平台的**IRQ0**、**IRQ8**中断**被HPET占用**.  cpu内部时钟源，同样响应0号中断响应timer_interrupt. Linux中hpet已经取代了pit，有hpet系统先选择hpet.

HPET支持**周期性**和**单次计时**两种工作方式. 

同时使用多个时钟带来一个明显缺点是**过多时钟中断会影响系统的性能(！！！**). 

所以, 当高精度时钟可用, **OS通常会禁用低精度时钟(！！！**), 并根据需要使用**高精度时钟模拟低精度时钟**.

# 3. 操作系统的时钟观

* 硬件方面, x86 主流平台, **计时**靠`tsc`，**定时**靠`local apic timer`. 

* 软件方面, linux, 低精度，高精度, 先低精度然后切换到高精度. 

两个系统时钟的常识**jiffies**和**xtimer**，前者是linux系统时钟的**累计数字**，后者是系统的**墙上时间**. 

从操作系统角度看, **时钟作用**可以分为如下两类.

## 3.1. 统计值和驱动事件

⓵ 提供**统计值**及**驱动事件**: 

- 提供**统计值**是指操作系统用时钟来**维护一些必需的数据**, 例如一个**进程**在**用户态/内核态的时间**, 系统的日期、时间等.

- **驱动事件**是指**驱动以时间为资源的程序！！！**, 典型就是进程. 例如, 分时操作系统为**每个进程分配固定的时间片**, 调度时间片耗尽的进程睡眠, 唤醒分配到新时间片的进程运行.

## 3.2. 定时器

⓶ **维护定时器(Timer**): 定时器是程序中常用的组件, 用于在某个指定时间到达后执行特定的操作. 定时器大量运用于操作系统中, 例如内核为I/O操作注册的超时定时器、操作系统提供给应用程序使用的定时器接口等. 见图2\-19.

![](./images/2019-07-01-17-41-22.png)

图中可看到, 操作系统使用时钟的功能, 是以时钟中断为基础的. 要了解时钟的作用, 可以以时钟中断为脉络, 勾画出整个框图.

操作系统往往会对时钟架构进行封装以方便维护和使用. 但从**硬件角度**看, 时钟中断仍然是所有封装的基础, 故**虚拟化**中**对时钟的处理**主要是提供**准确的时钟中断**以**模拟硬件**的行为.