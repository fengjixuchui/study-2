
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 什么是isa](#1-什么是isa)
- [2 CPU架构](#2-cpu架构)
- [参考](#参考)

<!-- /code_chunk_output -->

# 1 什么是isa

isa, instruction set architecture. 中文就是指令集合架构. 在计算机里面什么是isa呢?就是xx定义的一个**指令集**这里的xx可以指任何东西. 比如你只会做加法你就定义一个叫假发isa(不是假发是桂)这个指令集只做加法这也是一个isa. 任何一个isa对于另外一个isa都没有根本意义上的"先进"isa之间的对比是非常复杂的. 你只会做加法我只会做乘法你说我们谁先进?我见得比较多的是争吵x86 isa比arm isa先进的我往往一脸懵逼好像他们比我懂我是不是不应该插一腿进去...

**x86 isa**现在是**Intel**和**AMD**共同拥有也就是说如果你要开新的x86cpu公司你必须向这两者付版权费用而且必须两者都同意你才能获得完整的isa如果你只获得一部分不完整的isa那就和完全没拿到isa一样. **ISA**在cpu里面就像是**字典**用厨房的比喻就是菜谱菜谱定义了你这个厨房会做什么菜这个菜做出来是什么样什么味道那么顾客在这家连锁店的任何一间都能叫到相同的菜吃到相同的味道. 

ARM isa 当然是ARM公司所有的当时ARM公司是定菜单的并且给出试菜的人说你们每家店都要做出这个味才算ARM. 而做店的则是不同的公司像qualcomn啦他们中间喜欢怎么做菜是他们的自由但是必须会那几道菜必须做出这个味. 

各家的菜单都一样所以顾客不需要知道是谁做的菜只要是这个菜单做出来肯定一个味. 因为操作系统根本不需要知道你cpu是怎么设计的操作系统只要知道我需要运行这些指令你知道怎么运行就行了每个不同牌子的cpu只要你运行出来结果都一样就行了. 如果isa定义1+1=9那么这个是定义下来的所有人都这样错就没错. 如果isa定义了1+1=9你要纠正他我的cpu是1+1=2那么你做出来的cpu虽然数学上正确但是所有软件系统就突然不知道怎么办了. 你说这么愚蠢的错误cpu不可能犯是吧?自行百度一下苹果75-37.5 bug(虽然不一定是cpu或者isa上的错误也许是软件上的)

然后又有人说ISA是铁定下来的x86的良好生态环境是因为他的ISA一直有legacy支持. legacy直接翻译就是遗产. x86的legacy支持的意思就是世界上第一个x86cpu支持的东西今年你发明的x86 cpu也支持以后的也要支持. 的确从某个角度上来说农企和Intel都非常努力的去支持很多已经没什么人的东西就是餐馆里菜谱里面有些菜基本上你都不会去试的. 你说你都不用了农企Intel还在那里浪费设计是吧?你不用不代表没人用啊X国很多军用的设备还是Windows95啊甚至还是服役中的Windows3.1啊银行的atm还有用Windows98的. 别问我为什么他们要那样如果他们肯花钱找些软件工程师重新写那些程序就可以用最新的东西很多没有注释现在没有人学的语言或者算法诡异的程序很多军事设备还在用啊. 原因大概是: 这种语言连学都没人学我自己都看不懂我看你怎么破解我的坦克系统！

但是实际上x86又不是完全100%legacy支持的至少isa上面没有这样定义农企和Intel也没有官方明文定义. x86里面有一个指令叫cpuid系统/编译器运行它的时候它会给出一些数据就是告诉系统/编译器这个cpu支持什么东西这个cpu有些什么新东西之类的. 所以理论上可以设计一个cpu不支持那些非常少用的指令以降低cpu的设计复杂程度也更省电省事. (对不起你想吃的这个菜我们不卖了你找另外一家试试)

# 2 CPU架构

如果你有编程经验你有没有想过你写的代码是怎么运行的?我当初就是由于这个原因而对cpu感兴趣然后不知不觉进了这一行. 我和知乎某czh用户(据说已成教)是某理工大学同学我的编程能力远不及他. 但是我是这样的一个人我看到轮子转我就想知道轮子是怎么转的我就想拆开马达拆开电线然后学物理学磁感线然后知道是什么让轮子转. 后来由于各种原因我有缘接触汇编cpu架构之后对比起编程我对cpu的运行原理非常兴趣我是兴趣使动的然后就花时间去研究了. 其实UIUC对于半导体EE那边的研究更多更有趣但是那边的教授的所有课让我对computer architecture的有浓厚兴趣. 我学习过程是这样的怎么写c->c怎么编译会汇编语言->汇编语言怎么在cpu里面运行->cpu的组成->transistor的原理->半导体的电子学应用->半导体的工业使用. 在学习半导体的时候对各种光学半导体也曾经非常感兴趣没有继续学下去的原因是设备太贵了里面的数学太难了(对说的就是数学很多方程都没有解答方法很多是以前的数学家通过直接观察式子然后试答案试出来的所以很多differential equation要单纯靠记忆我对背书非常非常不在行如果有哪一天有数学家发现了可以怎么算我学了算法也许还能去学一点)！后来就去研究cpu怎么才能提高效率. 

回归正题代码是怎样运行的呢?给纯来看科普的读者的厨房比喻你要组织一个宴会然后你说了要弄些什么你就是软件. 然后有个人专门根据你你要求弄成一份菜单他就是编译器. 然后把这份菜单给厨房基本上就是: 读菜单拿食材(instruction fetch)切菜(decode)煮菜(execute)上盘出餐(load store and writeback). 然后前面就一读菜单后面就一直工作. 

举个例子c: 

```
int func(){

...

int a = 1;

a = a +3;

...

}
```

这段编译后大概就是

```
sub sp, 4 ; stack point increase变量都在函数栈里留一个位置因为是int所以留4

mov ebx, 1 ; ebx用来存1就是你定义 a了a=1

; mov [sp], ebx ;有时候如果需要就把ebx是值存到刚刚预留的栈里

; mov ebx, [sp] ;需要用的时候再读出来不是必然会发生的但是这两步可能发生

add ebx, 3 ; ebx = ebx+3, 当然你可以用其他register

...
```

你不需要读得懂因为我手打的分分钟错给你看. 然后这些东西就会跑到内存没错你运行软件的时候代码是先去到内存如果想了解他们怎么从硬盘跑到内存这是另外一个主题我这里先不讨论然后缓存又会把这些代码读取缓存就已经在SoC里面的cpu在从缓存里面读取别问为什么这么麻烦读这么多次都是为了省钱和稍微加快速度. 

由于是举例子我就随便乱说个decode. 这个是Intel公布的manual问我为什么不用本家农企是吧?因为我拿到农企那个不是对外公布的公布版我还要上网找. 

Opcode Instruction Op/ En 64-bit Mode Compat/ Leg Mode D

05 id ADD EAX, imm32 I Valid Valid Add imm32 to EAX.

在cacheline里面看起来大概是这样的 0x05__02___00000003

里面的_代表其他位不详细讲的大概这个翻译成机械码就是 要做05(ADD加法)在02(ebx实际上我印象中ebx是02然而eax是00不是01这些编码乱七八糟的Intel决定的别问我)后面的00000003就是32为imm32就是 add, ebx 03

cpu读了这条cacheline叫instruction fetch然后下一步就是把它decode解释成add, ebx 03,再下一步就是把运行(execute没错这么麻烦之后最后终于要算了)把算得的结果存到ebx上然后再看看需不需要存回去cacheline或者内存里面(load/store writeback). 这个就是cpu的基本运行原理. 

CPU pipeline

有时候会听到cpu流水线如果按照上面的做法没一个指令都要通过这几部来预算那么只有一部分电子器件在用的时候其他部分都在发呆浪费电. 就像是厨房里面从取菜到上盘全部都一个人做肯定要累死那个人但是你炒菜的时候是不是想如果有人已经帮你切好菜我就一直炒菜好了这样我们厨房工作效率就高了cpu也是这样. 

![2019-07-10-09-45-14.png](./images/2019-07-10-09-45-14.png)

转自 A Journey Through the CPU Pipeline
让你们失望了这张图不是猫咪. 这是一个经典的cpu运行流水线. 换成厨房理论就是一个人专门去食材一个人专门切菜一个人专门炒菜一个人专门上盘一个人专门给客人下单上菜是不是现代化很多呢！然而这样不能满足我们cpu的工程师我们还有branch prediction什么叫branch prediction呢?程序黎里面最耗时间的一个就是branch就像c里面的if你得到答案之前不知道是继续往下走还是进去if里面的括号. 就像下单的小哥那些犹豫不决而改菜单的人最讨厌了. 于是cpu里面有了这个东西他是怎么用的呢. 下单的小哥也不是笨蛋顾客a来了100多次了有80次都改单把猪肉改成鸡肉那么他下单时候小哥就先说了改鸡肉如果顾客a觉得还是猪肉吧就再抄如果顾客a真的改单那么厨房以及开始做了而且有80%的几率啊小哥还是挺聪明的吧. cpu也大概是这样根据每个loop的地址(顾客)来训练出一个未卜先知的系统. 

上图里面还有OOO(out of order)x86里面real mode可以用的general register只有8个eaxebx之类的64位之后增加了8个. 流水线工作如果

mov eax1; 

add eax1; 

sub eax2; 

你们发现问题了没eax用了再用但是流水线做add的时候eax是1sub在等add retire之前是不能做的那么你就不得不等. 那么流水线的效率就体现不出来了. 因为这里有一个write after write 的dependency就是同一个register你两个pipeline stage要用同一个register而且x86在传统模式只有8个registereax,ebx等等64位模式增加了一些. 所以这中情况是非常常见的. 为了解决这个问题就有了out of order execute in order commit. 就是不按顺序来运行指令但是按顺序完成指令. 

用厨房理论解释就是有这么一道菜(或者说两道菜)鸡要先煮了然后炸你煮熟鸡之前不能炸否则炸了再煮口感就不同了顾客肯定骂死你但是后面又有其他菜在等锅你是有的所以在煮鸡的时候你先做后面的菜然后鸡煮好了再炸. 出餐的时候你还是先出了这道鸡肉再出后的菜那样顾客就不会投诉出餐的顺序不按菜单了. 

# 参考

https://zhuanlan.zhihu.com/p/20731557?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=50718148919296

A Journey Through the CPU Pipeline --Bryan Wagstaff: https://www.gamedev.net/articles/programming/general-and-gameplay-programming/a-journey-through-the-cpu-pipeline-r3115

http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf -- intel isa manual