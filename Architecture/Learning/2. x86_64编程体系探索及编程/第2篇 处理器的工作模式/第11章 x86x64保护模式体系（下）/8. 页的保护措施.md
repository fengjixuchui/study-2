
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [访问权限位U/S的检查](#访问权限位us的检查)
  - [U/S权限位的判定](#us权限位的判定)
- [读/写权限位R/W的检查](#读写权限位rw的检查)
  - [R/W权限位的判定](#rw权限位的判定)
- [执行权限位XD的检查](#执行权限位xd的检查)
  - [XD权限位的判定](#xd权限位的判定)
- [4 缺页保护P标志位的检查](#4-缺页保护p标志位的检查)
  - [4.1 P标志位的判定](#41-p标志位的判定)
- [5 保留位的检查](#5-保留位的检查)

<!-- /code_chunk_output -->


在paging里, 处理器会对访问各级table entry及最终的page frame进行以下的检查.

① 访问权限位U/S的检查.
② 读/写权限位R/W的检查.
③ 执行权限位XD的检查.
④ 缺页保护位P的检查.
⑤ 保留位的检查.

# 访问权限位U/S的检查

各级table entry的U/S标志组合起来最终决定了page frame的访问权限.

① U/S=0时, 属于Supervisor访问权限.

② U/S=1时, 属于User访问权限.

对于一个page frame进行读/写访问时, U/S=0时, 只能在CPL=0、1或2级权限下访问. U/S=1时CPL可以在任何权限级别下进行访问.

对于一个page frame进行执行访问时, U/S=0时, 只能在CPL=0、1或2级权限下执行. U/S=1时依赖于SMEP功能(详见11.5.6节描述)是否开启, 当CR4.SMEP=1时, 只能在CPL=3级权限下执行. CR4.SMEP=0时(或不支持SMEP时), CPL可以在任何权限级别下执行.

## U/S权限位的判定

一个 page frame 的最终 U/S 由各级 table entry 的 U/S 进行组合, 另见 11.6.1.2 节所描述的 page frame 的访问权限.

① 在 IA-32e paging 模式下的 4K 页面映射中.

```x86asm
Page_frame.U/S=PML4E.U/S & PDPTE.U/S & PDE.U/S & PTE.U/S   ; 进行 AND 操作
```
由 PML4E、PDPTE、PDE, 以及 PTE 的 U/S 进行 AND 操作, 得出最终 4K page frame 的 U/S 标志位值.

② 在 IA-32e paging 模式下的 2M 页面映射中.

```x86asm
Page_frame.U/S=PML4E.U/S & PDPTE.U/S & PDE.U/S  ; 进行 AND 操作
```

由 PML4E、PDPTE, 以及 PDE 的 U/S 进行 AND 操作, 得出最终 2M page frame 的 U/S 值.

③ 在 IA-32e paging 模式下的 1G 页面映射中.

```x86asm
Page_frame.U/S=PML4E.U/S & PDPTE.U/S    ; 进行 AND 操作
```

由 PML4E 和 PDPTE 的 U/S 标志进行 AND 操作, 得出最终的 1G page frame 的 U/S 值.

④ 在 PAE paging 和 32 位 paging 模式下的 4K 页面映射中.

```x86asm
Page_frame.U/S=PDE.U/S & PTE.U/S    ; 进行 AND 操作
```
由 PDE 和 PTE 的 U/S 标志进行 AND 操作, PAE 模式下 PDPTE 不存在 U/S 标志位.

⑤ 在 PAE paging 模式和 32 位 paging 下的 2M 和 4M 页面映射中.

```x86asm
Page_frame.U/S=PDE.U/S                                         ;  2M/4M page frame的U/S
```

2M 和 4M 页面 page frame 的 U/S 来自于 PDE 里的 U/S 值.

# 读/写权限位R/W的检查

各级table entry的R/W标志位组合起来决定了最终page frame的读/写权限.

① R/W=0 时, page frame 是 Read-Only(只读的).

② R/W=1 时, page frame 是 Read/Write(可读写的).

在任何权限下可以对读/写的页进行写操作. 当 R/W=0 时, 在 CPL=3 级权限下, 不能对 page frame 进行写操作. 在 CPL=0、1 或 2 级权限下, 依赖于是否开启 CR0.WP(Write Protection) 功能. 当 CR0.WP=1 时, Supervisor 权限也不能对 Read-Only 页进行写操作. 当 CR0.WP=0 时, Supervisor 可以对 Read-Only 页进行写操作.

## R/W权限位的判定

R/W 标志位与 U/S 标志位所遭遇的情形一致. 上面 11.8.1 节里所描述符的 U/S 权限位的判定方式适合于 R/W 标志位(上面的计算式子中将 U/S 标志改为 R/W 标志位).

# 执行权限位XD的检查

在 PAE paging 模式和 IA-32e paging 模式下, 可以使用XD标志位来限制对 page frame 的执行. 在 32 位 paging 模式下 page frame 总是被允许执行的.

① XD=1 时, page frame 不能被执行.

② XD=0 时, page frame 允许执行.

`IA32_EFER.NXE` 控制 Execution Disable 功能的开启, `IA32_EFER.NXE=1` 时, XD 标志位有效. 否则为保留位, 必须为 0 值.

当 `IA32_EFER.NXE=1` 并且 `XD=1` 时的 page frame 不能执行, 否则 page frame 被允许执行. page frame 的执行检查, 还依赖于前面所述的 CR4.SMEP 控制位.

在 XD=0 的前提下, CR4.SMEP=1 时, 在 CPL=0、1 或 2 级权限下不能执行 User 权限的 page frame, 当 CR4.SMEP=0 时, 允许 Supervisor 对 User 的 page frame 执行.

## XD权限位的判定

同样, page frame的XD值由各级table entry的XD标志组合起来决定.

① 在IA-32e paging模式下的4K页面映射中.

```x86asm
Page_frame.XD=PML4E.XD | PDPTE.XD | PDE.XD | PTE.XD   ; 进行 OR 操作
```

由PML4E、PDPTE、PDE, 以及PTE的XD进行OR操作, 得出最终4K page frame的XD标志位值.

② 在IA-32e paging模式下的2M页面映射中.

```x86asm
Page_frame.XD=PML4E.XD | PDPTE.XD | PDE.XD             ; 进行 OR 操作
```

由PML4E、PDPTE, 以及PDE的XD进行OR操作, 得出最终2M page frame的XD值.

③ 在IA-32e paging模式下的1G页面映射中.

```x86asm
Page_frame.XD=PML4E.XD | PDPTE.XD                           ; 进行 OR 操作
```
由PML4E和PDPTE的XD标志进行OR操作, 得出最终的1G page frame的XD值.

④ 在PAE paging模式下的4K页面映射中.

```x86asm
Page_frame.XD=PDE.XD | PTE.XD                                ; 进行 OR 操作
```
由PDE和PTE的XD标志进行OR操作.

⑤ 在PAE paging模式的2M页面映射中.

```x86asm
Page_frame.XD=PDE.XD                         ;  2M page frame的XD
```

2M page frame的XD来自于PDE里的XD值.

由上面的page frame XD值来看, 只要有任何一级table entry的XD为1时, 所对应的page frame就是不可执行的.

# 4 缺页保护P标志位的检查

同样, 各级table entry的P标志位组合起来决定了最终page是否被提交到物理地址空间中.

① P=0时, 不存在内存中.

② P=1时, 已在内存中.

处理器对访问P=0的page frame会产生#PF异常.

## 4.1 P标志位的判定

在线性地址的访问中, 仅当在转换物理地址过程中所有table entry的P=1时, 页的转换才是成功的. 这与U/S标志及R/W标志位所遭遇的情形是一致的(在11.8.1节的计算式子中U/S标志位换为P标志位), 也就是所有table entry的P标志位进行与操作.

# 5 保留位的检查

当各级table entry的保留位不为0时, table entry是无效的, 会产生#PF异常.

关注下列table entry中的保留位.

① 11.3.2.2节中的32位paging模式下的4M页面的PDE结构保留位.

② 11.4.4.1节中的PAE paging模式下的2M页面的PDE结构保留位.

③ 11.4.4.2节中的PAE paging模式下的4K页面的PDE结构保留位.

④ 11.4.5节中的PAE paging模式下的PTE结构保留位.

⑤ 11.5.2节中的IA-32e paging模式下PML4E结构保留位.

⑥ 11.5.3.1节中的IA-32e paging模式下1G页面PDPTE结构保留位.

⑦ 11.5.3.2节中的IA-32e paging模式下4K/2M页面PDPTE结构保留位.

⑧ 11.5.4节中的IA-32e paging模式下2M页面PDE结构保留位.

⑨ 11.5.4节中的IA-32e paging模式下4K页面PDE结构保留位.

⑩ 11.5.5节中的IA-32e paging模式下的PTE结构保留位.

在这些保留位检查中, 许多table entry的保留位依赖于MAXPHYADDR值.

① 当MAXPHYADDR为36时, table entry的[51: 36]为保留位.

② 当MAXPHYADDR为40时, table entry的[51: 40]为保留位.

③ 当MAXPHYADDR为52时, table entry的[51: 12]为有效位.

当IA32_EFER.NXE=1时, bit63是XD标志位, 否则为保留位, 须为0值.

下面的保留位检查将产生\#GP异常.

① 11.4.3节的PAE paging模式下的PDPTE结构保留位.

② 11.5.1.1节的CR3结构中的保留位.