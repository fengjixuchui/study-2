

在nasm中可以在同一个源代码文件里同时指出16位代码、32位代码, 以及64位代码。

```
bits 16
… …                               ; 以下是 16位代码
bits 32
… …                               ; 以下是 32位代码
bits 64
… …                               ; 以下是 64位代码
```

不用担心这里会有什么问题, **编译器**会为**每部分**生成**正确的机器指令**。关于16位机器码、32位机器码以及64位机器码, 详见笔者个人网站里的《x86/x64指令系统》篇章, 地址为 http://www.mouseos.com/x64/default.html 。

>16位编程、32位编程, 以及64位编程有什么不同之处？

这确实需要简单了解一下。

# 通用寄存器

## 16位和32位

在16位和32位编程里, 可以使用的通用寄存器是一样的, 如下所示。

![2020-02-09-21-22-18.png](./images/2020-02-09-21-22-18.png)

在**16位编程**里可以使用**32位的寄存器**, 在**32位编程**里也可以使用**16位的寄存器**, 编译器会生成**正确的机器码**。

```
bits 16      ； 为16 位代码而编译
mov eax, 1                   ； 机器码是: 66 b8 01 00 00 00
```

上面这段代码为**16位代码编译**, 使用了**32位的寄存器**, 编译器会自动加上`default operand-size override prefix`(66H字节), 这个`66H`字节用来调整为正确的操作数。

```
bits 32      ； 为32位代码而编译
mov eax, 1                   ； 机器码是: b8 01 00 00 00
```

这段代码的汇编语句是完全一样的, 只不过是为32位代码而编译, 它们的机器码就是不一样的。

## x64体系

在**x64体系**里, 在原来的**8个通用寄存器**的基础上**新增了8个寄存器**, 并且原来的寄存器也得到了扩展。

在64位编程里可以使用的通用寄存器如下表所示。

![2020-02-09-21-24-01.png](./images/2020-02-09-21-24-01.png)

在64位编程里可以使用**20个8位寄存器**, 和**16个16位**、**32位**及**64位寄存器**, 寄存器体系得到了完整的补充。

**所有的16个寄存器**都可以分割出相应的8位、16位或32位寄存器。在16位编程和32位编程里, sp、bp、si及di不能使用低8位。在64位编程里, 可以使用分割出的spl、bpl、sil及dil低8位寄存器。

64位的r8～r15寄存器分割出相对应的8位、16位及32位寄存器形式为: r8b～r15b、r8w～r15w, 以及r8d～r15d。

```
bits 64      ； 为64位代码编译
mov r8b, 1
mov spl, r8b
```

比如上面这两条指令必须在64位下使用, r8b和spl寄存器在16位和32位下是无效的。

# 操作数大小

在16位编程和32位编程下, 寄存器没有使用上的不便, 32位的操作数依旧可以在16位编程里使用, 而16位的操作数也可以在32位编程下使用。

```
bits 16
push word 1                         ； 16位操作数
push dword 1                        ； 32位操作数
call ax       ； 16 位操作数
call eax       ； 32 位操作数
bits 32
push word 1                         ； 16位操作数
push dword 1                        ； 32位操作数
call ax       ； 16 位操作数
call eax       ； 32 位操作数
```

上面的代码完全可以用在16编程和32位编程里。在64位编程里操作数可以扩展到64位。

```
bits 64
mov rax, 0x1122334455667788 ； 机器码是: b8 8877665544332211
```

这条指令直接使用了64位立即操作数。

# 64位模式下的内存地址

在64位编程里可以使用宽达**64位的地址值**。

## canonical地址形式

然而, 在x64体系里只实现了**48位的virtual address**, 高16位被用做符号扩展。这高16位必须要么全是0, 要么全是1, 这种形式的地址被称为canonical地址, 如下所示。

![2020-02-11-00-22-55.png](./images/2020-02-11-00-22-55.png)

与canonical地址形式相对的是`non-canoncial`地址形式, 如下所示。在64位模式下non-canonical地址形式是不合法的。

![2020-02-11-00-23-55.png](./images/2020-02-11-00-23-55.png)

在64位的线性地址空间里, 

① 0x00000000_00000000到0x00007FFF_FFFFFFFF是合法的canonical地址。

② 0x00008000_00000000到0xFFFF7FFF_FFFFFFFF是非法的non-canonical地址。

③ 0xFFFF8000_00000000到0xFFFFFFFF_FFFFFFFF是合法的canonical地址。

在non-canonical地址形式里, 它们的符号扩展位出现了问题。

2.4.4 内存寻址模式

在16位和32位编程里, 16位和32位的寻址模式都可以使用。在64位下, 32位的寻址模式被扩展为64位, 而且不能使用16位的寻址模式。

16位内存寻址模式

在16位编程里, 内存操作数的寻址模式如下所示。


在16位寻址模式里基址只能使用bx和bp寄存器, 变址只能使用si和di寄存器, displacement值使用8位或16位的偏移量。
32位内存寻址模式
在32位编程里, 内存操作数的寻址模式如下所示。

基址和变址可以是8个通用寄存器。displacement的值是8位或32位。
如以下指令中地址操作数的使用: 
 mov eax, [eax + ecx*4 + 0x1c]
这是典型的“基址(base)加变址(index)寻址加上偏移量寻址”。
64位内存寻址模式
64位寻址模式形式和32位寻址模式是一致的, 基址和变址寄存器默认情况下使用64位的通用寄存器。
64位寻址模式新增了一个RIP-Relative寻址形式。
RIP-Relative寻址: [rip+disp32]
这个displacement值是32位宽, 地址值依赖于当前的RIP(指令指针)值。可是nasm的语法并不支持直接使用rip, 像下面的用法是错误的。
 mov rax, [rip + 0x1c]     ； error: symbol 'rip' undefined
rip是处理器内部使用的寄存器, 并不是外部编程可用的资源, 但在yasm语法上是支持的。nasm中的解决方案是使用rel指示字。
 mov rax, [rel table]        ； rel指示字后面跟上一个地址label
这样就将编译为RIP-Relative寻址模式。RIP-Relative寻址最直接的好处是很容易构造PIC代码结构。
什么是PIC？PIC是指Position-Independent Code(不依赖于位置的代码)。
假设有一条指令调用了GetStdHandle()函数。
 00073BEC     FF15 DC810700      call  dword ptr [__imp__GetStdHandle]
call指令从 [__imp__GetStdHandle] 里读取 Kernel32.dll 库里的 GetStdHandle() 入口地址, 这里的__imp__GetStdHandle是绝对地址, 地址值为 0x000781DC。

__imp__ReadFile:  000781D4   A3 3E 4D 75 __imp__XXXX:  000781D8   2C 3F 4D 75 __imp__GetStdHandle:  000781DC   83 51 4D 75
在0x000781DC(__imp__GetStdHandle)里放着的就是GetStdHandle()在库里的地址0x754D5183。
那么这条call指令就属于PDC(Position-Dependent Code, 依赖于位置的代码)。
 FF15   DC810700            call   dword ptr [__imp__GetStdHandle@4 (781DCh)]      ----------   依赖于这个绝对地址
由于使用了绝对地址, 当__imp__GetStdHandle的位置因重定位而有可能改变时, 这条call指令就会出错, 这个绝对地址已经不是__imp__GetStdHandle的地址了。
在x64体系的64位环境下, 使用RIP-Relative很容易得到改善。
 00073BEC  48 8d 85 e1 45 00 00  lea rbx, [rip + 0x45e1]  ； 得到 __IMP_FUNCTION_TABLE的地址 00073BF3  48 03 1c c3              add rbx, [rbx + rax * 8] ； 得到 __imp_GetStdHandle 的地址 00073BF7  ff 13                      call [rbx]                   ； call [__imp_GetStdHandle] ... ... __IMP_FUNCTION_TABLE:                                ；  函数表地址在 0x000781D4 000781D4   A3 3E 4D 75 000781D8   2C 3F 4D 75 000781DC   83 51 4D 75                                ； GetStdHandle()的入口地址
在nasm里应该是lea rbx, [rel__IMP_FUNCTION_TABLE], 这里使用rip是为了便于理解。使用lea指令配合RIP-Relative寻址得到的__IMP_FUNCTION_TABLE的地址不会因为重定位改变而改变, 因为这里使用基于RIP的相对地址, 没什么绝对地址, 而这个代码的相对地址是不会变的。
内存寻址模式的使用
在16位编程和32位编程下依旧可以使用16位地址模式和32位地址模式。
 bits 16 mov ax, [bx+si]                        ； 使用 16 位地址模式 mov eax, [eax+ecx*4]                 ； 使用 32 位地址模式 bits 32 mov ax, [bx+si]                        ； 使用 16 位地址模式 mov eax, [eax+ecx*4]                 ； 使用 32 位地址模式
指令的默认地址(16位或32位)依赖于CS.D标志位(在保护模式章节会有详细的描述), CS.D=1时使用32位的寻址模式, CS.L=0使用16位的寻址模式。
上面的代码中, 编译器会生成正确的机器指令, 当改变default address-size(默认的地址尺寸)时, 生成的机器指令会相应地插入67H(address-size override prefix)这个前缀值。
在64位模式下, 也可以使用67H改变默认的64位寻址模式, 改变为32位的寻址模式。
2.4.5 内存寻址范围
在正常的情况下, 16位实模式编程里, 虽然可以使用32位的寻址模式, 可是依然逃不过64K内存空间的限制(实际上可以改变地址值大小, 在后面实模式的章节里进行探讨)。
假如在16位实模式下写出如下代码。
 mov eax, 0x200000                       ； 2M 地址 mov eax, [eax]                           ； 错误: > 64K mov eax, 0x2000 mov ecx, 1 mov eax, [eax + ecx * 4]              ； 正确: <= 64K
在32位保护模式下, 可以寻址4G的线性空间, OS通常的做法会使用最大的4G寻址空间；而在64位环境, 寻址空间增加到了64位, 这个空间大小是不会改变的。
2.4.6 使用的指令限制
有些指令在64位环境里是不可用的, 在编程过程中应避免, 典型的如push cs/ds/es/ss指令和pop ds/es/ss指令, 这些在16位和32位下常用的指令在64位模式下是无效的。
 call 0x0018: 0x00100000               ； 无效 jmp  0x0018: 0x00100000                ； 无效
这些常用的direct far call/jmp(直接的远程call/jmp)也是无效的。此外还需要注意是否有权限去执行指令, 像cli/sti这类指令需要0级的执行权限, in/out指令需要高于eflags.IOPL的执行权限。这里不再一一列举。